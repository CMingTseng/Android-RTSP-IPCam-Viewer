From 3a44b36d701a92a57314b49722db5a199633caef Mon Sep 17 00:00:00 2001
From: "Warren R. Bank" <warren.r.bank@gmail.com>
Date: Wed, 1 Jan 2020 20:02:32 -0800
Subject: [PATCH] release-v2

---
 .../exoplayer2/AbstractConcatenatedTimeline.java   | 319 ----------
 .../exoplayer2/AudioBecomingNoisyManager.java      |  81 +++
 .../android/exoplayer2/AudioFocusManager.java      | 456 +++++++++++++
 .../com/google/android/exoplayer2/BasePlayer.java  |   6 +
 .../google/android/exoplayer2/BaseRenderer.java    |  40 +-
 .../main/java/com/google/android/exoplayer2/C.java | 208 +++---
 .../android/exoplayer2/DefaultMediaClock.java      |   7 -
 .../exoplayer2/DefaultRenderersFactory.java        |  27 +
 .../android/exoplayer2/ExoPlaybackException.java   |  57 +-
 .../com/google/android/exoplayer2/ExoPlayer.java   | 156 +----
 .../android/exoplayer2/ExoPlayerFactory.java       |  11 +-
 .../google/android/exoplayer2/ExoPlayerImpl.java   | 329 ++--------
 .../android/exoplayer2/ExoPlayerImplInternal.java  | 537 ++++++----------
 .../android/exoplayer2/ExoPlayerLibraryInfo.java   |   6 +-
 .../java/com/google/android/exoplayer2/Format.java |  52 +-
 .../android/exoplayer2/MediaPeriodHolder.java      |  24 +-
 .../android/exoplayer2/MediaPeriodQueue.java       |   7 +-
 .../android/exoplayer2/NoSampleRenderer.java       |  13 +-
 .../java/com/google/android/exoplayer2/Player.java | 106 ++-
 .../com/google/android/exoplayer2/Playlist.java    | 708 ---------------------
 .../android/exoplayer2/RendererCapabilities.java   | 200 +++++-
 .../google/android/exoplayer2/SimpleExoPlayer.java | 394 ++++++------
 .../com/google/android/exoplayer2/Timeline.java    |  83 +--
 .../google/android/exoplayer2/WakeLockManager.java | 102 +++
 .../exoplayer2/analytics/AnalyticsCollector.java   |  27 +-
 .../exoplayer2/analytics/AnalyticsListener.java    |  18 +
 .../exoplayer2/analytics/PlaybackStats.java        |  33 +-
 .../analytics/PlaybackStatsListener.java           | 105 ++-
 .../exoplayer2/audio/AudioFocusManager.java        | 446 -------------
 .../android/exoplayer2/audio/AudioProcessor.java   | 103 +--
 .../audio/AudioRendererEventListener.java          |  33 +-
 .../exoplayer2/audio/BaseAudioProcessor.java       |  74 +--
 .../audio/ChannelMappingAudioProcessor.java        |  60 +-
 .../android/exoplayer2/audio/DefaultAudioSink.java |  24 +-
 .../audio/FloatResamplingAudioProcessor.java       |  29 +-
 .../exoplayer2/audio/MediaCodecAudioRenderer.java  | 209 ++++--
 .../exoplayer2/audio/ResamplingAudioProcessor.java |  26 +-
 .../audio/SilenceSkippingAudioProcessor.java       |  24 +-
 .../audio/SimpleDecoderAudioRenderer.java          |  37 +-
 .../exoplayer2/audio/SonicAudioProcessor.java      | 115 ++--
 .../exoplayer2/audio/TeeAudioProcessor.java        |  19 +-
 .../exoplayer2/audio/TrimmingAudioProcessor.java   |  61 +-
 .../android/exoplayer2/drm/DefaultDrmSession.java  |  36 +-
 .../drm/DefaultDrmSessionEventListener.java        |   8 +-
 .../exoplayer2/drm/DefaultDrmSessionManager.java   | 482 ++++++++------
 .../google/android/exoplayer2/drm/DrmSession.java  |  39 +-
 .../android/exoplayer2/drm/DrmSessionManager.java  |  51 +-
 .../android/exoplayer2/drm/DummyExoMediaDrm.java   |   7 +
 .../exoplayer2/drm/ErrorStateDrmSession.java       |   9 +-
 .../google/android/exoplayer2/drm/ExoMediaDrm.java |  50 +-
 .../android/exoplayer2/drm/FrameworkMediaDrm.java  |  27 +-
 .../exoplayer2/drm/OfflineLicenseHelper.java       |  80 +--
 .../android/exoplayer2/extractor/Extractor.java    |   4 +
 .../exoplayer2/extractor/MpegAudioHeader.java      |   4 +-
 .../android/exoplayer2/extractor/SeekMap.java      |   2 +-
 .../extractor/mkv/MatroskaExtractor.java           | 498 +++++++++------
 .../extractor/mp3/ConstantBitrateSeeker.java       |   3 +-
 .../exoplayer2/extractor/mp3/MlltSeeker.java       |   2 +-
 .../exoplayer2/extractor/mp3/Mp3Extractor.java     |  56 +-
 .../android/exoplayer2/extractor/mp3/Seeker.java   |  60 ++
 .../exoplayer2/extractor/mp3/VbriSeeker.java       |   6 +-
 .../exoplayer2/extractor/mp3/XingSeeker.java       |   6 +-
 .../exoplayer2/extractor/mp4/AtomParsers.java      |  14 +-
 .../exoplayer2/extractor/mp4/Mp4Extractor.java     |   6 +-
 .../exoplayer2/extractor/mp4/PsshAtomUtil.java     |   3 +-
 .../android/exoplayer2/extractor/mp4/Sniffer.java  |   4 -
 .../android/exoplayer2/extractor/mp4/Track.java    |   2 +
 .../exoplayer2/extractor/ogg/FlacReader.java       |  17 +-
 .../exoplayer2/extractor/ts/Ac3Extractor.java      |   2 +-
 .../android/exoplayer2/extractor/ts/Ac3Reader.java |   2 +-
 .../exoplayer2/extractor/ts/Ac4Extractor.java      |   3 +-
 .../android/exoplayer2/extractor/ts/Ac4Reader.java |   3 +-
 .../exoplayer2/extractor/ts/AdtsExtractor.java     |  66 +-
 .../exoplayer2/extractor/ts/AdtsReader.java        |   2 +-
 .../android/exoplayer2/extractor/ts/DtsReader.java |   2 +-
 .../exoplayer2/extractor/ts/DvbSubtitleReader.java |   2 +-
 .../extractor/ts/ElementaryStreamReader.java       |   5 +-
 .../exoplayer2/extractor/ts/H262Reader.java        |   2 +-
 .../exoplayer2/extractor/ts/H264Reader.java        |   2 +-
 .../exoplayer2/extractor/ts/H265Reader.java        |   2 +-
 .../android/exoplayer2/extractor/ts/Id3Reader.java |   2 +-
 .../exoplayer2/extractor/ts/LatmReader.java        |   2 +-
 .../exoplayer2/extractor/ts/MpegAudioReader.java   |   2 +-
 .../android/exoplayer2/extractor/ts/PesReader.java |   1 -
 .../exoplayer2/extractor/ts/PsExtractor.java       |   2 +-
 .../extractor/ts/SectionPayloadReader.java         |   4 +-
 .../exoplayer2/extractor/ts/SectionReader.java     |   3 +-
 .../android/exoplayer2/extractor/ts/SeiReader.java |   2 +-
 .../extractor/ts/SpliceInfoSectionReader.java      |   3 +-
 .../exoplayer2/extractor/ts/TsExtractor.java       |   2 +-
 .../exoplayer2/extractor/ts/TsPayloadReader.java   |  82 ++-
 .../exoplayer2/extractor/ts/UserDataReader.java    |   3 +-
 .../exoplayer2/extractor/wav/WavHeader.java        |   2 +-
 .../exoplayer2/extractor/wav/WavHeaderReader.java  |   2 +
 .../exoplayer2/mediacodec/MediaCodecInfo.java      |  50 +-
 .../exoplayer2/mediacodec/MediaCodecRenderer.java  | 175 +++--
 .../exoplayer2/mediacodec/MediaCodecUtil.java      |  34 +-
 .../android/exoplayer2/metadata/Metadata.java      |  18 +-
 .../metadata/MetadataDecoderFactory.java           |  31 +-
 .../exoplayer2/metadata/MetadataRenderer.java      |  30 +-
 .../metadata/emsg/EventMessageDecoder.java         |  28 +-
 .../exoplayer2/metadata/emsg/package-info.java     |  19 +
 .../exoplayer2/metadata/flac/package-info.java     |  19 +
 .../exoplayer2/metadata/icy/IcyDecoder.java        |  14 +-
 .../android/exoplayer2/metadata/icy/IcyInfo.java   |  26 +-
 .../exoplayer2/metadata/icy/package-info.java      |  19 +
 .../android/exoplayer2/metadata/id3/ApicFrame.java |   2 +-
 .../exoplayer2/metadata/id3/Id3Decoder.java        |  22 +-
 .../exoplayer2/metadata/id3/package-info.java      |  19 +
 .../android/exoplayer2/metadata/package-info.java  |  19 +
 .../metadata/scte35/SpliceInfoDecoder.java         |  10 +-
 .../exoplayer2/metadata/scte35/package-info.java   |  19 +
 .../exoplayer2/offline/ActionFileUpgradeUtil.java  |   4 +
 .../exoplayer2/offline/DefaultDownloadIndex.java   |  21 +-
 .../android/exoplayer2/offline/Download.java       |   4 +-
 .../android/exoplayer2/offline/DownloadHelper.java |  25 +-
 .../android/exoplayer2/offline/DownloadIndex.java  |   6 +
 .../offline/DownloaderConstructorHelper.java       |  10 +-
 .../exoplayer2/offline/ProgressiveDownloader.java  |   6 +
 .../exoplayer2/offline/SegmentDownloader.java      |   3 +-
 .../android/exoplayer2/offline/StreamKey.java      |   3 +-
 .../exoplayer2/offline/WritableDownloadIndex.java  |  14 +
 .../source/AbstractConcatenatedTimeline.java       | 327 ++++++++++
 .../android/exoplayer2/source/BaseMediaSource.java |  23 +-
 .../exoplayer2/source/ClippingMediaPeriod.java     |  15 +-
 .../exoplayer2/source/CompositeMediaSource.java    |   2 +-
 .../source/CompositeSequenceableLoader.java        |   9 +
 .../source/ConcatenatingMediaSource.java           |   1 -
 .../source/DecryptableSampleQueueReader.java       | 208 ------
 .../source/DefaultMediaSourceEventListener.java    |  77 +--
 .../exoplayer2/source/ExtractorMediaSource.java    |   2 +-
 .../android/exoplayer2/source/IcyDataSource.java   |   2 +-
 .../exoplayer2/source/LoopingMediaSource.java      |   1 -
 .../exoplayer2/source/MaskingMediaPeriod.java      |  15 +-
 .../exoplayer2/source/MaskingMediaSource.java      |  13 +-
 .../android/exoplayer2/source/MediaPeriod.java     |  21 +-
 .../android/exoplayer2/source/MediaSource.java     |  25 +-
 .../source/MediaSourceEventListener.java           |  30 +-
 .../exoplayer2/source/MergingMediaPeriod.java      |  19 +-
 .../exoplayer2/source/ProgressiveMediaPeriod.java  |  86 +--
 .../exoplayer2/source/ProgressiveMediaSource.java  |  18 +-
 .../exoplayer2/source/SampleMetadataQueue.java     | 161 ++++-
 .../android/exoplayer2/source/SampleQueue.java     | 135 ++--
 .../exoplayer2/source/SequenceableLoader.java      |   3 +
 .../exoplayer2/source/SilenceMediaSource.java      |  16 +-
 .../exoplayer2/source/SinglePeriodTimeline.java    |  17 +-
 .../exoplayer2/source/SingleSampleMediaPeriod.java |  17 +-
 .../exoplayer2/source/SingleSampleMediaSource.java |   9 +-
 .../exoplayer2/source/chunk/ChunkSampleStream.java |  32 +-
 .../android/exoplayer2/source/chunk/DataChunk.java |  11 +-
 .../com/google/android/exoplayer2/text/Cue.java    |   7 +-
 .../exoplayer2/text/SimpleSubtitleDecoder.java     |   8 +-
 .../exoplayer2/text/SubtitleDecoderFactory.java    |  57 +-
 .../android/exoplayer2/text/TextRenderer.java      |  25 +-
 .../android/exoplayer2/text/cea/Cea708Cue.java     |   6 -
 .../android/exoplayer2/text/cea/Cea708Decoder.java |   4 +-
 .../android/exoplayer2/text/cea/package-info.java  |  19 +
 .../android/exoplayer2/text/dvb/DvbParser.java     | 133 ++--
 .../android/exoplayer2/text/dvb/package-info.java  |  19 +
 .../android/exoplayer2/text/package-info.java      |  19 +
 .../android/exoplayer2/text/pgs/package-info.java  |  19 +
 .../android/exoplayer2/text/ssa/SsaDecoder.java    | 417 +++++++++---
 .../exoplayer2/text/ssa/SsaDialogueFormat.java     |  83 +++
 .../android/exoplayer2/text/ssa/SsaStyle.java      | 301 +++++++++
 .../android/exoplayer2/text/ssa/SsaSubtitle.java   |  21 +-
 .../android/exoplayer2/text/ssa/package-info.java  |  19 +
 .../exoplayer2/text/subrip/SubripDecoder.java      |  19 +-
 .../exoplayer2/text/subrip/package-info.java       |  19 +
 .../android/exoplayer2/text/ttml/package-info.java |  19 +
 .../android/exoplayer2/text/tx3g/package-info.java |  19 +
 .../exoplayer2/text/webvtt/WebvttCssStyle.java     |  41 +-
 .../android/exoplayer2/text/webvtt/WebvttCue.java  | 256 ++++++--
 .../exoplayer2/text/webvtt/WebvttCueParser.java    | 103 +--
 .../exoplayer2/text/webvtt/WebvttParserUtil.java   |   8 +-
 .../exoplayer2/text/webvtt/WebvttSubtitle.java     |  25 +-
 .../exoplayer2/text/webvtt/package-info.java       |  20 +
 .../trackselection/AdaptiveTrackSelection.java     |  10 +-
 .../trackselection/DefaultTrackSelector.java       | 198 +++---
 .../trackselection/MappingTrackSelector.java       | 131 ++--
 .../exoplayer2/trackselection/TrackSelection.java  |  44 +-
 .../trackselection/TrackSelectionParameters.java   |   6 +
 .../exoplayer2/trackselection/TrackSelector.java   |   2 +-
 .../exoplayer2/upstream/DataSchemeDataSource.java  |   2 +
 .../android/exoplayer2/upstream/DataSpec.java      | 106 ++-
 .../exoplayer2/upstream/DefaultBandwidthMeter.java | 345 +++++-----
 .../exoplayer2/upstream/DefaultDataSource.java     |   1 -
 .../exoplayer2/upstream/DefaultHttpDataSource.java |  17 +-
 .../upstream/DefaultLoadErrorHandlingPolicy.java   |   1 +
 .../exoplayer2/upstream/FileDataSource.java        |  56 +-
 .../exoplayer2/upstream/FileDataSourceFactory.java |  20 +-
 .../exoplayer2/upstream/ResolvingDataSource.java   |   6 +-
 .../exoplayer2/upstream/TransferListener.java      |   2 +-
 .../android/exoplayer2/upstream/UdpDataSource.java |  54 +-
 .../android/exoplayer2/upstream/cache/Cache.java   |  40 +-
 .../exoplayer2/upstream/cache/CacheDataSink.java   |   3 +-
 .../exoplayer2/upstream/cache/CacheDataSource.java |  31 +-
 .../upstream/cache/CacheDataSourceFactory.java     |   4 +-
 .../upstream/cache/CacheFileMetadataIndex.java     |  27 +-
 .../exoplayer2/upstream/cache/CacheUtil.java       |  21 +-
 .../upstream/cache/CachedContentIndex.java         |  18 +-
 .../cache/LeastRecentlyUsedCacheEvictor.java       |  27 +-
 .../exoplayer2/upstream/cache/SimpleCache.java     |  44 +-
 .../exoplayer2/upstream/cache/SimpleCacheSpan.java |  13 +-
 .../upstream/crypto/AesCipherDataSink.java         |   5 +-
 .../google/android/exoplayer2/util/Assertions.java |  36 ++
 .../android/exoplayer2/util/ConditionVariable.java |   4 +
 .../android/exoplayer2/util/EventLogger.java       | 128 ++--
 .../exoplayer2/util/FlacStreamMetadata.java        |   2 +-
 .../com/google/android/exoplayer2/util/GlUtil.java |   2 +-
 .../android/exoplayer2/util/ParsableBitArray.java  |  21 +-
 .../com/google/android/exoplayer2/util/Util.java   | 264 +++++---
 .../exoplayer2/video/DolbyVisionConfig.java        |   2 +-
 .../exoplayer2/video/MediaCodecVideoRenderer.java  | 151 +++--
 .../video/SimpleDecoderVideoRenderer.java          | 245 ++++---
 .../video/VideoDecoderGLSurfaceView.java           |  57 ++
 .../exoplayer2/video/VideoDecoderOutputBuffer.java |  41 +-
 .../video/VideoDecoderOutputBufferRenderer.java    |  27 +
 .../exoplayer2/video/VideoDecoderRenderer.java     | 241 +++++++
 .../video/VideoFrameMetadataListener.java          |  11 +-
 .../video/VideoRendererEventListener.java          |  36 +-
 .../video/spherical/CameraMotionRenderer.java      |   6 +-
 230 files changed, 7490 insertions(+), 6385 deletions(-)
 delete mode 100644 core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/AudioBecomingNoisyManager.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java
 delete mode 100644 core/src/main/java/com/google/android/exoplayer2/Playlist.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java
 delete mode 100644 core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Seeker.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/metadata/emsg/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/metadata/flac/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/metadata/icy/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/metadata/id3/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/metadata/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/metadata/scte35/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
 delete mode 100644 core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/cea/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/dvb/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/pgs/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDialogueFormat.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaStyle.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/ssa/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/subrip/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/ttml/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/tx3g/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/text/webvtt/package-info.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderGLSurfaceView.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java
 create mode 100644 core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java

diff --git a/core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java b/core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java
deleted file mode 100644
index a307e4b..0000000
--- a/core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2;
-
-import android.util.Pair;
-import com.google.android.exoplayer2.source.ShuffleOrder;
-import com.google.android.exoplayer2.util.Assertions;
-
-/** Abstract base class for the concatenation of one or more {@link Timeline}s. */
-public abstract class AbstractConcatenatedTimeline extends Timeline {
-
-  private final int childCount;
-  private final ShuffleOrder shuffleOrder;
-  private final boolean isAtomic;
-
-  /**
-   * Returns UID of child timeline from a concatenated period UID.
-   *
-   * @param concatenatedUid UID of a period in a concatenated timeline.
-   * @return UID of the child timeline this period belongs to.
-   */
-  @SuppressWarnings("nullness:return.type.incompatible")
-  public static Object getChildTimelineUidFromConcatenatedUid(Object concatenatedUid) {
-    return ((Pair<?, ?>) concatenatedUid).first;
-  }
-
-  /**
-   * Returns UID of the period in the child timeline from a concatenated period UID.
-   *
-   * @param concatenatedUid UID of a period in a concatenated timeline.
-   * @return UID of the period in the child timeline.
-   */
-  @SuppressWarnings("nullness:return.type.incompatible")
-  public static Object getChildPeriodUidFromConcatenatedUid(Object concatenatedUid) {
-    return ((Pair<?, ?>) concatenatedUid).second;
-  }
-
-  /**
-   * Returns a concatenated UID for a period or window in a child timeline.
-   *
-   * @param childTimelineUid UID of the child timeline this period or window belongs to.
-   * @param childPeriodOrWindowUid UID of the period or window in the child timeline.
-   * @return UID of the period or window in the concatenated timeline.
-   */
-  public static Object getConcatenatedUid(Object childTimelineUid, Object childPeriodOrWindowUid) {
-    return Pair.create(childTimelineUid, childPeriodOrWindowUid);
-  }
-
-  /**
-   * Sets up a concatenated timeline with a shuffle order of child timelines.
-   *
-   * @param isAtomic Whether the child timelines shall be treated as atomic, i.e., treated as a
-   *     single item for repeating and shuffling.
-   * @param shuffleOrder A shuffle order of child timelines. The number of child timelines must
-   *     match the number of elements in the shuffle order.
-   */
-  public AbstractConcatenatedTimeline(boolean isAtomic, ShuffleOrder shuffleOrder) {
-    this.isAtomic = isAtomic;
-    this.shuffleOrder = shuffleOrder;
-    this.childCount = shuffleOrder.getLength();
-  }
-
-  @Override
-  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
-      boolean shuffleModeEnabled) {
-    if (isAtomic) {
-      // Adapt repeat and shuffle mode to atomic concatenation.
-      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
-      shuffleModeEnabled = false;
-    }
-    // Find next window within current child.
-    int childIndex = getChildIndexByWindowIndex(windowIndex);
-    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    int nextWindowIndexInChild = getTimelineByChildIndex(childIndex).getNextWindowIndex(
-        windowIndex - firstWindowIndexInChild,
-        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
-        shuffleModeEnabled);
-    if (nextWindowIndexInChild != C.INDEX_UNSET) {
-      return firstWindowIndexInChild + nextWindowIndexInChild;
-    }
-    // If not found, find first window of next non-empty child.
-    int nextChildIndex = getNextChildIndex(childIndex, shuffleModeEnabled);
-    while (nextChildIndex != C.INDEX_UNSET && getTimelineByChildIndex(nextChildIndex).isEmpty()) {
-      nextChildIndex = getNextChildIndex(nextChildIndex, shuffleModeEnabled);
-    }
-    if (nextChildIndex != C.INDEX_UNSET) {
-      return getFirstWindowIndexByChildIndex(nextChildIndex)
-          + getTimelineByChildIndex(nextChildIndex).getFirstWindowIndex(shuffleModeEnabled);
-    }
-    // If not found, this is the last window.
-    if (repeatMode == Player.REPEAT_MODE_ALL) {
-      return getFirstWindowIndex(shuffleModeEnabled);
-    }
-    return C.INDEX_UNSET;
-  }
-
-  @Override
-  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
-      boolean shuffleModeEnabled) {
-    if (isAtomic) {
-      // Adapt repeat and shuffle mode to atomic concatenation.
-      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
-      shuffleModeEnabled = false;
-    }
-    // Find previous window within current child.
-    int childIndex = getChildIndexByWindowIndex(windowIndex);
-    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    int previousWindowIndexInChild = getTimelineByChildIndex(childIndex).getPreviousWindowIndex(
-        windowIndex - firstWindowIndexInChild,
-        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
-        shuffleModeEnabled);
-    if (previousWindowIndexInChild != C.INDEX_UNSET) {
-      return firstWindowIndexInChild + previousWindowIndexInChild;
-    }
-    // If not found, find last window of previous non-empty child.
-    int previousChildIndex = getPreviousChildIndex(childIndex, shuffleModeEnabled);
-    while (previousChildIndex != C.INDEX_UNSET
-        && getTimelineByChildIndex(previousChildIndex).isEmpty()) {
-      previousChildIndex = getPreviousChildIndex(previousChildIndex, shuffleModeEnabled);
-    }
-    if (previousChildIndex != C.INDEX_UNSET) {
-      return getFirstWindowIndexByChildIndex(previousChildIndex)
-          + getTimelineByChildIndex(previousChildIndex).getLastWindowIndex(shuffleModeEnabled);
-    }
-    // If not found, this is the first window.
-    if (repeatMode == Player.REPEAT_MODE_ALL) {
-      return getLastWindowIndex(shuffleModeEnabled);
-    }
-    return C.INDEX_UNSET;
-  }
-
-  @Override
-  public int getLastWindowIndex(boolean shuffleModeEnabled) {
-    if (childCount == 0) {
-      return C.INDEX_UNSET;
-    }
-    if (isAtomic) {
-      shuffleModeEnabled = false;
-    }
-    // Find last non-empty child.
-    int lastChildIndex = shuffleModeEnabled ? shuffleOrder.getLastIndex() : childCount - 1;
-    while (getTimelineByChildIndex(lastChildIndex).isEmpty()) {
-      lastChildIndex = getPreviousChildIndex(lastChildIndex, shuffleModeEnabled);
-      if (lastChildIndex == C.INDEX_UNSET) {
-        // All children are empty.
-        return C.INDEX_UNSET;
-      }
-    }
-    return getFirstWindowIndexByChildIndex(lastChildIndex)
-        + getTimelineByChildIndex(lastChildIndex).getLastWindowIndex(shuffleModeEnabled);
-  }
-
-  @Override
-  public int getFirstWindowIndex(boolean shuffleModeEnabled) {
-    if (childCount == 0) {
-      return C.INDEX_UNSET;
-    }
-    if (isAtomic) {
-      shuffleModeEnabled = false;
-    }
-    // Find first non-empty child.
-    int firstChildIndex = shuffleModeEnabled ? shuffleOrder.getFirstIndex() : 0;
-    while (getTimelineByChildIndex(firstChildIndex).isEmpty()) {
-      firstChildIndex = getNextChildIndex(firstChildIndex, shuffleModeEnabled);
-      if (firstChildIndex == C.INDEX_UNSET) {
-        // All children are empty.
-        return C.INDEX_UNSET;
-      }
-    }
-    return getFirstWindowIndexByChildIndex(firstChildIndex)
-        + getTimelineByChildIndex(firstChildIndex).getFirstWindowIndex(shuffleModeEnabled);
-  }
-
-  @Override
-  public final Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
-    int childIndex = getChildIndexByWindowIndex(windowIndex);
-    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
-    getTimelineByChildIndex(childIndex)
-        .getWindow(windowIndex - firstWindowIndexInChild, window, defaultPositionProjectionUs);
-    Object childUid = getChildUidByChildIndex(childIndex);
-    // Don't create new objects if the child is using SINGLE_WINDOW_UID.
-    window.uid =
-        Window.SINGLE_WINDOW_UID.equals(window.uid)
-            ? childUid
-            : getConcatenatedUid(childUid, window.uid);
-    window.firstPeriodIndex += firstPeriodIndexInChild;
-    window.lastPeriodIndex += firstPeriodIndexInChild;
-    return window;
-  }
-
-  @Override
-  public final Period getPeriodByUid(Object uid, Period period) {
-    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);
-    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);
-    int childIndex = getChildIndexByChildUid(childUid);
-    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    getTimelineByChildIndex(childIndex).getPeriodByUid(periodUid, period);
-    period.windowIndex += firstWindowIndexInChild;
-    period.uid = uid;
-    return period;
-  }
-
-  @Override
-  public final Period getPeriod(int periodIndex, Period period, boolean setIds) {
-    int childIndex = getChildIndexByPeriodIndex(periodIndex);
-    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
-    getTimelineByChildIndex(childIndex).getPeriod(periodIndex - firstPeriodIndexInChild, period,
-        setIds);
-    period.windowIndex += firstWindowIndexInChild;
-    if (setIds) {
-      period.uid =
-          getConcatenatedUid(
-              getChildUidByChildIndex(childIndex), Assertions.checkNotNull(period.uid));
-    }
-    return period;
-  }
-
-  @Override
-  public final int getIndexOfPeriod(Object uid) {
-    if (!(uid instanceof Pair)) {
-      return C.INDEX_UNSET;
-    }
-    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);
-    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);
-    int childIndex = getChildIndexByChildUid(childUid);
-    if (childIndex == C.INDEX_UNSET) {
-      return C.INDEX_UNSET;
-    }
-    int periodIndexInChild = getTimelineByChildIndex(childIndex).getIndexOfPeriod(periodUid);
-    return periodIndexInChild == C.INDEX_UNSET ? C.INDEX_UNSET
-        : getFirstPeriodIndexByChildIndex(childIndex) + periodIndexInChild;
-  }
-
-  @Override
-  public final Object getUidOfPeriod(int periodIndex) {
-    int childIndex = getChildIndexByPeriodIndex(periodIndex);
-    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
-    Object periodUidInChild =
-        getTimelineByChildIndex(childIndex).getUidOfPeriod(periodIndex - firstPeriodIndexInChild);
-    return getConcatenatedUid(getChildUidByChildIndex(childIndex), periodUidInChild);
-  }
-
-  /**
-   * Returns the index of the child timeline containing the given period index.
-   *
-   * @param periodIndex A valid period index within the bounds of the timeline.
-   */
-  protected abstract int getChildIndexByPeriodIndex(int periodIndex);
-
-  /**
-   * Returns the index of the child timeline containing the given window index.
-   *
-   * @param windowIndex A valid window index within the bounds of the timeline.
-   */
-  protected abstract int getChildIndexByWindowIndex(int windowIndex);
-
-  /**
-   * Returns the index of the child timeline with the given UID or {@link C#INDEX_UNSET} if not
-   * found.
-   *
-   * @param childUid A child UID.
-   * @return Index of child timeline or {@link C#INDEX_UNSET} if UID was not found.
-   */
-  protected abstract int getChildIndexByChildUid(Object childUid);
-
-  /**
-   * Returns the child timeline for the child with the given index.
-   *
-   * @param childIndex A valid child index within the bounds of the timeline.
-   */
-  protected abstract Timeline getTimelineByChildIndex(int childIndex);
-
-  /**
-   * Returns the first period index belonging to the child timeline with the given index.
-   *
-   * @param childIndex A valid child index within the bounds of the timeline.
-   */
-  protected abstract int getFirstPeriodIndexByChildIndex(int childIndex);
-
-  /**
-   * Returns the first window index belonging to the child timeline with the given index.
-   *
-   * @param childIndex A valid child index within the bounds of the timeline.
-   */
-  protected abstract int getFirstWindowIndexByChildIndex(int childIndex);
-
-  /**
-   * Returns the UID of the child timeline with the given index.
-   *
-   * @param childIndex A valid child index within the bounds of the timeline.
-   */
-  protected abstract Object getChildUidByChildIndex(int childIndex);
-
-  private int getNextChildIndex(int childIndex, boolean shuffleModeEnabled) {
-    return shuffleModeEnabled ? shuffleOrder.getNextIndex(childIndex)
-        : childIndex < childCount - 1 ? childIndex + 1 : C.INDEX_UNSET;
-  }
-
-  private int getPreviousChildIndex(int childIndex, boolean shuffleModeEnabled) {
-    return shuffleModeEnabled ? shuffleOrder.getPreviousIndex(childIndex)
-        : childIndex > 0 ? childIndex - 1 : C.INDEX_UNSET;
-  }
-
-}
diff --git a/core/src/main/java/com/google/android/exoplayer2/AudioBecomingNoisyManager.java b/core/src/main/java/com/google/android/exoplayer2/AudioBecomingNoisyManager.java
new file mode 100644
index 0000000..2a52a03
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/AudioBecomingNoisyManager.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.media.AudioManager;
+import android.os.Handler;
+
+/* package */ final class AudioBecomingNoisyManager {
+
+  private final Context context;
+  private final AudioBecomingNoisyReceiver receiver;
+  private boolean receiverRegistered;
+
+  public interface EventListener {
+    void onAudioBecomingNoisy();
+  }
+
+  public AudioBecomingNoisyManager(Context context, Handler eventHandler, EventListener listener) {
+    this.context = context.getApplicationContext();
+    this.receiver = new AudioBecomingNoisyReceiver(eventHandler, listener);
+  }
+
+  /**
+   * Enables the {@link AudioBecomingNoisyManager} which calls {@link
+   * EventListener#onAudioBecomingNoisy()} upon receiving an intent of {@link
+   * AudioManager#ACTION_AUDIO_BECOMING_NOISY}.
+   *
+   * @param enabled True if the listener should be notified when audio is becoming noisy.
+   */
+  public void setEnabled(boolean enabled) {
+    if (enabled && !receiverRegistered) {
+      context.registerReceiver(
+          receiver, new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY));
+      receiverRegistered = true;
+    } else if (!enabled && receiverRegistered) {
+      context.unregisterReceiver(receiver);
+      receiverRegistered = false;
+    }
+  }
+
+  private final class AudioBecomingNoisyReceiver extends BroadcastReceiver implements Runnable {
+    private final EventListener listener;
+    private final Handler eventHandler;
+
+    public AudioBecomingNoisyReceiver(Handler eventHandler, EventListener listener) {
+      this.eventHandler = eventHandler;
+      this.listener = listener;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+      if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) {
+        eventHandler.post(this);
+      }
+    }
+
+    @Override
+    public void run() {
+      if (receiverRegistered) {
+        listener.onAudioBecomingNoisy();
+      }
+    }
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java b/core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java
new file mode 100644
index 0000000..c9aa9e5
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java
@@ -0,0 +1,456 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.content.Context;
+import android.media.AudioFocusRequest;
+import android.media.AudioManager;
+import android.os.Handler;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.audio.AudioAttributes;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+/** Manages requesting and responding to changes in audio focus. */
+/* package */ final class AudioFocusManager {
+
+  /** Interface to allow AudioFocusManager to give commands to a player. */
+  public interface PlayerControl {
+    /**
+     * Called when the volume multiplier on the player should be changed.
+     *
+     * @param volumeMultiplier The new volume multiplier.
+     */
+    void setVolumeMultiplier(float volumeMultiplier);
+
+    /**
+     * Called when a command must be executed on the player.
+     *
+     * @param playerCommand The command that must be executed.
+     */
+    void executePlayerCommand(@PlayerCommand int playerCommand);
+  }
+
+  /**
+   * Player commands. One of {@link #PLAYER_COMMAND_DO_NOT_PLAY}, {@link
+   * #PLAYER_COMMAND_WAIT_FOR_CALLBACK} or {@link #PLAYER_COMMAND_PLAY_WHEN_READY}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    PLAYER_COMMAND_DO_NOT_PLAY,
+    PLAYER_COMMAND_WAIT_FOR_CALLBACK,
+    PLAYER_COMMAND_PLAY_WHEN_READY,
+  })
+  public @interface PlayerCommand {}
+  /** Do not play. */
+  public static final int PLAYER_COMMAND_DO_NOT_PLAY = -1;
+  /** Do not play now. Wait for callback to play. */
+  public static final int PLAYER_COMMAND_WAIT_FOR_CALLBACK = 0;
+  /** Play freely. */
+  public static final int PLAYER_COMMAND_PLAY_WHEN_READY = 1;
+
+  /** Audio focus state. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    AUDIO_FOCUS_STATE_LOST_FOCUS,
+    AUDIO_FOCUS_STATE_NO_FOCUS,
+    AUDIO_FOCUS_STATE_HAVE_FOCUS,
+    AUDIO_FOCUS_STATE_LOSS_TRANSIENT,
+    AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
+  })
+  private @interface AudioFocusState {}
+  /** No audio focus was held, but has been lost by another app taking it permanently. */
+  private static final int AUDIO_FOCUS_STATE_LOST_FOCUS = -1;
+  /** No audio focus is currently being held. */
+  private static final int AUDIO_FOCUS_STATE_NO_FOCUS = 0;
+  /** The requested audio focus is currently held. */
+  private static final int AUDIO_FOCUS_STATE_HAVE_FOCUS = 1;
+  /** Audio focus has been temporarily lost. */
+  private static final int AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 2;
+  /** Audio focus has been temporarily lost, but playback may continue with reduced volume. */
+  private static final int AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK = 3;
+
+  private static final String TAG = "AudioFocusManager";
+
+  private static final float VOLUME_MULTIPLIER_DUCK = 0.2f;
+  private static final float VOLUME_MULTIPLIER_DEFAULT = 1.0f;
+
+  private final AudioManager audioManager;
+  private final AudioFocusListener focusListener;
+  private final PlayerControl playerControl;
+  @Nullable private AudioAttributes audioAttributes;
+
+  @AudioFocusState private int audioFocusState;
+  @C.AudioFocusGain private int focusGain;
+  private float volumeMultiplier = VOLUME_MULTIPLIER_DEFAULT;
+
+  private @MonotonicNonNull AudioFocusRequest audioFocusRequest;
+  private boolean rebuildAudioFocusRequest;
+
+  /**
+   * Constructs an AudioFocusManager to automatically handle audio focus for a player.
+   *
+   * @param context The current context.
+   * @param eventHandler A {@link Handler} to for the thread on which the player is used.
+   * @param playerControl A {@link PlayerControl} to handle commands from this instance.
+   */
+  public AudioFocusManager(Context context, Handler eventHandler, PlayerControl playerControl) {
+    this.audioManager =
+        (AudioManager) context.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+    this.playerControl = playerControl;
+    this.focusListener = new AudioFocusListener(eventHandler);
+    this.audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
+  }
+
+  /** Gets the current player volume multiplier. */
+  public float getVolumeMultiplier() {
+    return volumeMultiplier;
+  }
+
+  /**
+   * Sets audio attributes that should be used to manage audio focus.
+   *
+   * @param audioAttributes The audio attributes or {@code null} if audio focus should not be
+   *     managed automatically.
+   * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
+   * @param playerState The current player state; {@link ExoPlayer#getPlaybackState()}.
+   * @return A {@link PlayerCommand} to execute on the player.
+   */
+  @PlayerCommand
+  public int setAudioAttributes(
+      @Nullable AudioAttributes audioAttributes, boolean playWhenReady, int playerState) {
+    if (!Util.areEqual(this.audioAttributes, audioAttributes)) {
+      this.audioAttributes = audioAttributes;
+      focusGain = convertAudioAttributesToFocusGain(audioAttributes);
+
+      Assertions.checkArgument(
+          focusGain == C.AUDIOFOCUS_GAIN || focusGain == C.AUDIOFOCUS_NONE,
+          "Automatic handling of audio focus is only available for USAGE_MEDIA and USAGE_GAME.");
+      if (playWhenReady
+          && (playerState == Player.STATE_BUFFERING || playerState == Player.STATE_READY)) {
+        return requestAudioFocus();
+      }
+    }
+
+    return playerState == Player.STATE_IDLE
+        ? handleIdle(playWhenReady)
+        : handlePrepare(playWhenReady);
+  }
+
+  /**
+   * Called by a player as part of {@link ExoPlayer#prepare(MediaSource, boolean, boolean)}.
+   *
+   * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
+   * @return A {@link PlayerCommand} to execute on the player.
+   */
+  @PlayerCommand
+  public int handlePrepare(boolean playWhenReady) {
+    return playWhenReady ? requestAudioFocus() : PLAYER_COMMAND_DO_NOT_PLAY;
+  }
+
+  /**
+   * Called by the player as part of {@link ExoPlayer#setPlayWhenReady(boolean)}.
+   *
+   * @param playWhenReady The desired value of playWhenReady.
+   * @param playerState The current state of the player.
+   * @return A {@link PlayerCommand} to execute on the player.
+   */
+  @PlayerCommand
+  public int handleSetPlayWhenReady(boolean playWhenReady, int playerState) {
+    if (!playWhenReady) {
+      abandonAudioFocus();
+      return PLAYER_COMMAND_DO_NOT_PLAY;
+    }
+
+    return playerState == Player.STATE_IDLE ? handleIdle(playWhenReady) : requestAudioFocus();
+  }
+
+  /** Called by the player as part of {@link ExoPlayer#stop(boolean)}. */
+  public void handleStop() {
+    abandonAudioFocus(/* forceAbandon= */ true);
+  }
+
+  // Internal methods.
+
+  @VisibleForTesting
+  /* package */ AudioManager.OnAudioFocusChangeListener getFocusListener() {
+    return focusListener;
+  }
+
+  @PlayerCommand
+  private int handleIdle(boolean playWhenReady) {
+    return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
+  }
+
+  @PlayerCommand
+  private int requestAudioFocus() {
+    int focusRequestResult;
+
+    if (focusGain == C.AUDIOFOCUS_NONE) {
+      if (audioFocusState != AUDIO_FOCUS_STATE_NO_FOCUS) {
+        abandonAudioFocus(/* forceAbandon= */ true);
+      }
+      return PLAYER_COMMAND_PLAY_WHEN_READY;
+    }
+
+    if (audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
+      if (Util.SDK_INT >= 26) {
+        focusRequestResult = requestAudioFocusV26();
+      } else {
+        focusRequestResult = requestAudioFocusDefault();
+      }
+      audioFocusState =
+          focusRequestResult == AudioManager.AUDIOFOCUS_REQUEST_GRANTED
+              ? AUDIO_FOCUS_STATE_HAVE_FOCUS
+              : AUDIO_FOCUS_STATE_NO_FOCUS;
+    }
+
+    if (audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
+      return PLAYER_COMMAND_DO_NOT_PLAY;
+    }
+
+    return audioFocusState == AUDIO_FOCUS_STATE_LOSS_TRANSIENT
+        ? PLAYER_COMMAND_WAIT_FOR_CALLBACK
+        : PLAYER_COMMAND_PLAY_WHEN_READY;
+  }
+
+  private void abandonAudioFocus() {
+    abandonAudioFocus(/* forceAbandon= */ false);
+  }
+
+  private void abandonAudioFocus(boolean forceAbandon) {
+    if (focusGain == C.AUDIOFOCUS_NONE && audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
+      return;
+    }
+
+    if (focusGain != C.AUDIOFOCUS_GAIN
+        || audioFocusState == AUDIO_FOCUS_STATE_LOST_FOCUS
+        || forceAbandon) {
+      if (Util.SDK_INT >= 26) {
+        abandonAudioFocusV26();
+      } else {
+        abandonAudioFocusDefault();
+      }
+      audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
+    }
+  }
+
+  private int requestAudioFocusDefault() {
+    return audioManager.requestAudioFocus(
+        focusListener,
+        Util.getStreamTypeForAudioUsage(Assertions.checkNotNull(audioAttributes).usage),
+        focusGain);
+  }
+
+  @RequiresApi(26)
+  private int requestAudioFocusV26() {
+    if (audioFocusRequest == null || rebuildAudioFocusRequest) {
+      AudioFocusRequest.Builder builder =
+          audioFocusRequest == null
+              ? new AudioFocusRequest.Builder(focusGain)
+              : new AudioFocusRequest.Builder(audioFocusRequest);
+
+      boolean willPauseWhenDucked = willPauseWhenDucked();
+      audioFocusRequest =
+          builder
+              .setAudioAttributes(Assertions.checkNotNull(audioAttributes).getAudioAttributesV21())
+              .setWillPauseWhenDucked(willPauseWhenDucked)
+              .setOnAudioFocusChangeListener(focusListener)
+              .build();
+
+      rebuildAudioFocusRequest = false;
+    }
+    return audioManager.requestAudioFocus(audioFocusRequest);
+  }
+
+  private void abandonAudioFocusDefault() {
+    audioManager.abandonAudioFocus(focusListener);
+  }
+
+  @RequiresApi(26)
+  private void abandonAudioFocusV26() {
+    if (audioFocusRequest != null) {
+      audioManager.abandonAudioFocusRequest(audioFocusRequest);
+    }
+  }
+
+  private boolean willPauseWhenDucked() {
+    return audioAttributes != null && audioAttributes.contentType == C.CONTENT_TYPE_SPEECH;
+  }
+
+  /**
+   * Converts {@link AudioAttributes} to one of the audio focus request.
+   *
+   * <p>This follows the class Javadoc of {@link AudioFocusRequest}.
+   *
+   * @param audioAttributes The audio attributes associated with this focus request.
+   * @return The type of audio focus gain that should be requested.
+   */
+  @C.AudioFocusGain
+  private static int convertAudioAttributesToFocusGain(@Nullable AudioAttributes audioAttributes) {
+
+    if (audioAttributes == null) {
+      // Don't handle audio focus. It may be either video only contents or developers
+      // want to have more finer grained control. (e.g. adding audio focus listener)
+      return C.AUDIOFOCUS_NONE;
+    }
+
+    switch (audioAttributes.usage) {
+        // USAGE_VOICE_COMMUNICATION_SIGNALLING is for DTMF that may happen multiple times
+        // during the phone call when AUDIOFOCUS_GAIN_TRANSIENT is requested for that.
+        // Don't request audio focus here.
+      case C.USAGE_VOICE_COMMUNICATION_SIGNALLING:
+        return C.AUDIOFOCUS_NONE;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN: Examples of uses of this focus gain are for music
+        // playback, for a game or a video player'
+      case C.USAGE_GAME:
+      case C.USAGE_MEDIA:
+        return C.AUDIOFOCUS_GAIN;
+
+        // Special usages: USAGE_UNKNOWN shouldn't be used. Request audio focus to prevent
+        // multiple media playback happen at the same time.
+      case C.USAGE_UNKNOWN:
+        Log.w(
+            TAG,
+            "Specify a proper usage in the audio attributes for audio focus"
+                + " handling. Using AUDIOFOCUS_GAIN by default.");
+        return C.AUDIOFOCUS_GAIN;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN_TRANSIENT: An example is for playing an alarm, or
+        // during a VoIP call'
+      case C.USAGE_ALARM:
+      case C.USAGE_VOICE_COMMUNICATION:
+        return C.AUDIOFOCUS_GAIN_TRANSIENT;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK: Examples are when playing
+        // driving directions or notifications'
+      case C.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
+      case C.USAGE_ASSISTANCE_SONIFICATION:
+      case C.USAGE_NOTIFICATION:
+      case C.USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
+      case C.USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
+      case C.USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
+      case C.USAGE_NOTIFICATION_EVENT:
+      case C.USAGE_NOTIFICATION_RINGTONE:
+        return C.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+
+        // Javadoc says 'AUDIOFOCUS_GAIN_EXCLUSIVE: This is typically used if you are doing
+        // audio recording or speech recognition'.
+        // Assistant is considered as both recording and notifying developer
+      case C.USAGE_ASSISTANT:
+        if (Util.SDK_INT >= 19) {
+          return C.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
+        } else {
+          return C.AUDIOFOCUS_GAIN_TRANSIENT;
+        }
+
+        // Special usages:
+      case C.USAGE_ASSISTANCE_ACCESSIBILITY:
+        if (audioAttributes.contentType == C.CONTENT_TYPE_SPEECH) {
+          // Voice shouldn't be interrupted by other playback.
+          return C.AUDIOFOCUS_GAIN_TRANSIENT;
+        }
+        return C.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+      default:
+        Log.w(TAG, "Unidentified audio usage: " + audioAttributes.usage);
+        return C.AUDIOFOCUS_NONE;
+    }
+  }
+
+  private void handleAudioFocusChange(int focusChange) {
+    // Convert the platform focus change to internal state.
+    switch (focusChange) {
+      case AudioManager.AUDIOFOCUS_LOSS:
+        audioFocusState = AUDIO_FOCUS_STATE_LOST_FOCUS;
+        break;
+      case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+        audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
+        break;
+      case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
+        if (willPauseWhenDucked()) {
+          audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
+        } else {
+          audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK;
+        }
+        break;
+      case AudioManager.AUDIOFOCUS_GAIN:
+        audioFocusState = AUDIO_FOCUS_STATE_HAVE_FOCUS;
+        break;
+      default:
+        Log.w(TAG, "Unknown focus change type: " + focusChange);
+        // Early return.
+        return;
+    }
+
+    // Handle the internal state (change).
+    switch (audioFocusState) {
+      case AUDIO_FOCUS_STATE_NO_FOCUS:
+        // Focus was not requested; nothing to do.
+        break;
+      case AUDIO_FOCUS_STATE_LOST_FOCUS:
+        playerControl.executePlayerCommand(PLAYER_COMMAND_DO_NOT_PLAY);
+        abandonAudioFocus(/* forceAbandon= */ true);
+        break;
+      case AUDIO_FOCUS_STATE_LOSS_TRANSIENT:
+        playerControl.executePlayerCommand(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
+        break;
+      case AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK:
+        // Volume will be adjusted by the code below.
+        break;
+      case AUDIO_FOCUS_STATE_HAVE_FOCUS:
+        playerControl.executePlayerCommand(PLAYER_COMMAND_PLAY_WHEN_READY);
+        break;
+      default:
+        throw new IllegalStateException("Unknown audio focus state: " + audioFocusState);
+    }
+
+    float volumeMultiplier =
+        (audioFocusState == AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK)
+            ? AudioFocusManager.VOLUME_MULTIPLIER_DUCK
+            : AudioFocusManager.VOLUME_MULTIPLIER_DEFAULT;
+    if (AudioFocusManager.this.volumeMultiplier != volumeMultiplier) {
+      AudioFocusManager.this.volumeMultiplier = volumeMultiplier;
+      playerControl.setVolumeMultiplier(volumeMultiplier);
+    }
+  }
+
+  // Internal audio focus listener.
+
+  private class AudioFocusListener implements AudioManager.OnAudioFocusChangeListener {
+    private final Handler eventHandler;
+
+    public AudioFocusListener(Handler eventHandler) {
+      this.eventHandler = eventHandler;
+    }
+
+    @Override
+    public void onAudioFocusChange(int focusChange) {
+      eventHandler.post(() -> handleAudioFocusChange(focusChange));
+    }
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java b/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
index baa2a76..2646cbc 100644
--- a/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
@@ -128,6 +128,12 @@ public abstract class BasePlayer implements Player {
   }
 
   @Override
+  public final boolean isCurrentWindowLive() {
+    Timeline timeline = getCurrentTimeline();
+    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isLive;
+  }
+
+  @Override
   public final boolean isCurrentWindowSeekable() {
     Timeline timeline = getCurrentTimeline();
     return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
diff --git a/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index 6c323de..10573af 100644
--- a/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -44,6 +44,7 @@ public abstract class BaseRenderer implements Renderer, RendererCapabilities {
   private long streamOffsetUs;
   private long readingPositionUs;
   private boolean streamIsFinal;
+  private boolean throwRendererExceptionIsExecuting;
 
   /**
    * @param trackType The track type that the renderer handles. One of the {@link C}
@@ -177,6 +178,7 @@ public abstract class BaseRenderer implements Renderer, RendererCapabilities {
   // RendererCapabilities implementation.
 
   @Override
+  @AdaptiveSupport
   public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
     return ADAPTIVE_NOT_SUPPORTED;
   }
@@ -313,15 +315,15 @@ public abstract class BaseRenderer implements Renderer, RendererCapabilities {
     @Nullable DrmSession<T> newSourceDrmSession = null;
     if (newFormat.drmInitData != null) {
       if (drmSessionManager == null) {
-        throw ExoPlaybackException.createForRenderer(
-            new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
+        throw createRendererException(
+            new IllegalStateException("Media requires a DrmSessionManager"), newFormat);
       }
       newSourceDrmSession =
           drmSessionManager.acquireSession(
               Assertions.checkNotNull(Looper.myLooper()), newFormat.drmInitData);
     }
     if (existingSourceSession != null) {
-      existingSourceSession.releaseReference();
+      existingSourceSession.release();
     }
     return newSourceDrmSession;
   }
@@ -334,22 +336,46 @@ public abstract class BaseRenderer implements Renderer, RendererCapabilities {
   }
 
   /**
+   * Creates an {@link ExoPlaybackException} of type {@link ExoPlaybackException#TYPE_RENDERER} for
+   * this renderer.
+   *
+   * @param cause The cause of the exception.
+   * @param format The current format used by the renderer. May be null.
+   */
+  protected final ExoPlaybackException createRendererException(
+      Exception cause, @Nullable Format format) {
+    @FormatSupport int formatSupport = RendererCapabilities.FORMAT_HANDLED;
+    if (format != null && !throwRendererExceptionIsExecuting) {
+      // Prevent recursive re-entry from subclass supportsFormat implementations.
+      throwRendererExceptionIsExecuting = true;
+      try {
+        formatSupport = RendererCapabilities.getFormatSupport(supportsFormat(format));
+      } catch (ExoPlaybackException e) {
+        // Ignore, we are already failing.
+      } finally {
+        throwRendererExceptionIsExecuting = false;
+      }
+    }
+    return ExoPlaybackException.createForRenderer(cause, getIndex(), format, formatSupport);
+  }
+
+  /**
    * Reads from the enabled upstream source. If the upstream source has been read to the end then
    * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been
    * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     end of the stream. If the end of the stream has been reached, the {@link
+   *     C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
    * @param formatRequired Whether the caller requires that the format of the stream be read even if
    *     it's not changing. A sample will never be read if set to true, however it is still possible
    *     for the end of stream or nothing to be read.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
-  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer,
-      boolean formatRequired) {
+  protected final int readSource(
+      FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {
     int result = stream.readData(formatHolder, buffer, formatRequired);
     if (result == C.RESULT_BUFFER_READ) {
       if (buffer.isEndOfStream()) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/C.java b/core/src/main/java/com/google/android/exoplayer2/C.java
index 9a0959d..567ce98 100644
--- a/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -27,6 +27,8 @@ import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.audio.AuxEffectInfo;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.SimpleDecoderVideoRenderer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
 import java.lang.annotation.Documented;
@@ -187,15 +184,15 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          Format.NO_VALUE,
-          ENCODING_INVALID,
-          ENCODING_PCM_8BIT,
-          ENCODING_PCM_16BIT,
-          ENCODING_PCM_24BIT,
-          ENCODING_PCM_32BIT,
-          ENCODING_PCM_FLOAT,
-          ENCODING_PCM_MU_LAW,
-          ENCODING_PCM_A_LAW
+    Format.NO_VALUE,
+    ENCODING_INVALID,
+    ENCODING_PCM_8BIT,
+    ENCODING_PCM_16BIT,
+    ENCODING_PCM_24BIT,
+    ENCODING_PCM_32BIT,
+    ENCODING_PCM_FLOAT,
+    ENCODING_PCM_MU_LAW,
+    ENCODING_PCM_A_LAW
   })
   public @interface PcmEncoding {}
   /** @see AudioFormat#ENCODING_INVALID */
@@ -238,14 +235,14 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          STREAM_TYPE_ALARM,
-          STREAM_TYPE_DTMF,
-          STREAM_TYPE_MUSIC,
-          STREAM_TYPE_NOTIFICATION,
-          STREAM_TYPE_RING,
-          STREAM_TYPE_SYSTEM,
-          STREAM_TYPE_VOICE_CALL,
-          STREAM_TYPE_USE_DEFAULT
+    STREAM_TYPE_ALARM,
+    STREAM_TYPE_DTMF,
+    STREAM_TYPE_MUSIC,
+    STREAM_TYPE_NOTIFICATION,
+    STREAM_TYPE_RING,
+    STREAM_TYPE_SYSTEM,
+    STREAM_TYPE_VOICE_CALL,
+    STREAM_TYPE_USE_DEFAULT
   })
   public @interface StreamType {}
   /**
@@ -293,11 +290,11 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          CONTENT_TYPE_MOVIE,
-          CONTENT_TYPE_MUSIC,
-          CONTENT_TYPE_SONIFICATION,
-          CONTENT_TYPE_SPEECH,
-          CONTENT_TYPE_UNKNOWN
+    CONTENT_TYPE_MOVIE,
+    CONTENT_TYPE_MUSIC,
+    CONTENT_TYPE_SONIFICATION,
+    CONTENT_TYPE_SPEECH,
+    CONTENT_TYPE_UNKNOWN
   })
   public @interface AudioContentType {}
   /**
@@ -312,17 +309,17 @@ public final class C {
    * @see android.media.AudioAttributes#CONTENT_TYPE_SONIFICATION
    */
   public static final int CONTENT_TYPE_SONIFICATION =
-          android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION;
+      android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION;
   /**
    * @see android.media.AudioAttributes#CONTENT_TYPE_SPEECH
    */
   public static final int CONTENT_TYPE_SPEECH =
-          android.media.AudioAttributes.CONTENT_TYPE_SPEECH;
+      android.media.AudioAttributes.CONTENT_TYPE_SPEECH;
   /**
    * @see android.media.AudioAttributes#CONTENT_TYPE_UNKNOWN
    */
   public static final int CONTENT_TYPE_UNKNOWN =
-          android.media.AudioAttributes.CONTENT_TYPE_UNKNOWN;
+      android.media.AudioAttributes.CONTENT_TYPE_UNKNOWN;
 
   /**
    * Flags for {@link com.google.android.exoplayer2.audio.AudioAttributes}. Possible flag value is
@@ -334,14 +331,14 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
-          flag = true,
-          value = {FLAG_AUDIBILITY_ENFORCED})
+      flag = true,
+      value = {FLAG_AUDIBILITY_ENFORCED})
   public @interface AudioFlags {}
   /**
    * @see android.media.AudioAttributes#FLAG_AUDIBILITY_ENFORCED
    */
   public static final int FLAG_AUDIBILITY_ENFORCED =
-          android.media.AudioAttributes.FLAG_AUDIBILITY_ENFORCED;
+      android.media.AudioAttributes.FLAG_AUDIBILITY_ENFORCED;
 
   /**
    * Usage types for {@link com.google.android.exoplayer2.audio.AudioAttributes}. One of {@link
@@ -357,22 +354,22 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          USAGE_ALARM,
-          USAGE_ASSISTANCE_ACCESSIBILITY,
-          USAGE_ASSISTANCE_NAVIGATION_GUIDANCE,
-          USAGE_ASSISTANCE_SONIFICATION,
-          USAGE_ASSISTANT,
-          USAGE_GAME,
-          USAGE_MEDIA,
-          USAGE_NOTIFICATION,
-          USAGE_NOTIFICATION_COMMUNICATION_DELAYED,
-          USAGE_NOTIFICATION_COMMUNICATION_INSTANT,
-          USAGE_NOTIFICATION_COMMUNICATION_REQUEST,
-          USAGE_NOTIFICATION_EVENT,
-          USAGE_NOTIFICATION_RINGTONE,
-          USAGE_UNKNOWN,
-          USAGE_VOICE_COMMUNICATION,
-          USAGE_VOICE_COMMUNICATION_SIGNALLING
+    USAGE_ALARM,
+    USAGE_ASSISTANCE_ACCESSIBILITY,
+    USAGE_ASSISTANCE_NAVIGATION_GUIDANCE,
+    USAGE_ASSISTANCE_SONIFICATION,
+    USAGE_ASSISTANT,
+    USAGE_GAME,
+    USAGE_MEDIA,
+    USAGE_NOTIFICATION,
+    USAGE_NOTIFICATION_COMMUNICATION_DELAYED,
+    USAGE_NOTIFICATION_COMMUNICATION_INSTANT,
+    USAGE_NOTIFICATION_COMMUNICATION_REQUEST,
+    USAGE_NOTIFICATION_EVENT,
+    USAGE_NOTIFICATION_RINGTONE,
+    USAGE_UNKNOWN,
+    USAGE_VOICE_COMMUNICATION,
+    USAGE_VOICE_COMMUNICATION_SIGNALLING
   })
   public @interface AudioUsage {}
   /**
@@ -381,17 +378,17 @@ public final class C {
   public static final int USAGE_ALARM = android.media.AudioAttributes.USAGE_ALARM;
   /** @see android.media.AudioAttributes#USAGE_ASSISTANCE_ACCESSIBILITY */
   public static final int USAGE_ASSISTANCE_ACCESSIBILITY =
-          android.media.AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY;
+      android.media.AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY;
   /**
    * @see android.media.AudioAttributes#USAGE_ASSISTANCE_NAVIGATION_GUIDANCE
    */
   public static final int USAGE_ASSISTANCE_NAVIGATION_GUIDANCE =
-          android.media.AudioAttributes.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE;
+      android.media.AudioAttributes.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE;
   /**
    * @see android.media.AudioAttributes#USAGE_ASSISTANCE_SONIFICATION
    */
   public static final int USAGE_ASSISTANCE_SONIFICATION =
-          android.media.AudioAttributes.USAGE_ASSISTANCE_SONIFICATION;
+      android.media.AudioAttributes.USAGE_ASSISTANCE_SONIFICATION;
   /** @see android.media.AudioAttributes#USAGE_ASSISTANT */
   public static final int USAGE_ASSISTANT = android.media.AudioAttributes.USAGE_ASSISTANT;
   /**
@@ -410,27 +407,27 @@ public final class C {
    * @see android.media.AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_DELAYED
    */
   public static final int USAGE_NOTIFICATION_COMMUNICATION_DELAYED =
-          android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_DELAYED;
+      android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_DELAYED;
   /**
    * @see android.media.AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_INSTANT
    */
   public static final int USAGE_NOTIFICATION_COMMUNICATION_INSTANT =
-          android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_INSTANT;
+      android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_INSTANT;
   /**
    * @see android.media.AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_REQUEST
    */
   public static final int USAGE_NOTIFICATION_COMMUNICATION_REQUEST =
-          android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_REQUEST;
+      android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_REQUEST;
   /**
    * @see android.media.AudioAttributes#USAGE_NOTIFICATION_EVENT
    */
   public static final int USAGE_NOTIFICATION_EVENT =
-          android.media.AudioAttributes.USAGE_NOTIFICATION_EVENT;
+      android.media.AudioAttributes.USAGE_NOTIFICATION_EVENT;
   /**
    * @see android.media.AudioAttributes#USAGE_NOTIFICATION_RINGTONE
    */
   public static final int USAGE_NOTIFICATION_RINGTONE =
-          android.media.AudioAttributes.USAGE_NOTIFICATION_RINGTONE;
+      android.media.AudioAttributes.USAGE_NOTIFICATION_RINGTONE;
   /**
    * @see android.media.AudioAttributes#USAGE_UNKNOWN
    */
@@ -439,12 +436,12 @@ public final class C {
    * @see android.media.AudioAttributes#USAGE_VOICE_COMMUNICATION
    */
   public static final int USAGE_VOICE_COMMUNICATION =
-          android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION;
+      android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION;
   /**
    * @see android.media.AudioAttributes#USAGE_VOICE_COMMUNICATION_SIGNALLING
    */
   public static final int USAGE_VOICE_COMMUNICATION_SIGNALLING =
-          android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION_SIGNALLING;
+      android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION_SIGNALLING;
 
   /**
    * Capture policies for {@link com.google.android.exoplayer2.audio.AudioAttributes}. One of {@link
@@ -469,11 +466,11 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          AUDIOFOCUS_NONE,
-          AUDIOFOCUS_GAIN,
-          AUDIOFOCUS_GAIN_TRANSIENT,
-          AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK,
-          AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE
+    AUDIOFOCUS_NONE,
+    AUDIOFOCUS_GAIN,
+    AUDIOFOCUS_GAIN_TRANSIENT,
+    AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK,
+    AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE
   })
   public @interface AudioFocusGain {}
   /** @see AudioManager#AUDIOFOCUS_NONE */
@@ -484,10 +481,10 @@ public final class C {
   public static final int AUDIOFOCUS_GAIN_TRANSIENT = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
   /** @see AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK */
   public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK =
-          AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+      AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
   /** @see AudioManager#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE */
   public static final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE =
-          AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
+      AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
 
   /**
    * Flags which can apply to a buffer containing a media sample. Possible flag values are {@link
@@ -524,6 +521,7 @@ public final class C {
   /** Indicates that a buffer should be decoded but not rendered. */
   public static final int BUFFER_FLAG_DECODE_ONLY = 1 << 31; // 0x80000000
 
+  // LINT.IfChange
   /**
    * Video decoder output modes. Possible modes are {@link #VIDEO_OUTPUT_MODE_NONE}, {@link
    * #VIDEO_OUTPUT_MODE_YUV} and {@link #VIDEO_OUTPUT_MODE_SURFACE_YUV}.
@@ -538,6 +536,10 @@ public final class C {
   public static final int VIDEO_OUTPUT_MODE_YUV = 0;
   /** Video decoder output mode that renders 4:2:0 YUV planes directly to a surface. */
   public static final int VIDEO_OUTPUT_MODE_SURFACE_YUV = 1;
+  // LINT.ThenChange(
+  //     ../../../../../../../../../extensions/av1/src/main/jni/gav1_jni.cc,
+  //     ../../../../../../../../../extensions/vp9/src/main/jni/vpx_jni.cc
+  // )
 
   /**
    * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s. One of {@link
@@ -551,12 +553,12 @@ public final class C {
    * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
    */
   public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
+      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
   /**
    * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
    */
   public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
+      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
   /**
    * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
    */
@@ -569,8 +571,8 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
-          flag = true,
-          value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED, SELECTION_FLAG_AUTOSELECT})
+      flag = true,
+      value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED, SELECTION_FLAG_AUTOSELECT})
   public @interface SelectionFlags {}
   /**
    * Indicates that the track should be selected if user preferences do not state otherwise.
@@ -829,6 +831,17 @@ public final class C {
   public static final int MSG_SET_CAMERA_MOTION_LISTENER = 7;
 
   /**
+   * The type of a message that can be passed to a {@link SimpleDecoderVideoRenderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be the target {@link
+   * VideoDecoderOutputBufferRenderer}, or null.
+   *
+   * <p>This message is intended only for use with extension renderers that expect a {@link
+   * VideoDecoderOutputBufferRenderer}. For other use cases, an output surface should be passed via
+   * {@link #MSG_SET_SURFACE} instead.
+   */
+  public static final int MSG_SET_VIDEO_DECODER_OUTPUT_BUFFER_RENDERER = 8;
+
+  /**
    * Applications or extensions may define custom {@code MSG_*} constants that can be passed to
    * {@link Renderer}s. These custom constants must be greater than or equal to this value.
    */
@@ -842,11 +855,11 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          Format.NO_VALUE,
-          STEREO_MODE_MONO,
-          STEREO_MODE_TOP_BOTTOM,
-          STEREO_MODE_LEFT_RIGHT,
-          STEREO_MODE_STEREO_MESH
+    Format.NO_VALUE,
+    STEREO_MODE_MONO,
+    STEREO_MODE_TOP_BOTTOM,
+    STEREO_MODE_LEFT_RIGHT,
+    STEREO_MODE_STEREO_MESH
   })
   public @interface StereoMode {}
   /**
@@ -969,15 +982,15 @@ public final class C {
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
-          NETWORK_TYPE_UNKNOWN,
-          NETWORK_TYPE_OFFLINE,
-          NETWORK_TYPE_WIFI,
-          NETWORK_TYPE_2G,
-          NETWORK_TYPE_3G,
-          NETWORK_TYPE_4G,
-          NETWORK_TYPE_CELLULAR_UNKNOWN,
-          NETWORK_TYPE_ETHERNET,
-          NETWORK_TYPE_OTHER
+    NETWORK_TYPE_UNKNOWN,
+    NETWORK_TYPE_OFFLINE,
+    NETWORK_TYPE_WIFI,
+    NETWORK_TYPE_2G,
+    NETWORK_TYPE_3G,
+    NETWORK_TYPE_4G,
+    NETWORK_TYPE_CELLULAR_UNKNOWN,
+    NETWORK_TYPE_ETHERNET,
+    NETWORK_TYPE_OTHER
   })
   public @interface NetworkType {}
   /** Unknown network type. */
@@ -1132,7 +1122,7 @@ public final class C {
   @TargetApi(21)
   public static int generateAudioSessionIdV21(Context context) {
     return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
-            .generateAudioSessionId();
+        .generateAudioSessionId();
   }
 
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java b/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
index 3e264b3..1971a4c 100644
--- a/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
+++ b/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
@@ -71,13 +71,6 @@ import com.google.android.exoplayer2.util.StandaloneMediaClock;
   }
 
   /**
-   * Returns whether the standalone clock has been started.
-   */
-  public boolean isStarted() {
-    return standaloneClockIsStarted;
-  }
-
-  /**
    * Stops the standalone fallback clock.
    */
   public void stop() {
diff --git a/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index a97b1e0..f53d72f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -365,6 +365,33 @@ public class DefaultRenderersFactory implements RenderersFactory {
       // The extension is present, but instantiation failed.
       throw new RuntimeException("Error instantiating VP9 extension", e);
     }
+
+    try {
+      // Full class names used for constructor args so the LINT rule triggers if any of them move.
+      // LINT.IfChange
+      Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.av1.Libgav1VideoRenderer");
+      Constructor<?> constructor =
+          clazz.getConstructor(
+              long.class,
+              android.os.Handler.class,
+              com.google.android.exoplayer2.video.VideoRendererEventListener.class,
+              int.class);
+      // LINT.ThenChange(../../../../../../../proguard-rules.txt)
+      Renderer renderer =
+          (Renderer)
+              constructor.newInstance(
+                  allowedVideoJoiningTimeMs,
+                  eventHandler,
+                  eventListener,
+                  MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
+      out.add(extensionRendererIndex++, renderer);
+      Log.i(TAG, "Loaded Libgav1VideoRenderer.");
+    } catch (ClassNotFoundException e) {
+      // Expected if the app was built without the extension.
+    } catch (Exception e) {
+      // The extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating AV1 extension", e);
+    }
   }
 
   /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java b/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
index 49aacd9..653b600 100644
--- a/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
+++ b/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
@@ -18,6 +18,7 @@ package com.google.android.exoplayer2;
 import android.os.SystemClock;
 import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.RendererCapabilities.FormatSupport;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -74,6 +75,19 @@ public final class ExoPlaybackException extends Exception {
    */
   public final int rendererIndex;
 
+  /**
+   * If {@link #type} is {@link #TYPE_RENDERER}, this is the {@link Format} the renderer was using
+   * at the time of the exception, or null if the renderer wasn't using a {@link Format}.
+   */
+  @Nullable public final Format rendererFormat;
+
+  /**
+   * If {@link #type} is {@link #TYPE_RENDERER}, this is the level of {@link FormatSupport} of the
+   * renderer for {@link #rendererFormat}. If {@link #rendererFormat} is null, this is {@link
+   * RendererCapabilities#FORMAT_HANDLED}.
+   */
+  @FormatSupport public final int rendererFormatSupport;
+
   /** The value of {@link SystemClock#elapsedRealtime()} when this exception was created. */
   public final long timestampMs;
 
@@ -86,7 +100,7 @@ public final class ExoPlaybackException extends Exception {
    * @return The created instance.
    */
   public static ExoPlaybackException createForSource(IOException cause) {
-    return new ExoPlaybackException(TYPE_SOURCE, cause, /* rendererIndex= */ C.INDEX_UNSET);
+    return new ExoPlaybackException(TYPE_SOURCE, cause);
   }
 
   /**
@@ -94,10 +108,23 @@ public final class ExoPlaybackException extends Exception {
    *
    * @param cause The cause of the failure.
    * @param rendererIndex The index of the renderer in which the failure occurred.
+   * @param rendererFormat The {@link Format} the renderer was using at the time of the exception,
+   *     or null if the renderer wasn't using a {@link Format}.
+   * @param rendererFormatSupport The {@link FormatSupport} of the renderer for {@code
+   *     rendererFormat}. Ignored if {@code rendererFormat} is null.
    * @return The created instance.
    */
-  public static ExoPlaybackException createForRenderer(Exception cause, int rendererIndex) {
-    return new ExoPlaybackException(TYPE_RENDERER, cause, rendererIndex);
+  public static ExoPlaybackException createForRenderer(
+      Exception cause,
+      int rendererIndex,
+      @Nullable Format rendererFormat,
+      @FormatSupport int rendererFormatSupport) {
+    return new ExoPlaybackException(
+        TYPE_RENDERER,
+        cause,
+        rendererIndex,
+        rendererFormat,
+        rendererFormat == null ? RendererCapabilities.FORMAT_HANDLED : rendererFormatSupport);
   }
 
   /**
@@ -107,7 +134,7 @@ public final class ExoPlaybackException extends Exception {
    * @return The created instance.
    */
   public static ExoPlaybackException createForUnexpected(RuntimeException cause) {
-    return new ExoPlaybackException(TYPE_UNEXPECTED, cause, /* rendererIndex= */ C.INDEX_UNSET);
+    return new ExoPlaybackException(TYPE_UNEXPECTED, cause);
   }
 
   /**
@@ -127,14 +154,30 @@ public final class ExoPlaybackException extends Exception {
    * @return The created instance.
    */
   public static ExoPlaybackException createForOutOfMemoryError(OutOfMemoryError cause) {
-    return new ExoPlaybackException(TYPE_OUT_OF_MEMORY, cause, /* rendererIndex= */ C.INDEX_UNSET);
+    return new ExoPlaybackException(TYPE_OUT_OF_MEMORY, cause);
+  }
+
+  private ExoPlaybackException(@Type int type, Throwable cause) {
+    this(
+        type,
+        cause,
+        /* rendererIndex= */ C.INDEX_UNSET,
+        /* rendererFormat= */ null,
+        /* rendererFormatSupport= */ RendererCapabilities.FORMAT_HANDLED);
   }
 
-  private ExoPlaybackException(@Type int type, Throwable cause, int rendererIndex) {
+  private ExoPlaybackException(
+      @Type int type,
+      Throwable cause,
+      int rendererIndex,
+      @Nullable Format rendererFormat,
+      @FormatSupport int rendererFormatSupport) {
     super(cause);
     this.type = type;
     this.cause = cause;
     this.rendererIndex = rendererIndex;
+    this.rendererFormat = rendererFormat;
+    this.rendererFormatSupport = rendererFormatSupport;
     timestampMs = SystemClock.elapsedRealtime();
   }
 
@@ -142,6 +185,8 @@ public final class ExoPlaybackException extends Exception {
     super(message);
     this.type = type;
     rendererIndex = C.INDEX_UNSET;
+    rendererFormat = null;
+    rendererFormatSupport = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
     cause = null;
     timestampMs = SystemClock.elapsedRealtime();
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 4418549..7c8a454 100644
--- a/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -28,7 +28,6 @@ import com.google.android.exoplayer2.source.LoopingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MergingMediaSource;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.SingleSampleMediaSource;
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
@@ -40,7 +39,6 @@ import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
-import java.util.List;
 
 /**
  * An extensible media player that plays {@link MediaSource}s. Instances can be obtained from {@link
@@ -141,7 +139,7 @@ public interface ExoPlayer extends Player {
     private LoadControl loadControl;
     private BandwidthMeter bandwidthMeter;
     private Looper looper;
-    @Nullable private AnalyticsCollector analyticsCollector;
+    private AnalyticsCollector analyticsCollector;
     private boolean useLazyPreparation;
     private boolean buildCalled;
 
@@ -172,7 +170,7 @@ public interface ExoPlayer extends Player {
           new DefaultLoadControl(),
           DefaultBandwidthMeter.getSingletonInstance(context),
           Util.getLooper(),
-          /* analyticsCollector= */ null,
+          new AnalyticsCollector(Clock.DEFAULT),
           /* useLazyPreparation= */ true,
           Clock.DEFAULT);
     }
@@ -199,7 +197,7 @@ public interface ExoPlayer extends Player {
         LoadControl loadControl,
         BandwidthMeter bandwidthMeter,
         Looper looper,
-        @Nullable AnalyticsCollector analyticsCollector,
+        AnalyticsCollector analyticsCollector,
         boolean useLazyPreparation,
         Clock clock) {
       Assertions.checkArgument(renderers.length > 0);
@@ -320,156 +318,38 @@ public interface ExoPlayer extends Player {
       Assertions.checkState(!buildCalled);
       buildCalled = true;
       return new ExoPlayerImpl(
-          renderers,
-          trackSelector,
-          loadControl,
-          bandwidthMeter,
-          analyticsCollector,
-          useLazyPreparation,
-          clock,
-          looper);
+          renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
     }
   }
 
   /** Returns the {@link Looper} associated with the playback thread. */
   Looper getPlaybackLooper();
 
-  /** @deprecated Use {@link #prepare()} instead. */
-  @Deprecated
+  /**
+   * Retries a failed or stopped playback. Does nothing if the player has been reset, or if playback
+   * has not failed or been stopped.
+   */
   void retry();
 
-  /** @deprecated Use {@link #setMediaItem(MediaSource)} and {@link #prepare()} instead. */
-  @Deprecated
-  void prepare(MediaSource mediaSource);
-
-  /** @deprecated Use {@link #setMediaItems(List, int, long)} and {@link #prepare()} instead. */
-  @Deprecated
-  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState);
-
-  /** Prepares the player. */
-  void prepare();
-
   /**
-   * Clears the playlist and adds the specified {@link MediaSource MediaSources}.
-   *
-   * @param mediaItems The new {@link MediaSource MediaSources}.
+   * Prepares the player to play the provided {@link MediaSource}. Equivalent to {@code
+   * prepare(mediaSource, true, true)}.
    */
-  void setMediaItems(List<MediaSource> mediaItems);
+  void prepare(MediaSource mediaSource);
 
   /**
-   * Clears the playlist and adds the specified {@link MediaSource MediaSources}.
+   * Prepares the player to play the provided {@link MediaSource}, optionally resetting the playback
+   * position the default position in the first {@link Timeline.Window}.
    *
-   * @param mediaItems The new {@link MediaSource MediaSources}.
+   * @param mediaSource The {@link MediaSource} to play.
    * @param resetPosition Whether the playback position should be reset to the default position in
    *     the first {@link Timeline.Window}. If false, playback will start from the position defined
    *     by {@link #getCurrentWindowIndex()} and {@link #getCurrentPosition()}.
+   * @param resetState Whether the timeline, manifest, tracks and track selections should be reset.
+   *     Should be true unless the player is being prepared to play the same media as it was playing
+   *     previously (e.g. if playback failed and is being retried).
    */
-  void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition);
-
-  /**
-   * Clears the playlist and adds the specified {@link MediaSource MediaSources}.
-   *
-   * @param mediaItems The new {@link MediaSource MediaSources}.
-   * @param startWindowIndex The window index to start playback from. If {@link C#INDEX_UNSET} is
-   *     passed, the current position is not reset.
-   * @param startPositionMs The position in milliseconds to start playback from. If {@link
-   *     C#TIME_UNSET} is passed, the default position of the given window is used. In any case, if
-   *     {@code startWindowIndex} is set to {@link C#INDEX_UNSET}, this parameter is ignored and the
-   *     position is not reset at all.
-   */
-  void setMediaItems(List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs);
-
-  /**
-   * Clears the playlist and adds the specified {@link MediaSource}.
-   *
-   * @param mediaItem The new {@link MediaSource}.
-   */
-  void setMediaItem(MediaSource mediaItem);
-
-  /**
-   * Clears the playlist and adds the specified {@link MediaSource}.
-   *
-   * @param mediaItem The new {@link MediaSource}.
-   * @param startPositionMs The position in milliseconds to start playback from.
-   */
-  void setMediaItem(MediaSource mediaItem, long startPositionMs);
-
-  /**
-   * Adds a media item to the end of the playlist.
-   *
-   * @param mediaSource The {@link MediaSource} to add.
-   */
-  void addMediaItem(MediaSource mediaSource);
-
-  /**
-   * Adds a media item at the given index of the playlist.
-   *
-   * @param index The index at which to add the item.
-   * @param mediaSource The {@link MediaSource} to add.
-   */
-  void addMediaItem(int index, MediaSource mediaSource);
-
-  /**
-   * Adds a list of media items to the end of the playlist.
-   *
-   * @param mediaSources The {@link MediaSource MediaSources} to add.
-   */
-  void addMediaItems(List<MediaSource> mediaSources);
-
-  /**
-   * Adds a list of media items at the given index of the playlist.
-   *
-   * @param index The index at which to add the media items.
-   * @param mediaSources The {@link MediaSource MediaSources} to add.
-   */
-  void addMediaItems(int index, List<MediaSource> mediaSources);
-
-  /**
-   * Moves the media item at the current index to the new index.
-   *
-   * @param currentIndex The current index of the media item to move.
-   * @param newIndex The new index of the media item. If the new index is larger than the size of
-   *     the playlist the item is moved to the end of the playlist.
-   */
-  void moveMediaItem(int currentIndex, int newIndex);
-
-  /**
-   * Moves the media item range to the new index.
-   *
-   * @param fromIndex The start of the range to move.
-   * @param toIndex The first item not to be included in the range (exclusive).
-   * @param newIndex The new index of the first media item of the range. If the new index is larger
-   *     than the size of the remaining playlist after removing the range, the range is moved to the
-   *     end of the playlist.
-   */
-  void moveMediaItems(int fromIndex, int toIndex, int newIndex);
-
-  /**
-   * Removes the media item at the given index of the playlist.
-   *
-   * @param index The index at which to remove the media item.
-   * @return The removed {@link MediaSource} or null if no item exists at the given index.
-   */
-  @Nullable
-  MediaSource removeMediaItem(int index);
-
-  /**
-   * Removes a range of media items from the playlist.
-   *
-   * @param fromIndex The index at which to start removing media items.
-   * @param toIndex The index of the first item to be kept (exclusive).
-   */
-  void removeMediaItems(int fromIndex, int toIndex);
-
-  /** Clears the playlist. */
-  void clearMediaItems();
-
-  /**
-   * Sets the shuffle order.
-   *
-   * @param shuffleOrder The shuffle order.
-   */
-  void setShuffleOrder(ShuffleOrder shuffleOrder);
+  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState);
 
   /**
    * Creates a message that can be sent to a {@link PlayerMessage.Target}. By default, the message
diff --git a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index b900491..e4f239d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -278,6 +278,7 @@ public final class ExoPlayerFactory {
    *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
    *     MediaSource} factories.
    */
+  @SuppressWarnings("deprecation")
   @Deprecated
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
@@ -296,7 +297,6 @@ public final class ExoPlayerFactory {
         drmSessionManager,
         bandwidthMeter,
         analyticsCollector,
-        /* useLazyPreparation= */ true,
         Clock.DEFAULT,
         looper);
   }
@@ -345,13 +345,6 @@ public final class ExoPlayerFactory {
       BandwidthMeter bandwidthMeter,
       Looper looper) {
     return new ExoPlayerImpl(
-        renderers,
-        trackSelector,
-        loadControl,
-        bandwidthMeter,
-        /* analyticsCollector= */ null,
-        /* useLazyPreparation= */ true,
-        Clock.DEFAULT,
-        looper);
+        renderers, trackSelector, loadControl, bandwidthMeter, Clock.DEFAULT, looper);
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 12d6033..dd8fbee 100644
--- a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -22,10 +22,8 @@ import android.os.Message;
 import android.util.Pair;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.PlayerMessage.Target;
-import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
@@ -37,11 +35,7 @@ import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
  * An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayer.Builder}.
@@ -66,22 +60,20 @@ import java.util.concurrent.CopyOnWriteArraySet;
   private final Handler internalPlayerHandler;
   private final CopyOnWriteArrayList<ListenerHolder> listeners;
   private final Timeline.Period period;
-  private final VideoComponent videoComponent;
   private final ArrayDeque<Runnable> pendingListenerNotifications;
-  private final List<Playlist.MediaSourceHolder> mediaSourceHolders;
-  private final boolean useLazyPreparation;
 
+  private MediaSource mediaSource;
   private boolean playWhenReady;
   @PlaybackSuppressionReason private int playbackSuppressionReason;
   @RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
   private int pendingOperationAcks;
+  private boolean hasPendingPrepare;
   private boolean hasPendingSeek;
   private boolean foregroundMode;
   private int pendingSetPlaybackParametersAcks;
   private PlaybackParameters playbackParameters;
   private SeekParameters seekParameters;
-  private ShuffleOrder shuffleOrder;
 
   // Playback information when there is no pending seek/set source operation.
   private PlaybackInfo playbackInfo;
@@ -98,10 +90,6 @@ import java.util.concurrent.CopyOnWriteArraySet;
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
-   * @param analyticsCollector The {@link AnalyticsCollector} that will be used by the instance.
-   * @param useLazyPreparation Whether playlist items are prepared lazily. If false, all manifest
-   *     loads and other initial preparation steps happen immediately. If true, these initial
-   *     preparations are triggered only when the player starts buffering the media.
    * @param clock The {@link Clock} that will be used by the instance.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
    *     used to call listeners on.
@@ -112,48 +100,17 @@ import java.util.concurrent.CopyOnWriteArraySet;
       TrackSelector trackSelector,
       LoadControl loadControl,
       BandwidthMeter bandwidthMeter,
-      @Nullable AnalyticsCollector analyticsCollector,
-      boolean useLazyPreparation,
       Clock clock,
       Looper looper) {
-    this(renderers, trackSelector, loadControl, bandwidthMeter, clock, looper, null);
-  }
-
-  /**
-   * Constructs an instance. Must be called from a thread that has an associated {@link Looper}.
-   *
-   * @param renderers The {@link Renderer}s that will be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
-   * @param clock The {@link Clock} that will be used by the instance.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
-   * @param videoComponent The {@link VideoComponent} that will be used by the instance.
-   */
-  @SuppressLint("HandlerLeak")
-  public ExoPlayerImpl(
-     Renderer[] renderers,
-      TrackSelector trackSelector,
-      LoadControl loadControl,
-      BandwidthMeter bandwidthMeter,
-      Clock clock,
-      Looper looper,
-      VideoComponent videoComponent) {
     Log.i(TAG, "Init " + Integer.toHexString(System.identityHashCode(this)) + " ["
         + ExoPlayerLibraryInfo.VERSION_SLASHY + "] [" + Util.DEVICE_DEBUG_INFO + "]");
     Assertions.checkState(renderers.length > 0);
     this.renderers = Assertions.checkNotNull(renderers);
     this.trackSelector = Assertions.checkNotNull(trackSelector);
-    this.useLazyPreparation = useLazyPreparation;
-    playWhenReady = false;
-    videoComponent = videoComponent;
-    repeatMode = Player.REPEAT_MODE_OFF;
-    shuffleModeEnabled = false;
-    listeners = new CopyOnWriteArrayList<>();
-    mediaSourceHolders = new ArrayList<>();
-    shuffleOrder = new ShuffleOrder.DefaultShuffleOrder(/* length= */ 0);
-
+    this.playWhenReady = false;
+    this.repeatMode = Player.REPEAT_MODE_OFF;
+    this.shuffleModeEnabled = false;
+    this.listeners = new CopyOnWriteArrayList<>();
     emptyTrackSelectorResult =
         new TrackSelectorResult(
             new RendererConfiguration[renderers.length],
@@ -172,9 +129,6 @@ import java.util.concurrent.CopyOnWriteArraySet;
         };
     playbackInfo = PlaybackInfo.createDummy(/* startPositionUs= */ 0, emptyTrackSelectorResult);
     pendingListenerNotifications = new ArrayDeque<>();
-    if (analyticsCollector != null) {
-      analyticsCollector.setPlayer(this);
-    }
     internalPlayer =
         new ExoPlayerImplInternal(
             renderers,
@@ -185,7 +139,6 @@ import java.util.concurrent.CopyOnWriteArraySet;
             playWhenReady,
             repeatMode,
             shuffleModeEnabled,
-            analyticsCollector,
             eventHandler,
             clock);
     internalPlayerHandler = new Handler(internalPlayer.getPlaybackLooper());
@@ -200,7 +153,7 @@ import java.util.concurrent.CopyOnWriteArraySet;
   @Override
   @Nullable
   public VideoComponent getVideoComponent() {
-    return videoComponent;
+    return null;
   }
 
   @Override
@@ -259,168 +212,41 @@ import java.util.concurrent.CopyOnWriteArraySet;
   }
 
   @Override
-  @Deprecated
   public void retry() {
-    prepare();
+    if (mediaSource != null && playbackInfo.playbackState == Player.STATE_IDLE) {
+      prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
+    }
   }
 
   @Override
-  public void prepare() {
-    if (playbackInfo.playbackState != Player.STATE_IDLE) {
-      return;
-    }
+  public void prepare(MediaSource mediaSource) {
+    prepare(mediaSource, /* resetPosition= */ true, /* resetState= */ true);
+  }
+
+  @Override
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    this.mediaSource = mediaSource;
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
-            /* clearPlaylist= */ false,
+            resetPosition,
+            resetState,
             /* resetError= */ true,
             /* playbackState= */ Player.STATE_BUFFERING);
     // Trigger internal prepare first before updating the playback info and notifying external
     // listeners to ensure that new operations issued in the listener notifications reach the
     // player after this prepare. The internal player can't change the playback info immediately
     // because it uses a callback.
+    hasPendingPrepare = true;
     pendingOperationAcks++;
-    internalPlayer.prepare();
+    internalPlayer.prepare(mediaSource, resetPosition, resetState);
     updatePlaybackInfo(
         playbackInfo,
         /* positionDiscontinuity= */ false,
         /* ignored */ DISCONTINUITY_REASON_INTERNAL,
-        /* ignored */ TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
+        TIMELINE_CHANGE_REASON_RESET,
         /* seekProcessed= */ false);
   }
 
-  @Override
-  @Deprecated
-  public void prepare(MediaSource mediaSource) {
-    setMediaItem(mediaSource);
-    prepare();
-  }
-
-  @Override
-  @Deprecated
-  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-    setMediaItem(
-        mediaSource, /* startPositionMs= */ resetPosition ? C.TIME_UNSET : getCurrentPosition());
-    prepare();
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem) {
-    setMediaItems(Collections.singletonList(mediaItem));
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem, long startPositionMs) {
-    setMediaItems(Collections.singletonList(mediaItem), /* startWindowIndex= */ 0, startPositionMs);
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems) {
-    setMediaItems(
-        mediaItems, /* startWindowIndex= */ C.INDEX_UNSET, /* startPositionMs */ C.TIME_UNSET);
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition) {
-    setMediaItems(
-        mediaItems,
-        /* startWindowIndex= */ resetPosition ? C.INDEX_UNSET : getCurrentWindowIndex(),
-        /* startPositionMs= */ resetPosition ? C.TIME_UNSET : getCurrentPosition());
-  }
-
-  @Override
-  public void setMediaItems(
-      List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs) {
-    pendingOperationAcks++;
-    if (!mediaSourceHolders.isEmpty()) {
-      removeMediaSourceHolders(
-          /* fromIndex= */ 0, /* toIndexExclusive= */ mediaSourceHolders.size());
-    }
-    List<Playlist.MediaSourceHolder> holders = addMediaSourceHolders(/* index= */ 0, mediaItems);
-    Timeline timeline = maskTimeline();
-    internalPlayer.setMediaItems(
-        holders, startWindowIndex, C.msToUs(startPositionMs), shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
-
-  @Override
-  public void addMediaItem(MediaSource mediaSource) {
-    addMediaItems(Collections.singletonList(mediaSource));
-  }
-
-  @Override
-  public void addMediaItem(int index, MediaSource mediaSource) {
-    addMediaItems(index, Collections.singletonList(mediaSource));
-  }
-
-  @Override
-  public void addMediaItems(List<MediaSource> mediaSources) {
-    addMediaItems(/* index= */ mediaSourceHolders.size(), mediaSources);
-  }
-
-  @Override
-  public void addMediaItems(int index, List<MediaSource> mediaSources) {
-    Assertions.checkArgument(index >= 0);
-    pendingOperationAcks++;
-    List<Playlist.MediaSourceHolder> holders = addMediaSourceHolders(index, mediaSources);
-    Timeline timeline = maskTimeline();
-    internalPlayer.addMediaItems(index, holders, shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
-
-  @Override
-  public MediaSource removeMediaItem(int index) {
-    List<Playlist.MediaSourceHolder> mediaSourceHolders =
-        removeMediaItemsInternal(/* fromIndex= */ index, /* toIndex= */ index + 1);
-    return mediaSourceHolders.isEmpty() ? null : mediaSourceHolders.get(0).mediaSource;
-  }
-
-  @Override
-  public void removeMediaItems(int fromIndex, int toIndex) {
-    Assertions.checkArgument(toIndex > fromIndex);
-    removeMediaItemsInternal(fromIndex, toIndex);
-  }
-
-  @Override
-  public void moveMediaItem(int currentIndex, int newIndex) {
-    Assertions.checkArgument(currentIndex != newIndex);
-    moveMediaItems(/* fromIndex= */ currentIndex, /* toIndex= */ currentIndex + 1, newIndex);
-  }
-
-  @Override
-  public void moveMediaItems(int fromIndex, int toIndex, int newFromIndex) {
-    Assertions.checkArgument(
-        fromIndex >= 0
-            && fromIndex <= toIndex
-            && toIndex <= mediaSourceHolders.size()
-            && newFromIndex >= 0);
-    pendingOperationAcks++;
-    newFromIndex = Math.min(newFromIndex, mediaSourceHolders.size() - (toIndex - fromIndex));
-    Playlist.moveMediaSourceHolders(mediaSourceHolders, fromIndex, toIndex, newFromIndex);
-    Timeline timeline = maskTimeline();
-    internalPlayer.moveMediaItems(fromIndex, toIndex, newFromIndex, shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
-
-  @Override
-  public void clearMediaItems() {
-    if (mediaSourceHolders.isEmpty()) {
-      return;
-    }
-    removeMediaItemsInternal(/* fromIndex= */ 0, /* toIndex= */ mediaSourceHolders.size());
-  }
-
-  @Override
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    pendingOperationAcks++;
-    this.shuffleOrder = shuffleOrder;
-    Timeline timeline = maskTimeline();
-    internalPlayer.setShuffleOrder(shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
 
   @Override
   public void setPlayWhenReady(boolean playWhenReady) {
@@ -438,17 +264,21 @@ import java.util.concurrent.CopyOnWriteArraySet;
       internalPlayer.setPlayWhenReady(internalPlayWhenReady);
     }
     boolean playWhenReadyChanged = this.playWhenReady != playWhenReady;
+    boolean suppressionReasonChanged = this.playbackSuppressionReason != playbackSuppressionReason;
     this.playWhenReady = playWhenReady;
     this.playbackSuppressionReason = playbackSuppressionReason;
     boolean isPlaying = isPlaying();
     boolean isPlayingChanged = oldIsPlaying != isPlaying;
-    if (playWhenReadyChanged || isPlayingChanged) {
+    if (playWhenReadyChanged || suppressionReasonChanged || isPlayingChanged) {
       int playbackState = playbackInfo.playbackState;
       notifyListeners(
           listener -> {
             if (playWhenReadyChanged) {
               listener.onPlayerStateChanged(playWhenReady, playbackState);
             }
+            if (suppressionReasonChanged) {
+              listener.onPlaybackSuppressionReasonChanged(playbackSuppressionReason);
+            }
             if (isPlayingChanged) {
               listener.onIsPlayingChanged(isPlaying);
             }
@@ -578,9 +408,13 @@ import java.util.concurrent.CopyOnWriteArraySet;
 
   @Override
   public void stop(boolean reset) {
+    if (reset) {
+      mediaSource = null;
+    }
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
-            /* clearPlaylist= */ reset,
+            /* resetPosition= */ reset,
+            /* resetState= */ reset,
             /* resetError= */ reset,
             /* playbackState= */ Player.STATE_IDLE);
     // Trigger internal stop first before updating the playback info and notifying external
@@ -593,7 +427,7 @@ import java.util.concurrent.CopyOnWriteArraySet;
         playbackInfo,
         /* positionDiscontinuity= */ false,
         /* ignored */ DISCONTINUITY_REASON_INTERNAL,
-        TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
+        TIMELINE_CHANGE_REASON_RESET,
         /* seekProcessed= */ false);
   }
 
@@ -602,11 +436,13 @@ import java.util.concurrent.CopyOnWriteArraySet;
     Log.i(TAG, "Release " + Integer.toHexString(System.identityHashCode(this)) + " ["
         + ExoPlayerLibraryInfo.VERSION_SLASHY + "] [" + Util.DEVICE_DEBUG_INFO + "] ["
         + ExoPlayerLibraryInfo.registeredModules() + "]");
+    mediaSource = null;
     internalPlayer.release();
     eventHandler.removeCallbacksAndMessages(null);
     playbackInfo =
         getResetPlaybackInfo(
-            /* clearPlaylist= */ false,
+            /* resetPosition= */ false,
+            /* resetState= */ false,
             /* resetError= */ false,
             /* playbackState= */ Player.STATE_IDLE);
   }
@@ -754,11 +590,10 @@ import java.util.concurrent.CopyOnWriteArraySet;
 
   // Not private so it can be called from an inner class without going through a thunk method.
   /* package */ void handleEvent(Message msg) {
-
     switch (msg.what) {
       case ExoPlayerImplInternal.MSG_PLAYBACK_INFO_CHANGED:
         handlePlaybackInfo(
-            /* playbackInfo= */ (PlaybackInfo) msg.obj,
+            (PlaybackInfo) msg.obj,
             /* operationAcks= */ msg.arg1,
             /* positionDiscontinuity= */ msg.arg2 != C.INDEX_UNSET,
             /* positionDiscontinuityReason= */ msg.arg2);
@@ -806,23 +641,29 @@ import java.util.concurrent.CopyOnWriteArraySet;
         maskingWindowIndex = 0;
         maskingWindowPositionMs = 0;
       }
+      @Player.TimelineChangeReason
+      int timelineChangeReason =
+          hasPendingPrepare
+              ? Player.TIMELINE_CHANGE_REASON_PREPARED
+              : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
       boolean seekProcessed = hasPendingSeek;
+      hasPendingPrepare = false;
       hasPendingSeek = false;
       updatePlaybackInfo(
           playbackInfo,
           positionDiscontinuity,
           positionDiscontinuityReason,
-          TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
+          timelineChangeReason,
           seekProcessed);
     }
   }
 
   private PlaybackInfo getResetPlaybackInfo(
-      boolean clearPlaylist, boolean resetError, @Player.State int playbackState) {
-    if (clearPlaylist) {
-      // Reset list of media source holders which are used for creating the masking timeline.
-      removeMediaSourceHolders(
-          /* fromIndex= */ 0, /* toIndexExclusive= */ mediaSourceHolders.size());
+      boolean resetPosition,
+      boolean resetState,
+      boolean resetError,
+      @Player.State int playbackState) {
+    if (resetPosition) {
       maskingWindowIndex = 0;
       maskingPeriodIndex = 0;
       maskingWindowPositionMs = 0;
@@ -831,22 +672,24 @@ import java.util.concurrent.CopyOnWriteArraySet;
       maskingPeriodIndex = getCurrentPeriodIndex();
       maskingWindowPositionMs = getCurrentPosition();
     }
+    // Also reset period-based PlaybackInfo positions if resetting the state.
+    resetPosition = resetPosition || resetState;
     MediaPeriodId mediaPeriodId =
-        clearPlaylist
+        resetPosition
             ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window, period)
             : playbackInfo.periodId;
-    long startPositionUs = clearPlaylist ? 0 : playbackInfo.positionUs;
-    long contentPositionUs = clearPlaylist ? C.TIME_UNSET : playbackInfo.contentPositionUs;
+    long startPositionUs = resetPosition ? 0 : playbackInfo.positionUs;
+    long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     return new PlaybackInfo(
-        clearPlaylist ? Timeline.EMPTY : playbackInfo.timeline,
+        resetState ? Timeline.EMPTY : playbackInfo.timeline,
         mediaPeriodId,
         startPositionUs,
         contentPositionUs,
         playbackState,
         resetError ? null : playbackInfo.playbackError,
         /* isLoading= */ false,
-        clearPlaylist ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
-        clearPlaylist ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
+        resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
+        resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
         mediaPeriodId,
         startPositionUs,
         /* totalBufferedDurationUs= */ 0,
@@ -856,8 +699,8 @@ import java.util.concurrent.CopyOnWriteArraySet;
   private void updatePlaybackInfo(
       PlaybackInfo playbackInfo,
       boolean positionDiscontinuity,
-      @DiscontinuityReason int positionDiscontinuityReason,
-      @TimelineChangeReason int timelineChangeReason,
+      @Player.DiscontinuityReason int positionDiscontinuityReason,
+      @Player.TimelineChangeReason int timelineChangeReason,
       boolean seekProcessed) {
     boolean previousIsPlaying = isPlaying();
     // Assign playback info immediately such that all getters return the right values.
@@ -878,53 +721,6 @@ import java.util.concurrent.CopyOnWriteArraySet;
             /* isPlayingChanged= */ previousIsPlaying != isPlaying));
   }
 
-  private List<Playlist.MediaSourceHolder> addMediaSourceHolders(
-      int index, List<MediaSource> mediaSources) {
-    List<Playlist.MediaSourceHolder> holders = new ArrayList<>();
-    for (int i = 0; i < mediaSources.size(); i++) {
-      Playlist.MediaSourceHolder holder =
-          new Playlist.MediaSourceHolder(mediaSources.get(i), useLazyPreparation);
-      holders.add(holder);
-      mediaSourceHolders.add(i + index, holder);
-    }
-    shuffleOrder =
-        shuffleOrder.cloneAndInsert(
-            /* insertionIndex= */ index, /* insertionCount= */ holders.size());
-    return holders;
-  }
-
-  private List<Playlist.MediaSourceHolder> removeMediaItemsInternal(int fromIndex, int toIndex) {
-    Assertions.checkArgument(
-        fromIndex >= 0 && toIndex >= fromIndex && toIndex <= mediaSourceHolders.size());
-    pendingOperationAcks++;
-    List<Playlist.MediaSourceHolder> mediaSourceHolders =
-        removeMediaSourceHolders(fromIndex, /* toIndexExclusive= */ toIndex);
-    Timeline timeline = maskTimeline();
-    internalPlayer.removeMediaItems(fromIndex, toIndex, shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-    return mediaSourceHolders;
-  }
-
-  private List<Playlist.MediaSourceHolder> removeMediaSourceHolders(
-      int fromIndex, int toIndexExclusive) {
-    List<Playlist.MediaSourceHolder> removed = new ArrayList<>();
-    for (int i = toIndexExclusive - 1; i >= fromIndex; i--) {
-      removed.add(mediaSourceHolders.remove(i));
-    }
-    shuffleOrder = shuffleOrder.cloneAndRemove(fromIndex, toIndexExclusive);
-    return removed;
-  }
-
-  private Timeline maskTimeline() {
-    playbackInfo =
-        playbackInfo.copyWithTimeline(
-            mediaSourceHolders.isEmpty()
-                ? Timeline.EMPTY
-                : new Playlist.PlaylistTimeline(mediaSourceHolders, shuffleOrder));
-    return playbackInfo.timeline;
-  }
-
   private void notifyListeners(ListenerInvocation listenerInvocation) {
     CopyOnWriteArrayList<ListenerHolder> listenerSnapshot = new CopyOnWriteArrayList<>(listeners);
     notifyListeners(() -> invokeAll(listenerSnapshot, listenerInvocation));
@@ -960,7 +756,7 @@ import java.util.concurrent.CopyOnWriteArraySet;
     private final TrackSelector trackSelector;
     private final boolean positionDiscontinuity;
     private final @Player.DiscontinuityReason int positionDiscontinuityReason;
-    private final int timelineChangeReason;
+    private final @Player.TimelineChangeReason int timelineChangeReason;
     private final boolean seekProcessed;
     private final boolean playbackStateChanged;
     private final boolean playbackErrorChanged;
@@ -994,16 +790,15 @@ import java.util.concurrent.CopyOnWriteArraySet;
       playbackErrorChanged =
           previousPlaybackInfo.playbackError != playbackInfo.playbackError
               && playbackInfo.playbackError != null;
+      timelineChanged = previousPlaybackInfo.timeline != playbackInfo.timeline;
       isLoadingChanged = previousPlaybackInfo.isLoading != playbackInfo.isLoading;
-      timelineChanged =
-          !Util.areTimelinesSame(previousPlaybackInfo.timeline, playbackInfo.timeline);
       trackSelectorResultChanged =
           previousPlaybackInfo.trackSelectorResult != playbackInfo.trackSelectorResult;
     }
 
     @Override
     public void run() {
-      if (timelineChanged) {
+      if (timelineChanged || timelineChangeReason == TIMELINE_CHANGE_REASON_PREPARED) {
         invokeAll(
             listenerSnapshot,
             listener -> listener.onTimelineChanged(playbackInfo.timeline, timelineChangeReason));
diff --git a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index f9cbaa1..240c643 100644
--- a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -22,15 +22,14 @@ import android.os.Message;
 import android.os.Process;
 import android.os.SystemClock;
 import android.util.Pair;
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
-import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSource.MediaSourceCaller;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
@@ -45,7 +44,6 @@ import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Implements the internal behavior of {@link ExoPlayerImpl}. */
@@ -53,7 +51,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
     implements Handler.Callback,
         MediaPeriod.Callback,
         TrackSelector.InvalidationListener,
-        Playlist.PlaylistInfoRefreshListener,
+        MediaSourceCaller,
         PlaybackParameterListener,
         PlayerMessage.Sender {
 
@@ -72,24 +70,18 @@ import java.util.concurrent.atomic.AtomicBoolean;
   private static final int MSG_SET_SEEK_PARAMETERS = 5;
   private static final int MSG_STOP = 6;
   private static final int MSG_RELEASE = 7;
-  private static final int MSG_PERIOD_PREPARED = 8;
-  private static final int MSG_SOURCE_CONTINUE_LOADING_REQUESTED = 9;
-  private static final int MSG_TRACK_SELECTION_INVALIDATED = 10;
-  private static final int MSG_SET_REPEAT_MODE = 11;
-  private static final int MSG_SET_SHUFFLE_ENABLED = 12;
-  private static final int MSG_SET_FOREGROUND_MODE = 13;
-  private static final int MSG_SEND_MESSAGE = 14;
-  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 15;
-  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 16;
-  private static final int MSG_SET_MEDIA_ITEMS = 17;
-  private static final int MSG_ADD_MEDIA_ITEMS = 18;
-  private static final int MSG_MOVE_MEDIA_ITEMS = 19;
-  private static final int MSG_REMOVE_MEDIA_ITEMS = 20;
-  private static final int MSG_SET_SHUFFLE_ORDER = 21;
-  private static final int MSG_PLAYLIST_UPDATE_REQUESTED = 22;
+  private static final int MSG_REFRESH_SOURCE_INFO = 8;
+  private static final int MSG_PERIOD_PREPARED = 9;
+  private static final int MSG_SOURCE_CONTINUE_LOADING_REQUESTED = 10;
+  private static final int MSG_TRACK_SELECTION_INVALIDATED = 11;
+  private static final int MSG_SET_REPEAT_MODE = 12;
+  private static final int MSG_SET_SHUFFLE_ENABLED = 13;
+  private static final int MSG_SET_FOREGROUND_MODE = 14;
+  private static final int MSG_SEND_MESSAGE = 15;
+  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 16;
+  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 17;
 
   private static final int ACTIVE_INTERVAL_MS = 10;
-  private static final int LOW_ACTIVE_INTERVAL_MS = 20;
   private static final int IDLE_INTERVAL_MS = 1000;
 
   private final Renderer[] renderers;
@@ -110,23 +102,26 @@ import java.util.concurrent.atomic.AtomicBoolean;
   private final ArrayList<PendingMessageInfo> pendingMessages;
   private final Clock clock;
   private final MediaPeriodQueue queue;
-  private final Playlist playlist;
 
   @SuppressWarnings("unused")
   private SeekParameters seekParameters;
 
   private PlaybackInfo playbackInfo;
+  private MediaSource mediaSource;
   private Renderer[] enabledRenderers;
   private boolean released;
   private boolean playWhenReady;
   private boolean rebuffering;
+  private boolean shouldContinueLoading;
   @Player.RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
   private boolean foregroundMode;
 
-  @Nullable private SeekPosition pendingInitialSeekPosition;
+  private int pendingPrepareCount;
+  private SeekPosition pendingInitialSeekPosition;
   private long rendererPositionUs;
   private int nextPendingMessageIndex;
+  private boolean deliverPendingMessageAtStartPositionRequired;
 
   public ExoPlayerImplInternal(
       Renderer[] renderers,
@@ -137,7 +132,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
       boolean playWhenReady,
       @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled,
-      @Nullable AnalyticsCollector analyticsCollector,
       Handler eventHandler,
       Clock clock) {
     this.renderers = renderers;
@@ -177,14 +171,13 @@ import java.util.concurrent.atomic.AtomicBoolean;
         new HandlerThread("ExoPlayerImplInternal:Handler", Process.THREAD_PRIORITY_AUDIO);
     internalPlaybackThread.start();
     handler = clock.createHandler(internalPlaybackThread.getLooper(), this);
-    playlist = new Playlist(this);
-    if (analyticsCollector != null) {
-      playlist.setAnalyticsCollector(eventHandler, analyticsCollector);
-    }
+    deliverPendingMessageAtStartPositionRequired = true;
   }
 
-  public void prepare() {
-    handler.obtainMessage(MSG_PREPARE).sendToTarget();
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    handler
+        .obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, resetState ? 1 : 0, mediaSource)
+        .sendToTarget();
   }
 
   public void setPlayWhenReady(boolean playWhenReady) {
@@ -217,65 +210,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
     handler.obtainMessage(MSG_STOP, reset ? 1 : 0, 0).sendToTarget();
   }
 
-  public void setMediaItems(
-      List<Playlist.MediaSourceHolder> mediaSources, ShuffleOrder shuffleOrder) {
-    setMediaItems(
-        mediaSources,
-        /* windowIndex= */ C.INDEX_UNSET,
-        /* positionUs= */ C.TIME_UNSET,
-        shuffleOrder);
-  }
-
-  public void setMediaItems(
-      List<Playlist.MediaSourceHolder> mediaSources,
-      int windowIndex,
-      long positionUs,
-      ShuffleOrder shuffleOrder) {
-    handler
-        .obtainMessage(
-            MSG_SET_MEDIA_ITEMS,
-            new PlaylistUpdateMessage(mediaSources, shuffleOrder, windowIndex, positionUs))
-        .sendToTarget();
-  }
-
-  public void addMediaItems(
-      List<Playlist.MediaSourceHolder> mediaSources, ShuffleOrder shuffleOrder) {
-    addMediaItems(C.INDEX_UNSET, mediaSources, shuffleOrder);
-  }
-
-  public void addMediaItems(
-      int index, List<Playlist.MediaSourceHolder> mediaSources, ShuffleOrder shuffleOrder) {
-    handler
-        .obtainMessage(
-            MSG_ADD_MEDIA_ITEMS,
-            index,
-            /* ignored */ 0,
-            new PlaylistUpdateMessage(
-                mediaSources,
-                shuffleOrder,
-                /* windowIndex= */ C.INDEX_UNSET,
-                /* positionUs= */ C.TIME_UNSET))
-        .sendToTarget();
-  }
-
-  public void removeMediaItems(int fromIndex, int toIndex, ShuffleOrder shuffleOrder) {
-    handler.obtainMessage(MSG_REMOVE_MEDIA_ITEMS, fromIndex, toIndex, shuffleOrder).sendToTarget();
-  }
-
-  public void moveMediaItems(
-      int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {
-    MoveMediaItemsMessage moveMediaItemsMessage =
-        new MoveMediaItemsMessage(fromIndex, toIndex, newFromIndex, shuffleOrder);
-    handler.obtainMessage(MSG_MOVE_MEDIA_ITEMS, moveMediaItemsMessage).sendToTarget();
-  }
-
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    handler.obtainMessage(MSG_SET_SHUFFLE_ORDER, shuffleOrder).sendToTarget();
-  }
-
   @Override
   public synchronized void sendMessage(PlayerMessage message) {
-    if (released) {
+    if (released || !internalPlaybackThread.isAlive()) {
       Log.w(TAG, "Ignoring messages sent after release.");
       message.markAsProcessed(/* isDelivered= */ false);
       return;
@@ -284,6 +221,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
   }
 
   public synchronized void setForegroundMode(boolean foregroundMode) {
+    if (released || !internalPlaybackThread.isAlive()) {
+      return;
+    }
     if (foregroundMode) {
       handler.obtainMessage(MSG_SET_FOREGROUND_MODE, /* foregroundMode */ 1, 0).sendToTarget();
     } else {
@@ -292,7 +232,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
           .obtainMessage(MSG_SET_FOREGROUND_MODE, /* foregroundMode */ 0, 0, processedFlag)
           .sendToTarget();
       boolean wasInterrupted = false;
-      while (!processedFlag.get() && !released) {
+      while (!processedFlag.get()) {
         try {
           wait();
         } catch (InterruptedException e) {
@@ -307,7 +247,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
   }
 
   public synchronized void release() {
-    if (released) {
+    if (released || !internalPlaybackThread.isAlive()) {
       return;
     }
     handler.sendEmptyMessage(MSG_RELEASE);
@@ -329,11 +269,13 @@ import java.util.concurrent.atomic.AtomicBoolean;
     return internalPlaybackThread.getLooper();
   }
 
-  // Playlist.PlaylistInfoRefreshListener implementation.
+  // MediaSource.MediaSourceCaller implementation.
 
   @Override
-  public void onPlaylistUpdateRequested() {
-    handler.sendEmptyMessage(MSG_PLAYLIST_UPDATE_REQUESTED);
+  public void onSourceInfoRefreshed(MediaSource source, Timeline timeline) {
+    handler
+        .obtainMessage(MSG_REFRESH_SOURCE_INFO, new MediaSourceRefreshInfo(source, timeline))
+        .sendToTarget();
   }
 
   // MediaPeriod.Callback implementation.
@@ -365,12 +307,14 @@ import java.util.concurrent.atomic.AtomicBoolean;
   // Handler.Callback implementation.
 
   @Override
-  @SuppressWarnings("unchecked")
   public boolean handleMessage(Message msg) {
     try {
       switch (msg.what) {
         case MSG_PREPARE:
-          prepareInternal();
+          prepareInternal(
+              (MediaSource) msg.obj,
+              /* resetPosition= */ msg.arg1 != 0,
+              /* resetState= */ msg.arg2 != 0);
           break;
         case MSG_SET_PLAY_WHEN_READY:
           setPlayWhenReadyInternal(msg.arg1 != 0);
@@ -406,6 +350,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
         case MSG_PERIOD_PREPARED:
           handlePeriodPrepared((MediaPeriod) msg.obj);
           break;
+        case MSG_REFRESH_SOURCE_INFO:
+          handleSourceInfoRefreshed((MediaSourceRefreshInfo) msg.obj);
+          break;
         case MSG_SOURCE_CONTINUE_LOADING_REQUESTED:
           handleContinueLoadingRequested((MediaPeriod) msg.obj);
           break;
@@ -422,24 +369,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
         case MSG_SEND_MESSAGE_TO_TARGET_THREAD:
           sendMessageToTargetThread((PlayerMessage) msg.obj);
           break;
-        case MSG_SET_MEDIA_ITEMS:
-          setMediaItemsInternal((PlaylistUpdateMessage) msg.obj);
-          break;
-        case MSG_ADD_MEDIA_ITEMS:
-          addMediaItemsInternal((PlaylistUpdateMessage) msg.obj, msg.arg1);
-          break;
-        case MSG_MOVE_MEDIA_ITEMS:
-          moveMediaItemsInternal((MoveMediaItemsMessage) msg.obj);
-          break;
-        case MSG_REMOVE_MEDIA_ITEMS:
-          removeMediaItemsInternal(msg.arg1, msg.arg2, (ShuffleOrder) msg.obj);
-          break;
-        case MSG_SET_SHUFFLE_ORDER:
-          setShuffleOrderInternal((ShuffleOrder) msg.obj);
-          break;
-        case MSG_PLAYLIST_UPDATE_REQUESTED:
-          playlistUpdateRequestedInternal();
-          break;
         case MSG_RELEASE:
           releaseInternal();
           // Return immediately to not send playback info updates after release.
@@ -449,7 +378,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
       }
       maybeNotifyPlaybackInfoChanged();
     } catch (ExoPlaybackException e) {
-      Log.e(TAG, "Playback error.", e);
+      Log.e(TAG, getExoPlaybackExceptionMessage(e), e);
       stopInternal(
           /* forceResetRenderers= */ true,
           /* resetPositionAndState= */ false,
@@ -482,15 +411,23 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
   // Private methods.
 
-  private void setState(int state) {
-    if (playbackInfo.playbackState != state) {
-      playbackInfo = playbackInfo.copyWithPlaybackState(state);
+  private String getExoPlaybackExceptionMessage(ExoPlaybackException e) {
+    if (e.type != ExoPlaybackException.TYPE_RENDERER) {
+      return "Playback error.";
     }
+    return "Renderer error: index="
+        + e.rendererIndex
+        + ", type="
+        + Util.getTrackTypeString(renderers[e.rendererIndex].getTrackType())
+        + ", format="
+        + e.rendererFormat
+        + ", rendererSupport="
+        + RendererCapabilities.getFormatSupportString(e.rendererFormatSupport);
   }
 
-  private void setIsLoading(boolean isLoading) {
-    if (playbackInfo.isLoading != isLoading) {
-      playbackInfo = playbackInfo.copyWithIsLoading(isLoading);
+  private void setState(int state) {
+    if (playbackInfo.playbackState != state) {
+      playbackInfo = playbackInfo.copyWithPlaybackState(state);
     }
   }
 
@@ -509,112 +446,37 @@ import java.util.concurrent.atomic.AtomicBoolean;
     }
   }
 
-  private void prepareInternal() {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
+  private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    pendingPrepareCount++;
     resetInternal(
         /* resetRenderers= */ false,
-        /* resetPosition= */ false,
-        /* releasePlaylist= */ false,
-        /* clearPlaylist= */ false,
+        /* releaseMediaSource= */ true,
+        resetPosition,
+        resetState,
         /* resetError= */ true);
     loadControl.onPrepared();
-    setState(playbackInfo.timeline.isEmpty() ? Player.STATE_ENDED : Player.STATE_BUFFERING);
-    playlist.prepare(bandwidthMeter.getTransferListener());
+    this.mediaSource = mediaSource;
+    setState(Player.STATE_BUFFERING);
+    mediaSource.prepareSource(/* caller= */ this, bandwidthMeter.getTransferListener());
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
-  private void setMediaItemsInternal(PlaylistUpdateMessage playlistUpdateMessage)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    if (playlistUpdateMessage.windowIndex != C.INDEX_UNSET) {
-      pendingInitialSeekPosition =
-          new SeekPosition(
-              new Playlist.PlaylistTimeline(
-                  playlistUpdateMessage.mediaSourceHolders, playlistUpdateMessage.shuffleOrder),
-              playlistUpdateMessage.windowIndex,
-              playlistUpdateMessage.positionUs);
-    }
-    Timeline timeline =
-        playlist.setMediaSources(
-            playlistUpdateMessage.mediaSourceHolders, playlistUpdateMessage.shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void addMediaItemsInternal(PlaylistUpdateMessage addMessage, int insertionIndex)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline =
-        playlist.addMediaSources(
-            insertionIndex == C.INDEX_UNSET ? playlist.getSize() : insertionIndex,
-            addMessage.mediaSourceHolders,
-            addMessage.shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void moveMediaItemsInternal(MoveMediaItemsMessage moveMediaItemsMessage)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline =
-        playlist.moveMediaSourceRange(
-            moveMediaItemsMessage.fromIndex,
-            moveMediaItemsMessage.toIndex,
-            moveMediaItemsMessage.newFromIndex,
-            moveMediaItemsMessage.shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void removeMediaItemsInternal(int fromIndex, int toIndex, ShuffleOrder shuffleOrder)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline = playlist.removeMediaSourceRange(fromIndex, toIndex, shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void playlistUpdateRequestedInternal() throws ExoPlaybackException {
-    handlePlaylistInfoRefreshed(playlist.createTimeline());
-  }
-
-  private void setShuffleOrderInternal(ShuffleOrder shuffleOrder) throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline = playlist.setShuffleOrder(shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
   private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackException {
     rebuffering = false;
     this.playWhenReady = playWhenReady;
     if (!playWhenReady) {
-      stopClockAndRenderers();
-      setPauseInternal();
+      stopRenderers();
       updatePlaybackPositions();
     } else {
       if (playbackInfo.playbackState == Player.STATE_READY) {
-        startClockAndRenderers();
-        setResumeInternal();
+        startRenderers();
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
       } else if (playbackInfo.playbackState == Player.STATE_BUFFERING) {
-        setResumeInternal();
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
       }
     }
   }
 
-  private void setPauseInternal(){
-    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
-
-    if (playingPeriodHolder != null) {
-      playingPeriodHolder.mediaPeriod.pause();
-    }
-  }
-
-  private void setResumeInternal(){
-    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
-
-    if (playingPeriodHolder != null) {
-      playingPeriodHolder.mediaPeriod.resume();
-    }
-  }
-
   private void setRepeatModeInternal(@Player.RepeatMode int repeatMode)
       throws ExoPlaybackException {
     this.repeatMode = repeatMode;
@@ -640,12 +502,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
     long newPositionUs =
         seekToPeriodPosition(periodId, playbackInfo.positionUs, /* forceDisableRenderers= */ true);
     if (newPositionUs != playbackInfo.positionUs) {
-      playbackInfo =
-          playbackInfo.copyWithNewPosition(
-              periodId,
-              newPositionUs,
-              playbackInfo.contentPositionUs,
-              getTotalBufferedDurationUs());
+      playbackInfo = copyWithNewPosition(periodId, newPositionUs, playbackInfo.contentPositionUs);
       if (sendDiscontinuity) {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
@@ -654,17 +511,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
   private void startRenderers() throws ExoPlaybackException {
     rebuffering = false;
-    if (!mediaClock.isStarted()) {
-      mediaClock.start();
-    }
-
-    for (Renderer renderer : enabledRenderers) {
-      renderer.start();
-    }
-  }
-
-  private void startClockAndRenderers() throws ExoPlaybackException {
-    rebuffering = false;
     mediaClock.start();
     for (Renderer renderer : enabledRenderers) {
       renderer.start();
@@ -672,12 +518,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
   }
 
   private void stopRenderers() throws ExoPlaybackException {
-    for (Renderer renderer : enabledRenderers) {
-      ensureStopped(renderer);
-    }
-  }
-
-  private void stopClockAndRenderers() throws ExoPlaybackException {
     mediaClock.stop();
     for (Renderer renderer : enabledRenderers) {
       ensureStopped(renderer);
@@ -701,11 +541,8 @@ import java.util.concurrent.atomic.AtomicBoolean;
       // renderers are flushed. Only report the discontinuity externally if the position changed.
       if (discontinuityPositionUs != playbackInfo.positionUs) {
         playbackInfo =
-            playbackInfo.copyWithNewPosition(
-                playbackInfo.periodId,
-                discontinuityPositionUs,
-                playbackInfo.contentPositionUs,
-                getTotalBufferedDurationUs());
+            copyWithNewPosition(
+                playbackInfo.periodId, discontinuityPositionUs, playbackInfo.contentPositionUs);
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
     } else {
@@ -789,26 +626,18 @@ import java.util.concurrent.atomic.AtomicBoolean;
             || playingPeriodDurationUs <= playbackInfo.positionUs)
         && playingPeriodHolder.info.isFinal) {
       setState(Player.STATE_ENDED);
-      stopClockAndRenderers();
+      stopRenderers();
     } else if (playbackInfo.playbackState == Player.STATE_BUFFERING
         && shouldTransitionToReadyState(renderersAllowPlayback)) {
       setState(Player.STATE_READY);
       if (playWhenReady) {
-        if (mediaSource.isLive()) {
-          startRenderers();
-        } else {
-          startClockAndRenderers();
-        }
+        startRenderers();
       }
     } else if (playbackInfo.playbackState == Player.STATE_READY
         && !(enabledRenderers.length == 0 ? isTimelineReady() : renderersAllowPlayback)) {
       rebuffering = playWhenReady;
       setState(Player.STATE_BUFFERING);
-      if (mediaSource.isLive()) {
-        stopRenderers();
-      } else {
-        stopClockAndRenderers();
-      }
+      stopRenderers();
     }
 
     if (playbackInfo.playbackState == Player.STATE_BUFFERING) {
@@ -819,8 +648,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
     if ((playWhenReady && playbackInfo.playbackState == Player.STATE_READY)
         || playbackInfo.playbackState == Player.STATE_BUFFERING) {
-      scheduleNextWork(operationStartTimeMs, mediaSource.isTcp() ? ACTIVE_INTERVAL_MS
-              : LOW_ACTIVE_INTERVAL_MS);
+      scheduleNextWork(operationStartTimeMs, ACTIVE_INTERVAL_MS);
     } else if (enabledRenderers.length != 0 && playbackInfo.playbackState != Player.STATE_ENDED) {
       scheduleNextWork(operationStartTimeMs, IDLE_INTERVAL_MS);
     } else {
@@ -842,7 +670,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
     long periodPositionUs;
     long contentPositionUs;
     boolean seekPositionAdjusted;
-    @Nullable
     Pair<Object, Long> resolvedSeekPosition =
         resolveSeekPosition(seekPosition, /* trySubsequentPeriods= */ true);
     if (resolvedSeekPosition == null) {
@@ -867,7 +694,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
     }
 
     try {
-      if (playbackInfo.timeline.isEmpty() || !playlist.isPrepared()) {
+      if (mediaSource == null || pendingPrepareCount > 0) {
         // Save seek position for later, as we are still waiting for a prepared source.
         pendingInitialSeekPosition = seekPosition;
       } else if (periodPositionUs == C.TIME_UNSET) {
@@ -875,9 +702,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
         setState(Player.STATE_ENDED);
         resetInternal(
             /* resetRenderers= */ false,
+            /* releaseMediaSource= */ false,
             /* resetPosition= */ true,
-            /* releasePlaylist= */ false,
-            /* clearPlaylist= */ false,
+            /* resetState= */ false,
             /* resetError= */ true);
       } else {
         // Execute the seek in the current media periods.
@@ -902,9 +729,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
         periodPositionUs = newPeriodPositionUs;
       }
     } finally {
-      playbackInfo =
-          playbackInfo.copyWithNewPosition(
-              periodId, periodPositionUs, contentPositionUs, getTotalBufferedDurationUs());
+      playbackInfo = copyWithNewPosition(periodId, periodPositionUs, contentPositionUs);
       if (seekPositionAdjusted) {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
       }
@@ -921,7 +746,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
   private long seekToPeriodPosition(
       MediaPeriodId periodId, long periodPositionUs, boolean forceDisableRenderers)
       throws ExoPlaybackException {
-    stopClockAndRenderers();
+    stopRenderers();
     rebuffering = false;
     if (playbackInfo.playbackState != Player.STATE_IDLE && !playbackInfo.timeline.isEmpty()) {
       setState(Player.STATE_BUFFERING);
@@ -1024,11 +849,13 @@ import java.util.concurrent.atomic.AtomicBoolean;
       boolean forceResetRenderers, boolean resetPositionAndState, boolean acknowledgeStop) {
     resetInternal(
         /* resetRenderers= */ forceResetRenderers || !foregroundMode,
+        /* releaseMediaSource= */ true,
         /* resetPosition= */ resetPositionAndState,
-        /* releasePlaylist= */ true,
-        /* clearPlaylist= */ resetPositionAndState,
+        /* resetState= */ resetPositionAndState,
         /* resetError= */ resetPositionAndState);
-    playbackInfoUpdate.incrementPendingOperationAcks(acknowledgeStop ? 1 : 0);
+    playbackInfoUpdate.incrementPendingOperationAcks(
+        pendingPrepareCount + (acknowledgeStop ? 1 : 0));
+    pendingPrepareCount = 0;
     loadControl.onStopped();
     setState(Player.STATE_IDLE);
   }
@@ -1036,9 +863,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
   private void releaseInternal() {
     resetInternal(
         /* resetRenderers= */ true,
+        /* releaseMediaSource= */ true,
         /* resetPosition= */ true,
-        /* releasePlaylist= */ true,
-        /* clearPlaylist= */ true,
+        /* resetState= */ true,
         /* resetError= */ false);
     loadControl.onReleased();
     setState(Player.STATE_IDLE);
@@ -1051,9 +878,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
   private void resetInternal(
       boolean resetRenderers,
+      boolean releaseMediaSource,
       boolean resetPosition,
-      boolean releasePlaylist,
-      boolean clearPlaylist,
+      boolean resetState,
       boolean resetError) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
@@ -1081,8 +908,8 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
     if (resetPosition) {
       pendingInitialSeekPosition = null;
-    } else if (clearPlaylist) {
-      // When clearing the playlist, also reset the period-based PlaybackInfo position and convert
+    } else if (resetState) {
+      // When resetting the state, also reset the period-based PlaybackInfo position and convert
       // existing position to initial seek instead.
       resetPosition = true;
       if (pendingInitialSeekPosition == null && !playbackInfo.timeline.isEmpty()) {
@@ -1093,10 +920,10 @@ import java.util.concurrent.atomic.AtomicBoolean;
       }
     }
 
-    queue.clear(/* keepFrontPeriodUid= */ !clearPlaylist);
-    setIsLoading(false);
-    if (clearPlaylist) {
-      queue.setTimeline(playlist.clear(/* shuffleOrder= */ null));
+    queue.clear(/* keepFrontPeriodUid= */ !resetState);
+    shouldContinueLoading = false;
+    if (resetState) {
+      queue.setTimeline(Timeline.EMPTY);
       for (PendingMessageInfo pendingMessageInfo : pendingMessages) {
         pendingMessageInfo.message.markAsProcessed(/* isDelivered= */ false);
       }
@@ -1112,21 +939,24 @@ import java.util.concurrent.atomic.AtomicBoolean;
     long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     playbackInfo =
         new PlaybackInfo(
-            clearPlaylist ? Timeline.EMPTY : playbackInfo.timeline,
+            resetState ? Timeline.EMPTY : playbackInfo.timeline,
             mediaPeriodId,
             startPositionUs,
             contentPositionUs,
             playbackInfo.playbackState,
             resetError ? null : playbackInfo.playbackError,
             /* isLoading= */ false,
-            clearPlaylist ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
-            clearPlaylist ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
+            resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
+            resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
             mediaPeriodId,
             startPositionUs,
             /* totalBufferedDurationUs= */ 0,
             startPositionUs);
-    if (releasePlaylist) {
-      playlist.release();
+    if (releaseMediaSource) {
+      if (mediaSource != null) {
+        mediaSource.releaseSource(/* caller= */ this);
+        mediaSource = null;
+      }
     }
   }
 
@@ -1134,7 +964,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
     if (message.getPositionMs() == C.TIME_UNSET) {
       // If no delivery time is specified, trigger immediate message delivery.
       sendMessageToTarget(message);
-    } else if (playbackInfo.timeline.isEmpty()) {
+    } else if (mediaSource == null || pendingPrepareCount > 0) {
       // Still waiting for initial timeline to resolve position.
       pendingMessages.add(new PendingMessageInfo(message));
     } else {
@@ -1164,6 +994,11 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
   private void sendMessageToTargetThread(final PlayerMessage message) {
     Handler handler = message.getHandler();
+    if (!handler.getLooper().getThread().isAlive()) {
+      Log.w("TAG", "Trying to send message on a dead thread.");
+      message.markAsProcessed(/* isDelivered= */ false);
+      return;
+    }
     handler.post(
         () -> {
           try {
@@ -1232,10 +1067,13 @@ import java.util.concurrent.atomic.AtomicBoolean;
       return;
     }
     // If this is the first call from the start position, include oldPeriodPositionUs in potential
-    // trigger positions.
-    if (playbackInfo.startPositionUs == oldPeriodPositionUs) {
+    // trigger positions, but make sure we deliver it only once.
+    if (playbackInfo.startPositionUs == oldPeriodPositionUs
+        && deliverPendingMessageAtStartPositionRequired) {
       oldPeriodPositionUs--;
     }
+    deliverPendingMessageAtStartPositionRequired = false;
+
     // Correct next index if necessary (e.g. after seeking, timeline changes, or new messages)
     int currentPeriodIndex =
         playbackInfo.timeline.getIndexOfPeriod(playbackInfo.periodId.periodUid);
@@ -1334,11 +1172,8 @@ import java.util.concurrent.atomic.AtomicBoolean;
       if (playbackInfo.playbackState != Player.STATE_ENDED
           && periodPositionUs != playbackInfo.positionUs) {
         playbackInfo =
-            playbackInfo.copyWithNewPosition(
-                playbackInfo.periodId,
-                periodPositionUs,
-                playbackInfo.contentPositionUs,
-                getTotalBufferedDurationUs());
+            copyWithNewPosition(
+                playbackInfo.periodId, periodPositionUs, playbackInfo.contentPositionUs);
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
         resetRendererPosition(periodPositionUs);
       }
@@ -1449,11 +1284,20 @@ import java.util.concurrent.atomic.AtomicBoolean;
         }
       }
     }
-    playlist.maybeThrowSourceInfoRefreshError();
+    mediaSource.maybeThrowSourceInfoRefreshError();
   }
 
-  private void handlePlaylistInfoRefreshed(Timeline timeline) throws ExoPlaybackException {
+  private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
+      throws ExoPlaybackException {
+    if (sourceRefreshInfo.source != mediaSource) {
+      // Stale event.
+      return;
+    }
+    playbackInfoUpdate.incrementPendingOperationAcks(pendingPrepareCount);
+    pendingPrepareCount = 0;
+
     Timeline oldTimeline = playbackInfo.timeline;
+    Timeline timeline = sourceRefreshInfo.timeline;
     queue.setTimeline(timeline);
     playbackInfo = playbackInfo.copyWithTimeline(timeline);
     resolvePendingMessagePositions();
@@ -1464,7 +1308,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
     long newContentPositionUs = oldContentPositionUs;
     if (pendingInitialSeekPosition != null) {
       // Resolve initial seek position.
-      @Nullable
       Pair<Object, Long> periodPosition =
           resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
       pendingInitialSeekPosition = null;
@@ -1533,9 +1376,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
       // Actually do the seek.
       long newPositionUs = newPeriodId.isAd() ? 0 : newContentPositionUs;
       long seekedToPositionUs = seekToPeriodPosition(newPeriodId, newPositionUs);
-      playbackInfo =
-          playbackInfo.copyWithNewPosition(
-              newPeriodId, seekedToPositionUs, newContentPositionUs, getTotalBufferedDurationUs());
+      playbackInfo = copyWithNewPosition(newPeriodId, seekedToPositionUs, newContentPositionUs);
     }
     handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
   }
@@ -1569,12 +1410,12 @@ import java.util.concurrent.atomic.AtomicBoolean;
     if (playbackInfo.playbackState != Player.STATE_IDLE) {
       setState(Player.STATE_ENDED);
     }
-    // Reset, but retain the playlist so that it can still be used should a seek occur.
+    // Reset, but retain the source so that it can still be used should a seek occur.
     resetInternal(
         /* resetRenderers= */ false,
+        /* releaseMediaSource= */ false,
         /* resetPosition= */ true,
-        /* releasePlaylist= */ false,
-        /* clearPlaylist= */ false,
+        /* resetState= */ false,
         /* resetError= */ true);
   }
 
@@ -1653,11 +1494,12 @@ import java.util.concurrent.atomic.AtomicBoolean;
     }
     if (trySubsequentPeriods) {
       // Try and find a subsequent period from the seek timeline in the internal timeline.
+      @Nullable
       Object periodUid = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
       if (periodUid != null) {
-        // We found one. Map the SeekPosition onto the corresponding default position.
+        // We found one. Use the default position of the corresponding window.
         return getPeriodPosition(
-            timeline, timeline.getPeriod(periodIndex, period).windowIndex, C.TIME_UNSET);
+            timeline, timeline.getPeriodByUid(periodUid, period).windowIndex, C.TIME_UNSET);
       }
     }
     // We didn't find one. Give up.
@@ -1674,9 +1516,13 @@ import java.util.concurrent.atomic.AtomicBoolean;
   }
 
   private void updatePeriods() throws ExoPlaybackException, IOException {
-    if (playbackInfo.timeline.isEmpty() || !playlist.isPrepared()) {
+    if (mediaSource == null) {
+      // The player has no media source yet.
+      return;
+    }
+    if (pendingPrepareCount > 0) {
       // We're waiting to get information about periods.
-      playlist.maybeThrowSourceInfoRefreshError();
+      mediaSource.maybeThrowSourceInfoRefreshError();
       return;
     }
     maybeUpdateLoadingPeriod();
@@ -1696,27 +1542,26 @@ import java.util.concurrent.atomic.AtomicBoolean;
                 rendererCapabilities,
                 trackSelector,
                 loadControl.getAllocator(),
-                playlist,
+                mediaSource,
                 info,
                 emptyTrackSelectorResult);
         mediaPeriodHolder.mediaPeriod.prepare(this, info.startPositionUs);
-        setIsLoading(true);
         if (queue.getPlayingPeriod() == mediaPeriodHolder) {
           resetRendererPosition(mediaPeriodHolder.getStartPositionRendererTime());
         }
         handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
       }
     }
-    @Nullable MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    if (loadingPeriodHolder == null || loadingPeriodHolder.isFullyBuffered()) {
-      setIsLoading(false);
-    } else if (!playbackInfo.isLoading) {
+    if (shouldContinueLoading) {
+      shouldContinueLoading = isLoadingPossible();
+      updateIsLoading();
+    } else {
       maybeContinueLoading();
     }
   }
 
   private void maybeUpdateReadingPeriod() throws ExoPlaybackException {
-    @Nullable MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
+    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     if (readingPeriodHolder == null) {
       return;
     }
@@ -1809,11 +1654,10 @@ import java.util.concurrent.atomic.AtomicBoolean;
       MediaPeriodHolder newPlayingPeriodHolder = queue.advancePlayingPeriod();
       updatePlayingPeriodRenderers(oldPlayingPeriodHolder);
       playbackInfo =
-          playbackInfo.copyWithNewPosition(
+          copyWithNewPosition(
               newPlayingPeriodHolder.info.id,
               newPlayingPeriodHolder.info.startPositionUs,
-              newPlayingPeriodHolder.info.contentPositionUs,
-              getTotalBufferedDurationUs());
+              newPlayingPeriodHolder.info.contentPositionUs);
       int discontinuityReason =
           oldPlayingPeriodHolder.info.isLastInTimelinePeriod
               ? Player.DISCONTINUITY_REASON_PERIOD_TRANSITION
@@ -1911,23 +1755,51 @@ import java.util.concurrent.atomic.AtomicBoolean;
   }
 
   private void maybeContinueLoading() {
+    shouldContinueLoading = shouldContinueLoading();
+    if (shouldContinueLoading) {
+      queue.getLoadingPeriod().continueLoading(rendererPositionUs);
+    }
+    updateIsLoading();
+  }
+
+  private boolean shouldContinueLoading() {
+    if (!isLoadingPossible()) {
+      return false;
+    }
+    long bufferedDurationUs =
+        getTotalBufferedDurationUs(queue.getLoadingPeriod().getNextLoadPositionUs());
+    float playbackSpeed = mediaClock.getPlaybackParameters().speed;
+    return loadControl.shouldContinueLoading(bufferedDurationUs, playbackSpeed);
+  }
+
+  private boolean isLoadingPossible() {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    if (loadingPeriodHolder == null) {
+      return false;
+    }
     long nextLoadPositionUs = loadingPeriodHolder.getNextLoadPositionUs();
     if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
-      setIsLoading(false);
-      return;
+      return false;
     }
-    long bufferedDurationUs =
-        getTotalBufferedDurationUs(/* bufferedPositionInLoadingPeriodUs= */ nextLoadPositionUs);
-    boolean continueLoading =
-        loadControl.shouldContinueLoading(
-            bufferedDurationUs, mediaClock.getPlaybackParameters().speed);
-    setIsLoading(continueLoading);
-    if (continueLoading) {
-      loadingPeriodHolder.continueLoading(rendererPositionUs);
+    return true;
+  }
+
+  private void updateIsLoading() {
+    MediaPeriodHolder loadingPeriod = queue.getLoadingPeriod();
+    boolean isLoading =
+        shouldContinueLoading || (loadingPeriod != null && loadingPeriod.mediaPeriod.isLoading());
+    if (isLoading != playbackInfo.isLoading) {
+      playbackInfo = playbackInfo.copyWithIsLoading(isLoading);
     }
   }
 
+  private PlaybackInfo copyWithNewPosition(
+      MediaPeriodId mediaPeriodId, long positionUs, long contentPositionUs) {
+    deliverPendingMessageAtStartPositionRequired = true;
+    return playbackInfo.copyWithNewPosition(
+        mediaPeriodId, positionUs, contentPositionUs, getTotalBufferedDurationUs());
+  }
+
   @SuppressWarnings("ParameterNotNullable")
   private void updatePlayingPeriodRenderers(@Nullable MediaPeriodHolder oldPlayingPeriodHolder)
       throws ExoPlaybackException {
@@ -2107,7 +1979,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
     }
 
     @Override
-    public int compareTo(@NonNull PendingMessageInfo other) {
+    public int compareTo(PendingMessageInfo other) {
       if ((resolvedPeriodUid == null) != (other.resolvedPeriodUid == null)) {
         // PendingMessageInfos with a resolved period position are always smaller.
         return resolvedPeriodUid != null ? -1 : 1;
@@ -2125,38 +1997,14 @@ import java.util.concurrent.atomic.AtomicBoolean;
     }
   }
 
-  private static final class PlaylistUpdateMessage {
-
-    private final List<Playlist.MediaSourceHolder> mediaSourceHolders;
-    private final ShuffleOrder shuffleOrder;
-    private final int windowIndex;
-    private final long positionUs;
+  private static final class MediaSourceRefreshInfo {
 
-    private PlaylistUpdateMessage(
-        List<Playlist.MediaSourceHolder> mediaSourceHolders,
-        ShuffleOrder shuffleOrder,
-        int windowIndex,
-        long positionUs) {
-      this.mediaSourceHolders = mediaSourceHolders;
-      this.shuffleOrder = shuffleOrder;
-      this.windowIndex = windowIndex;
-      this.positionUs = positionUs;
-    }
-  }
-
-  private static class MoveMediaItemsMessage {
-
-    public final int fromIndex;
-    public final int toIndex;
-    public final int newFromIndex;
-    public final ShuffleOrder shuffleOrder;
+    public final MediaSource source;
+    public final Timeline timeline;
 
-    public MoveMediaItemsMessage(
-        int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {
-      this.fromIndex = fromIndex;
-      this.toIndex = toIndex;
-      this.newFromIndex = newFromIndex;
-      this.shuffleOrder = shuffleOrder;
+    public MediaSourceRefreshInfo(MediaSource source, Timeline timeline) {
+      this.source = source;
+      this.timeline = timeline;
     }
   }
 
@@ -2165,7 +2013,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
     private PlaybackInfo lastPlaybackInfo;
     private int operationAcks;
     private boolean positionDiscontinuity;
-    @DiscontinuityReason private int discontinuityReason;
+    private @DiscontinuityReason int discontinuityReason;
 
     public boolean hasPendingUpdate(PlaybackInfo playbackInfo) {
       return playbackInfo != lastPlaybackInfo || operationAcks > 0 || positionDiscontinuity;
@@ -2193,4 +2041,5 @@ import java.util.concurrent.atomic.AtomicBoolean;
       this.discontinuityReason = discontinuityReason;
     }
   }
+
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index bf64a14..217f580 100644
--- a/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@ public final class ExoPlayerLibraryInfo {
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.10.5";
+  public static final String VERSION = "2.11.1";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.5";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.11.1";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@ public final class ExoPlayerLibraryInfo {
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2010005;
+  public static final int VERSION_INT = 2011001;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/core/src/main/java/com/google/android/exoplayer2/Format.java b/core/src/main/java/com/google/android/exoplayer2/Format.java
index 3753984..4fb6cec 100644
--- a/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -187,8 +187,8 @@ public final class Format implements Parcelable {
   public static Format createVideoContainerFormat(
       @Nullable String id,
       @Nullable String containerMimeType,
-      String sampleMimeType,
-      String codecs,
+      @Nullable String sampleMimeType,
+      @Nullable String codecs,
       int bitrate,
       int width,
       int height,
@@ -215,8 +215,8 @@ public final class Format implements Parcelable {
       @Nullable String id,
       @Nullable String label,
       @Nullable String containerMimeType,
-      String sampleMimeType,
-      String codecs,
+      @Nullable String sampleMimeType,
+      @Nullable String codecs,
       @Nullable Metadata metadata,
       int bitrate,
       int width,
@@ -326,7 +326,7 @@ public final class Format implements Parcelable {
       @Nullable List<byte[]> initializationData,
       int rotationDegrees,
       float pixelWidthHeightRatio,
-      byte[] projectionData,
+      @Nullable byte[] projectionData,
       @C.StereoMode int stereoMode,
       @Nullable ColorInfo colorInfo,
       @Nullable DrmInitData drmInitData) {
@@ -618,7 +618,7 @@ public final class Format implements Parcelable {
 
   public static Format createTextSampleFormat(
       @Nullable String id,
-      String sampleMimeType,
+      @Nullable String sampleMimeType,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language) {
     return createTextSampleFormat(id, sampleMimeType, selectionFlags, language, null);
@@ -626,7 +626,7 @@ public final class Format implements Parcelable {
 
   public static Format createTextSampleFormat(
       @Nullable String id,
-      String sampleMimeType,
+      @Nullable String sampleMimeType,
       @C.SelectionFlags int selectionFlags,
       @Nullable String language,
       @Nullable DrmInitData drmInitData) {
@@ -697,7 +697,7 @@ public final class Format implements Parcelable {
       int accessibilityChannel,
       @Nullable DrmInitData drmInitData,
       long subsampleOffsetUs,
-      List<byte[]> initializationData) {
+      @Nullable List<byte[]> initializationData) {
     return new Format(
         id,
         /* label= */ null,
@@ -1099,6 +1099,39 @@ public final class Format implements Parcelable {
         exoMediaCryptoType);
   }
 
+  public Format copyWithLabel(@Nullable String label) {
+    return new Format(
+        id,
+        label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
+        containerMimeType,
+        sampleMimeType,
+        maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        language,
+        accessibilityChannel,
+        exoMediaCryptoType);
+  }
+
   public Format copyWithContainerInfo(
       @Nullable String id,
       @Nullable String label,
@@ -1439,7 +1472,8 @@ public final class Format implements Parcelable {
         exoMediaCryptoType);
   }
 
-  public Format copyWithExoMediaCryptoType(Class<? extends ExoMediaCrypto> exoMediaCryptoType) {
+  public Format copyWithExoMediaCryptoType(
+      @Nullable Class<? extends ExoMediaCrypto> exoMediaCryptoType) {
     return new Format(
         id,
         label,
diff --git a/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 5bbbcbe..850d2b7 100644
--- a/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -19,6 +19,7 @@ import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.ClippingMediaPeriod;
 import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -55,7 +56,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   private final boolean[] mayRetainStreamFlags;
   private final RendererCapabilities[] rendererCapabilities;
   private final TrackSelector trackSelector;
-  private final Playlist playlist;
+  private final MediaSource mediaSource;
 
   @Nullable private MediaPeriodHolder next;
   private TrackGroupArray trackGroups;
@@ -69,7 +70,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
    * @param rendererPositionOffsetUs The renderer time of the start of the period, in microseconds.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
-   * @param playlist The playlist.
+   * @param mediaSource The media source that produced the media period.
    * @param info Information used to identify this media period in its timeline period.
    * @param emptyTrackSelectorResult A {@link TrackSelectorResult} with empty selections for each
    *     renderer.
@@ -79,13 +80,13 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       long rendererPositionOffsetUs,
       TrackSelector trackSelector,
       Allocator allocator,
-      Playlist playlist,
+      MediaSource mediaSource,
       MediaPeriodInfo info,
       TrackSelectorResult emptyTrackSelectorResult) {
     this.rendererCapabilities = rendererCapabilities;
     this.rendererPositionOffsetUs = rendererPositionOffsetUs;
     this.trackSelector = trackSelector;
-    this.playlist = playlist;
+    this.mediaSource = mediaSource;
     this.uid = info.id.periodUid;
     this.info = info;
     this.trackGroups = TrackGroupArray.EMPTY;
@@ -93,7 +94,8 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
     sampleStreams = new SampleStream[rendererCapabilities.length];
     mayRetainStreamFlags = new boolean[rendererCapabilities.length];
     mediaPeriod =
-        createMediaPeriod(info.id, playlist, allocator, info.startPositionUs, info.endPositionUs);
+        createMediaPeriod(
+            info.id, mediaSource, allocator, info.startPositionUs, info.endPositionUs);
   }
 
   /**
@@ -303,7 +305,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   /** Releases the media period. No other method should be called after the release. */
   public void release() {
     disableTrackSelectionsInResult();
-    releaseMediaPeriod(info.endPositionUs, playlist, mediaPeriod);
+    releaseMediaPeriod(info.endPositionUs, mediaSource, mediaPeriod);
   }
 
   /**
@@ -400,11 +402,11 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   /** Returns a media period corresponding to the given {@code id}. */
   private static MediaPeriod createMediaPeriod(
       MediaPeriodId id,
-      Playlist playlist,
+      MediaSource mediaSource,
       Allocator allocator,
       long startPositionUs,
       long endPositionUs) {
-    MediaPeriod mediaPeriod = playlist.createPeriod(id, allocator, startPositionUs);
+    MediaPeriod mediaPeriod = mediaSource.createPeriod(id, allocator, startPositionUs);
     if (endPositionUs != C.TIME_UNSET && endPositionUs != C.TIME_END_OF_SOURCE) {
       mediaPeriod =
           new ClippingMediaPeriod(
@@ -415,12 +417,12 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
 
   /** Releases the given {@code mediaPeriod}, logging and suppressing any errors. */
   private static void releaseMediaPeriod(
-      long endPositionUs, Playlist playlist, MediaPeriod mediaPeriod) {
+      long endPositionUs, MediaSource mediaSource, MediaPeriod mediaPeriod) {
     try {
       if (endPositionUs != C.TIME_UNSET && endPositionUs != C.TIME_END_OF_SOURCE) {
-        playlist.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+        mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
       } else {
-        playlist.releasePeriod(mediaPeriod);
+        mediaSource.releasePeriod(mediaPeriod);
       }
     } catch (RuntimeException e) {
       // There's nothing we can do.
diff --git a/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 5b39db5..901b7b4 100644
--- a/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -19,6 +19,7 @@ import android.util.Pair;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Player.RepeatMode;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
@@ -133,7 +134,7 @@ import com.google.android.exoplayer2.util.Assertions;
    * @param rendererCapabilities The renderer capabilities.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
-   * @param playlist The playlist.
+   * @param mediaSource The media source that produced the media period.
    * @param info Information used to identify this media period in its timeline period.
    * @param emptyTrackSelectorResult A {@link TrackSelectorResult} with empty selections for each
    *     renderer.
@@ -142,7 +143,7 @@ import com.google.android.exoplayer2.util.Assertions;
       RendererCapabilities[] rendererCapabilities,
       TrackSelector trackSelector,
       Allocator allocator,
-      Playlist playlist,
+      MediaSource mediaSource,
       MediaPeriodInfo info,
       TrackSelectorResult emptyTrackSelectorResult) {
     long rendererPositionOffsetUs =
@@ -157,7 +158,7 @@ import com.google.android.exoplayer2.util.Assertions;
             rendererPositionOffsetUs,
             trackSelector,
             allocator,
-            playlist,
+            mediaSource,
             info,
             emptyTrackSelectorResult);
     if (loading != null) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java b/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
index 8947365..b0f690d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
@@ -20,6 +20,7 @@ import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
 import java.io.IOException;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
  * A {@link Renderer} implementation whose track type is {@link C#TRACK_TYPE_NONE} and does not
@@ -27,10 +28,10 @@ import java.io.IOException;
  */
 public abstract class NoSampleRenderer implements Renderer, RendererCapabilities {
 
-  private RendererConfiguration configuration;
+  @MonotonicNonNull private RendererConfiguration configuration;
   private int index;
   private int state;
-  private SampleStream stream;
+  @Nullable private SampleStream stream;
   private boolean streamIsFinal;
 
   @Override
@@ -184,11 +185,13 @@ public abstract class NoSampleRenderer implements Renderer, RendererCapabilities
   // RendererCapabilities implementation.
 
   @Override
+  @Capabilities
   public int supportsFormat(Format format) throws ExoPlaybackException {
-    return FORMAT_UNSUPPORTED_TYPE;
+    return RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
   }
 
   @Override
+  @AdaptiveSupport
   public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
     return ADAPTIVE_NOT_SUPPORTED;
   }
@@ -285,8 +288,10 @@ public abstract class NoSampleRenderer implements Renderer, RendererCapabilities
   // Methods to be called by subclasses.
 
   /**
-   * Returns the configuration set when the renderer was most recently enabled.
+   * Returns the configuration set when the renderer was most recently enabled, or {@code null} if
+   * the renderer has never been enabled.
    */
+  @Nullable
   protected final RendererConfiguration getConfiguration() {
     return configuration;
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/Player.java b/core/src/main/java/com/google/android/exoplayer2/Player.java
index b9ab69c..a29851f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -31,6 +31,7 @@ import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
@@ -216,7 +217,7 @@ public interface Player {
      *
      * @param surface The surface to clear.
      */
-    void clearVideoSurface(Surface surface);
+    void clearVideoSurface(@Nullable Surface surface);
 
     /**
      * Sets the {@link Surface} onto which video will be rendered. The caller is responsible for
@@ -239,7 +240,7 @@ public interface Player {
      *
      * @param surfaceHolder The surface holder.
      */
-    void setVideoSurfaceHolder(SurfaceHolder surfaceHolder);
+    void setVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder);
 
     /**
      * Clears the {@link SurfaceHolder} that holds the {@link Surface} onto which video is being
@@ -247,7 +248,7 @@ public interface Player {
      *
      * @param surfaceHolder The surface holder to clear.
      */
-    void clearVideoSurfaceHolder(SurfaceHolder surfaceHolder);
+    void clearVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder);
 
     /**
      * Sets the {@link SurfaceView} onto which video will be rendered. The player will track the
@@ -255,7 +256,7 @@ public interface Player {
      *
      * @param surfaceView The surface view.
      */
-    void setVideoSurfaceView(SurfaceView surfaceView);
+    void setVideoSurfaceView(@Nullable SurfaceView surfaceView);
 
     /**
      * Clears the {@link SurfaceView} onto which video is being rendered if it matches the one
@@ -263,7 +264,7 @@ public interface Player {
      *
      * @param surfaceView The texture view to clear.
      */
-    void clearVideoSurfaceView(SurfaceView surfaceView);
+    void clearVideoSurfaceView(@Nullable SurfaceView surfaceView);
 
     /**
      * Sets the {@link TextureView} onto which video will be rendered. The player will track the
@@ -271,7 +272,7 @@ public interface Player {
      *
      * @param textureView The texture view.
      */
-    void setVideoTextureView(TextureView textureView);
+    void setVideoTextureView(@Nullable TextureView textureView);
 
     /**
      * Clears the {@link TextureView} onto which video is being rendered if it matches the one
@@ -279,7 +280,31 @@ public interface Player {
      *
      * @param textureView The texture view to clear.
      */
-    void clearVideoTextureView(TextureView textureView);
+    void clearVideoTextureView(@Nullable TextureView textureView);
+
+    /**
+     * Sets the video decoder output buffer renderer. This is intended for use only with extension
+     * renderers that accept {@link C#MSG_SET_VIDEO_DECODER_OUTPUT_BUFFER_RENDERER}. For most use
+     * cases, an output surface or view should be passed via {@link #setVideoSurface(Surface)} or
+     * {@link #setVideoSurfaceView(SurfaceView)} instead.
+     *
+     * @param videoDecoderOutputBufferRenderer The video decoder output buffer renderer, or {@code
+     *     null} to clear the output buffer renderer.
+     */
+    void setVideoDecoderOutputBufferRenderer(
+        @Nullable VideoDecoderOutputBufferRenderer videoDecoderOutputBufferRenderer);
+
+    /** Clears the video decoder output buffer renderer. */
+    void clearVideoDecoderOutputBufferRenderer();
+
+    /**
+     * Clears the video decoder output buffer renderer if it matches the one passed. Else does
+     * nothing.
+     *
+     * @param videoDecoderOutputBufferRenderer The video decoder output buffer renderer to clear.
+     */
+    void clearVideoDecoderOutputBufferRenderer(
+        @Nullable VideoDecoderOutputBufferRenderer videoDecoderOutputBufferRenderer);
   }
 
   /** The text component of a {@link Player}. */
@@ -356,8 +381,7 @@ public interface Player {
      * {@link #onPositionDiscontinuity(int)}.
      *
      * @param timeline The latest timeline. Never null, but may be empty.
-     * @param manifest The latest manifest in case the timeline has a single window only. Always
-     *     null if the timeline has more than a single window.
+     * @param manifest The latest manifest. May be null.
      * @param reason The {@link TimelineChangeReason} responsible for this timeline change.
      * @deprecated Use {@link #onTimelineChanged(Timeline, int)} instead. The manifest can be
      *     accessed by using {@link #getCurrentManifest()} or {@code timeline.getWindow(windowIndex,
@@ -394,6 +418,14 @@ public interface Player {
     default void onPlayerStateChanged(boolean playWhenReady, @State int playbackState) {}
 
     /**
+     * Called when the value returned from {@link #getPlaybackSuppressionReason()} changes.
+     *
+     * @param playbackSuppressionReason The current {@link PlaybackSuppressionReason}.
+     */
+    default void onPlaybackSuppressionReasonChanged(
+        @PlaybackSuppressionReason int playbackSuppressionReason) {}
+
+    /**
      * Called when the value of {@link #isPlaying()} changes.
      *
      * @param isPlaying Whether the player is playing.
@@ -463,7 +495,6 @@ public interface Player {
   abstract class DefaultEventListener implements EventListener {
 
     @Override
-    @SuppressWarnings("deprecation")
     public void onTimelineChanged(Timeline timeline, @TimelineChangeReason int reason) {
       Object manifest = null;
       if (timeline.getWindowCount() == 1) {
@@ -518,18 +549,21 @@ public interface Player {
   int STATE_ENDED = 4;
 
   /**
-   * Reason why playback is suppressed even if {@link #getPlaybackState()} is {@link #STATE_READY}
-   * and {@link #getPlayWhenReady()} is {@code true}. One of {@link
-   * #PLAYBACK_SUPPRESSION_REASON_NONE} or {@link #PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS}.
+   * Reason why playback is suppressed even though {@link #getPlayWhenReady()} is {@code true}. One
+   * of {@link #PLAYBACK_SUPPRESSION_REASON_NONE} or {@link
+   * #PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({PLAYBACK_SUPPRESSION_REASON_NONE, PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS})
+  @IntDef({
+    PLAYBACK_SUPPRESSION_REASON_NONE,
+    PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS
+  })
   @interface PlaybackSuppressionReason {}
   /** Playback is not suppressed. */
   int PLAYBACK_SUPPRESSION_REASON_NONE = 0;
-  /** Playback is suppressed because audio focus is lost or can't be acquired. */
-  int PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS = 1;
+  /** Playback is suppressed due to transient audio focus loss. */
+  int PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS = 1;
 
   /**
    * Repeat modes for playback. One of {@link #REPEAT_MODE_OFF}, {@link #REPEAT_MODE_ONE} or {@link
@@ -585,17 +619,25 @@ public interface Player {
   int DISCONTINUITY_REASON_INTERNAL = 4;
 
   /**
-   * Reasons for timeline changes. One of {@link #TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED} or {@link
-   * #TIMELINE_CHANGE_REASON_SOURCE_UPDATE}.
+   * Reasons for timeline changes. One of {@link #TIMELINE_CHANGE_REASON_PREPARED}, {@link
+   * #TIMELINE_CHANGE_REASON_RESET} or {@link #TIMELINE_CHANGE_REASON_DYNAMIC}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED, TIMELINE_CHANGE_REASON_SOURCE_UPDATE})
+  @IntDef({
+    TIMELINE_CHANGE_REASON_PREPARED,
+    TIMELINE_CHANGE_REASON_RESET,
+    TIMELINE_CHANGE_REASON_DYNAMIC
+  })
   @interface TimelineChangeReason {}
-  /** Timeline changed as a result of a change of the playlist items or the order of the items. */
-  int TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED = 0;
-  /** Timeline changed as a result of a dynamic update introduced by the played media. */
-  int TIMELINE_CHANGE_REASON_SOURCE_UPDATE = 1;
+  /** Timeline and manifest changed as a result of a player initialization with new media. */
+  int TIMELINE_CHANGE_REASON_PREPARED = 0;
+  /** Timeline and manifest changed as a result of a player reset. */
+  int TIMELINE_CHANGE_REASON_RESET = 1;
+  /**
+   * Timeline or manifest changed as a result of an dynamic update introduced by the played media.
+   */
+  int TIMELINE_CHANGE_REASON_DYNAMIC = 2;
 
   /** Returns the component of this player for audio output, or null if audio is not supported. */
   @Nullable
@@ -646,13 +688,10 @@ public interface Player {
   int getPlaybackState();
 
   /**
-   * Returns reason why playback is suppressed even if {@link #getPlaybackState()} is {@link
-   * #STATE_READY} and {@link #getPlayWhenReady()} is {@code true}.
-   *
-   * <p>Note that {@link #PLAYBACK_SUPPRESSION_REASON_NONE} indicates that playback is not
-   * suppressed.
+   * Returns the reason why playback is suppressed even though {@link #getPlayWhenReady()} is {@code
+   * true}, or {@link #PLAYBACK_SUPPRESSION_REASON_NONE} if playback is not suppressed.
    *
-   * @return The current {@link PlaybackSuppressionReason}.
+   * @return The current {@link PlaybackSuppressionReason playback suppression reason}.
    */
   @PlaybackSuppressionReason
   int getPlaybackSuppressionReason();
@@ -706,7 +745,7 @@ public interface Player {
   /**
    * Sets the {@link RepeatMode} to be used for playback.
    *
-   * @param repeatMode A repeat mode.
+   * @param repeatMode The repeat mode.
    */
   void setRepeatMode(@RepeatMode int repeatMode);
 
@@ -947,6 +986,13 @@ public interface Player {
   boolean isCurrentWindowDynamic();
 
   /**
+   * Returns whether the current window is live, or {@code false} if the {@link Timeline} is empty.
+   *
+   * @see Timeline.Window#isLive
+   */
+  boolean isCurrentWindowLive();
+
+  /**
    * Returns whether the current window is seekable, or {@code false} if the {@link Timeline} is
    * empty.
    *
diff --git a/core/src/main/java/com/google/android/exoplayer2/Playlist.java b/core/src/main/java/com/google/android/exoplayer2/Playlist.java
deleted file mode 100644
index c5476a1..0000000
--- a/core/src/main/java/com/google/android/exoplayer2/Playlist.java
+++ /dev/null
@@ -1,708 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2;
-
-import android.os.Handler;
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.analytics.AnalyticsCollector;
-import com.google.android.exoplayer2.source.MaskingMediaPeriod;
-import com.google.android.exoplayer2.source.MaskingMediaSource;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSourceEventListener;
-import com.google.android.exoplayer2.source.ShuffleOrder;
-import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
-import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.upstream.TransferListener;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Concatenates multiple {@link MediaSource}s. The list of {@link MediaSource}s can be modified
- * during playback. It is valid for the same {@link MediaSource} instance to be present more than
- * once in the playlist.
- *
- * <p>With the exception of the constructor, all methods are called on the playback thread.
- */
-/* package */ class Playlist {
-
-  /** Listener for source events. */
-  public interface PlaylistInfoRefreshListener {
-
-    /**
-     * Called when the timeline of a media item has changed and a new timeline that reflects the
-     * current playlist state needs to be created by calling {@link #createTimeline()}.
-     *
-     * <p>Called on the playback thread.
-     */
-    void onPlaylistUpdateRequested();
-  }
-
-  private final List<MediaSourceHolder> mediaSourceHolders;
-  private final Map<MediaPeriod, MediaSourceHolder> mediaSourceByMediaPeriod;
-  private final Map<Object, MediaSourceHolder> mediaSourceByUid;
-  private final PlaylistInfoRefreshListener playlistInfoListener;
-  private final MediaSourceEventListener.EventDispatcher eventDispatcher;
-  private final HashMap<Playlist.MediaSourceHolder, MediaSourceAndListener> childSources;
-  private final Set<MediaSourceHolder> enabledMediaSourceHolders;
-
-  private ShuffleOrder shuffleOrder;
-  private boolean isPrepared;
-
-  @Nullable private TransferListener mediaTransferListener;
-
-  @SuppressWarnings("initialization")
-  public Playlist(PlaylistInfoRefreshListener listener) {
-    playlistInfoListener = listener;
-    shuffleOrder = new DefaultShuffleOrder(0);
-    mediaSourceByMediaPeriod = new IdentityHashMap<>();
-    mediaSourceByUid = new HashMap<>();
-    mediaSourceHolders = new ArrayList<>();
-    eventDispatcher = new MediaSourceEventListener.EventDispatcher();
-    childSources = new HashMap<>();
-    enabledMediaSourceHolders = new HashSet<>();
-  }
-
-  /**
-   * Sets the media sources replacing any sources previously contained in the playlist.
-   *
-   * @param holders The list of {@link MediaSourceHolder}s to set.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   */
-  public final Timeline setMediaSources(
-      List<MediaSourceHolder> holders, ShuffleOrder shuffleOrder) {
-    removeMediaSourcesInternal(/* fromIndex= */ 0, /* toIndex= */ mediaSourceHolders.size());
-    return addMediaSources(/* index= */ this.mediaSourceHolders.size(), holders, shuffleOrder);
-  }
-
-  /**
-   * Adds multiple {@link MediaSourceHolder}s to the playlist.
-   *
-   * @param index The index at which the new {@link MediaSourceHolder}s will be inserted. This index
-   *     must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param holders A list of {@link MediaSourceHolder}s to be added.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   */
-  public final Timeline addMediaSources(
-      int index, List<MediaSourceHolder> holders, ShuffleOrder shuffleOrder) {
-    if (!holders.isEmpty()) {
-      this.shuffleOrder = shuffleOrder;
-      for (int insertionIndex = index; insertionIndex < index + holders.size(); insertionIndex++) {
-        MediaSourceHolder holder = holders.get(insertionIndex - index);
-        if (insertionIndex > 0) {
-          MediaSourceHolder previousHolder = mediaSourceHolders.get(insertionIndex - 1);
-          Timeline previousTimeline = previousHolder.mediaSource.getTimeline();
-          holder.reset(
-              /* firstWindowInChildIndex= */ previousHolder.firstWindowIndexInChild
-                  + previousTimeline.getWindowCount());
-        } else {
-          holder.reset(/* firstWindowIndexInChild= */ 0);
-        }
-        Timeline newTimeline = holder.mediaSource.getTimeline();
-        correctOffsets(
-            /* startIndex= */ insertionIndex,
-            /* windowOffsetUpdate= */ newTimeline.getWindowCount());
-        mediaSourceHolders.add(insertionIndex, holder);
-        mediaSourceByUid.put(holder.uid, holder);
-        if (isPrepared) {
-          prepareChildSource(holder);
-          if (mediaSourceByMediaPeriod.isEmpty()) {
-            enabledMediaSourceHolders.add(holder);
-          } else {
-            disableChildSource(holder);
-          }
-        }
-      }
-    }
-    return createTimeline();
-  }
-
-  /**
-   * Removes a range of {@link MediaSourceHolder}s from the playlist, by specifying an initial index
-   * (included) and a final index (excluded).
-   *
-   * <p>Note: when specified range is empty, no actual media source is removed and no exception is
-   * thrown.
-   *
-   * @param fromIndex The initial range index, pointing to the first media source that will be
-   *     removed. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param toIndex The final range index, pointing to the first media source that will be left
-   *     untouched. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
-   *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
-   */
-  public final Timeline removeMediaSourceRange(
-      int fromIndex, int toIndex, ShuffleOrder shuffleOrder) {
-    Assertions.checkArgument(fromIndex >= 0 && fromIndex <= toIndex && toIndex <= getSize());
-    this.shuffleOrder = shuffleOrder;
-    removeMediaSourcesInternal(fromIndex, toIndex);
-    return createTimeline();
-  }
-
-  /**
-   * Moves an existing media source within the playlist.
-   *
-   * @param currentIndex The current index of the media source in the playlist. This index must be
-   *     in the range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param newIndex The target index of the media source in the playlist. This index must be in the
-   *     range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   * @throws IllegalArgumentException When an index is invalid, i.e. {@code currentIndex} &lt; 0,
-   *     {@code currentIndex} &gt;= {@link #getSize()}, {@code newIndex} &lt; 0
-   */
-  public final Timeline moveMediaSource(int currentIndex, int newIndex, ShuffleOrder shuffleOrder) {
-    return moveMediaSourceRange(currentIndex, currentIndex + 1, newIndex, shuffleOrder);
-  }
-
-  /**
-   * Moves a range of media sources within the playlist.
-   *
-   * <p>Note: when specified range is empty or the from index equals the new from index, no actual
-   * media source is moved and no exception is thrown.
-   *
-   * @param fromIndex The initial range index, pointing to the first media source of the range that
-   *     will be moved. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param toIndex The final range index, pointing to the first media source that will be left
-   *     untouched. This index must be larger or equals than {@code fromIndex}.
-   * @param newFromIndex The target index of the first media source of the range that will be moved.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
-   *     {@code toIndex} &lt; {@code fromIndex}, {@code fromIndex} &gt; {@code toIndex}, {@code
-   *     newFromIndex} &lt; 0
-   */
-  public Timeline moveMediaSourceRange(
-      int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {
-    Assertions.checkArgument(
-        fromIndex >= 0 && fromIndex <= toIndex && toIndex <= getSize() && newFromIndex >= 0);
-    this.shuffleOrder = shuffleOrder;
-    if (fromIndex == toIndex || fromIndex == newFromIndex) {
-      return createTimeline();
-    }
-    int startIndex = Math.min(fromIndex, newFromIndex);
-    int newEndIndex = newFromIndex + (toIndex - fromIndex) - 1;
-    int endIndex = Math.max(newEndIndex, toIndex - 1);
-    int windowOffset = mediaSourceHolders.get(startIndex).firstWindowIndexInChild;
-    moveMediaSourceHolders(mediaSourceHolders, fromIndex, toIndex, newFromIndex);
-    for (int i = startIndex; i <= endIndex; i++) {
-      MediaSourceHolder holder = mediaSourceHolders.get(i);
-      holder.firstWindowIndexInChild = windowOffset;
-      windowOffset += holder.mediaSource.getTimeline().getWindowCount();
-    }
-    return createTimeline();
-  }
-
-  /** Clears the playlist. */
-  public final Timeline clear(@Nullable ShuffleOrder shuffleOrder) {
-    this.shuffleOrder = shuffleOrder != null ? shuffleOrder : this.shuffleOrder.cloneAndClear();
-    removeMediaSourcesInternal(/* fromIndex= */ 0, /* toIndex= */ getSize());
-    return createTimeline();
-  }
-
-  /** Whether the playlist is prepared. */
-  public final boolean isPrepared() {
-    return isPrepared;
-  }
-
-  /** Returns the number of media sources in the playlist. */
-  public final int getSize() {
-    return mediaSourceHolders.size();
-  }
-
-  /**
-   * Sets the {@link AnalyticsCollector}.
-   *
-   * @param handler The handler on which to call the collector.
-   * @param analyticsCollector The analytics collector.
-   */
-  public final void setAnalyticsCollector(Handler handler, AnalyticsCollector analyticsCollector) {
-    eventDispatcher.addEventListener(handler, analyticsCollector);
-  }
-
-  /**
-   * Sets a new shuffle order to use when shuffling the child media sources.
-   *
-   * @param shuffleOrder A {@link ShuffleOrder}.
-   */
-  public final Timeline setShuffleOrder(ShuffleOrder shuffleOrder) {
-    int size = getSize();
-    if (shuffleOrder.getLength() != size) {
-      shuffleOrder =
-          shuffleOrder
-              .cloneAndClear()
-              .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
-    }
-    this.shuffleOrder = shuffleOrder;
-    return createTimeline();
-  }
-
-  /** Prepares the playlist. */
-  public final void prepare(@Nullable TransferListener mediaTransferListener) {
-    Assertions.checkState(!isPrepared);
-    this.mediaTransferListener = mediaTransferListener;
-    for (int i = 0; i < mediaSourceHolders.size(); i++) {
-      MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);
-      prepareChildSource(mediaSourceHolder);
-      enabledMediaSourceHolders.add(mediaSourceHolder);
-    }
-    isPrepared = true;
-  }
-
-  /**
-   * Returns a new {@link MediaPeriod} identified by {@code periodId}.
-   *
-   * @param id The identifier of the period.
-   * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
-   * @param startPositionUs The expected start position, in microseconds.
-   * @return A new {@link MediaPeriod}.
-   */
-  public MediaPeriod createPeriod(
-      MediaSource.MediaPeriodId id, Allocator allocator, long startPositionUs) {
-    Object mediaSourceHolderUid = getMediaSourceHolderUid(id.periodUid);
-    MediaSource.MediaPeriodId childMediaPeriodId =
-        id.copyWithPeriodUid(getChildPeriodUid(id.periodUid));
-    MediaSourceHolder holder = Assertions.checkNotNull(mediaSourceByUid.get(mediaSourceHolderUid));
-    enableMediaSource(holder);
-    holder.activeMediaPeriodIds.add(childMediaPeriodId);
-    MediaPeriod mediaPeriod =
-        holder.mediaSource.createPeriod(childMediaPeriodId, allocator, startPositionUs);
-    mediaSourceByMediaPeriod.put(mediaPeriod, holder);
-    disableUnusedMediaSources();
-    return mediaPeriod;
-  }
-
-  /**
-   * Releases the period.
-   *
-   * @param mediaPeriod The period to release.
-   */
-  public final void releasePeriod(MediaPeriod mediaPeriod) {
-    MediaSourceHolder holder =
-        Assertions.checkNotNull(mediaSourceByMediaPeriod.remove(mediaPeriod));
-    holder.mediaSource.releasePeriod(mediaPeriod);
-    holder.activeMediaPeriodIds.remove(((MaskingMediaPeriod) mediaPeriod).id);
-    if (!mediaSourceByMediaPeriod.isEmpty()) {
-      disableUnusedMediaSources();
-    }
-    maybeReleaseChildSource(holder);
-  }
-
-  /** Releases the playlist. */
-  public final void release() {
-    for (MediaSourceAndListener childSource : childSources.values()) {
-      childSource.mediaSource.releaseSource(childSource.caller);
-      childSource.mediaSource.removeEventListener(childSource.eventListener);
-    }
-    childSources.clear();
-    enabledMediaSourceHolders.clear();
-    isPrepared = false;
-  }
-
-  /** Throws any pending error encountered while loading or refreshing. */
-  public final void maybeThrowSourceInfoRefreshError() throws IOException {
-    for (MediaSourceAndListener childSource : childSources.values()) {
-      childSource.mediaSource.maybeThrowSourceInfoRefreshError();
-    }
-  }
-
-  /** Creates a timeline reflecting the current state of the playlist. */
-  public final Timeline createTimeline() {
-    if (mediaSourceHolders.isEmpty()) {
-      return Timeline.EMPTY;
-    }
-    int windowOffset = 0;
-    for (int i = 0; i < mediaSourceHolders.size(); i++) {
-      MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);
-      mediaSourceHolder.firstWindowIndexInChild = windowOffset;
-      windowOffset += mediaSourceHolder.mediaSource.getTimeline().getWindowCount();
-    }
-    return new PlaylistTimeline(mediaSourceHolders, shuffleOrder);
-  }
-
-  // Internal methods.
-
-  private void enableMediaSource(MediaSourceHolder mediaSourceHolder) {
-    enabledMediaSourceHolders.add(mediaSourceHolder);
-    @Nullable MediaSourceAndListener enabledChild = childSources.get(mediaSourceHolder);
-    if (enabledChild != null) {
-      enabledChild.mediaSource.enable(enabledChild.caller);
-    }
-  }
-
-  private void disableUnusedMediaSources() {
-    Iterator<MediaSourceHolder> iterator = enabledMediaSourceHolders.iterator();
-    while (iterator.hasNext()) {
-      MediaSourceHolder holder = iterator.next();
-      if (holder.activeMediaPeriodIds.isEmpty()) {
-        disableChildSource(holder);
-        iterator.remove();
-      }
-    }
-  }
-
-  private void disableChildSource(MediaSourceHolder holder) {
-    @Nullable MediaSourceAndListener disabledChild = childSources.get(holder);
-    if (disabledChild != null) {
-      disabledChild.mediaSource.disable(disabledChild.caller);
-    }
-  }
-
-  private void removeMediaSourcesInternal(int fromIndex, int toIndex) {
-    for (int index = toIndex - 1; index >= fromIndex; index--) {
-      MediaSourceHolder holder = mediaSourceHolders.remove(index);
-      mediaSourceByUid.remove(holder.uid);
-      Timeline oldTimeline = holder.mediaSource.getTimeline();
-      correctOffsets(
-          /* startIndex= */ index, /* windowOffsetUpdate= */ -oldTimeline.getWindowCount());
-      holder.isRemoved = true;
-      if (isPrepared) {
-        maybeReleaseChildSource(holder);
-      }
-    }
-  }
-
-  private void correctOffsets(int startIndex, int windowOffsetUpdate) {
-    for (int i = startIndex; i < mediaSourceHolders.size(); i++) {
-      MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);
-      mediaSourceHolder.firstWindowIndexInChild += windowOffsetUpdate;
-    }
-  }
-
-  // Internal methods to manage child sources.
-
-  @Nullable
-  private static MediaSource.MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(
-      MediaSourceHolder mediaSourceHolder, MediaSource.MediaPeriodId mediaPeriodId) {
-    for (int i = 0; i < mediaSourceHolder.activeMediaPeriodIds.size(); i++) {
-      // Ensure the reported media period id has the same window sequence number as the one created
-      // by this media source. Otherwise it does not belong to this child source.
-      if (mediaSourceHolder.activeMediaPeriodIds.get(i).windowSequenceNumber
-          == mediaPeriodId.windowSequenceNumber) {
-        Object periodUid = getPeriodUid(mediaSourceHolder, mediaPeriodId.periodUid);
-        return mediaPeriodId.copyWithPeriodUid(periodUid);
-      }
-    }
-    return null;
-  }
-
-  private static int getWindowIndexForChildWindowIndex(
-      MediaSourceHolder mediaSourceHolder, int windowIndex) {
-    return windowIndex + mediaSourceHolder.firstWindowIndexInChild;
-  }
-
-  private void prepareChildSource(MediaSourceHolder holder) {
-    MediaSource mediaSource = holder.mediaSource;
-    MediaSource.MediaSourceCaller caller =
-        (source, timeline) -> playlistInfoListener.onPlaylistUpdateRequested();
-    MediaSourceEventListener eventListener = new ForwardingEventListener(holder);
-    childSources.put(holder, new MediaSourceAndListener(mediaSource, caller, eventListener));
-    mediaSource.addEventListener(new Handler(), eventListener);
-    mediaSource.prepareSource(caller, mediaTransferListener);
-  }
-
-  private void maybeReleaseChildSource(MediaSourceHolder mediaSourceHolder) {
-    // Release if the source has been removed from the playlist and no periods are still active.
-    if (mediaSourceHolder.isRemoved && mediaSourceHolder.activeMediaPeriodIds.isEmpty()) {
-      MediaSourceAndListener removedChild =
-          Assertions.checkNotNull(childSources.remove(mediaSourceHolder));
-      removedChild.mediaSource.releaseSource(removedChild.caller);
-      removedChild.mediaSource.removeEventListener(removedChild.eventListener);
-      enabledMediaSourceHolders.remove(mediaSourceHolder);
-    }
-  }
-
-  /** Return uid of media source holder from period uid of concatenated source. */
-  private static Object getMediaSourceHolderUid(Object periodUid) {
-    return PlaylistTimeline.getChildTimelineUidFromConcatenatedUid(periodUid);
-  }
-
-  /** Return uid of child period from period uid of concatenated source. */
-  private static Object getChildPeriodUid(Object periodUid) {
-    return PlaylistTimeline.getChildPeriodUidFromConcatenatedUid(periodUid);
-  }
-
-  private static Object getPeriodUid(MediaSourceHolder holder, Object childPeriodUid) {
-    return PlaylistTimeline.getConcatenatedUid(holder.uid, childPeriodUid);
-  }
-
-  /* package */ static void moveMediaSourceHolders(
-      List<MediaSourceHolder> mediaSourceHolders, int fromIndex, int toIndex, int newFromIndex) {
-    MediaSourceHolder[] removedItems = new MediaSourceHolder[toIndex - fromIndex];
-    for (int i = removedItems.length - 1; i >= 0; i--) {
-      removedItems[i] = mediaSourceHolders.remove(fromIndex + i);
-    }
-    mediaSourceHolders.addAll(
-        Math.min(newFromIndex, mediaSourceHolders.size()), Arrays.asList(removedItems));
-  }
-
-  /** Data class to hold playlist media sources together with meta data needed to process them. */
-  /* package */ static final class MediaSourceHolder {
-
-    public final MaskingMediaSource mediaSource;
-    public final Object uid;
-    public final List<MediaSource.MediaPeriodId> activeMediaPeriodIds;
-
-    public int firstWindowIndexInChild;
-    public boolean isRemoved;
-
-    public MediaSourceHolder(MediaSource mediaSource, boolean useLazyPreparation) {
-      this.mediaSource = new MaskingMediaSource(mediaSource, useLazyPreparation);
-      this.activeMediaPeriodIds = new ArrayList<>();
-      this.uid = new Object();
-    }
-
-    public void reset(int firstWindowIndexInChild) {
-      this.firstWindowIndexInChild = firstWindowIndexInChild;
-      this.isRemoved = false;
-      this.activeMediaPeriodIds.clear();
-    }
-  }
-
-  /** Timeline exposing concatenated timelines of playlist media sources. */
-  /* package */ static final class PlaylistTimeline extends AbstractConcatenatedTimeline {
-
-    private final int windowCount;
-    private final int periodCount;
-    private final int[] firstPeriodInChildIndices;
-    private final int[] firstWindowInChildIndices;
-    private final Timeline[] timelines;
-    private final Object[] uids;
-    private final HashMap<Object, Integer> childIndexByUid;
-
-    public PlaylistTimeline(
-        Collection<MediaSourceHolder> mediaSourceHolders, ShuffleOrder shuffleOrder) {
-      super(/* isAtomic= */ false, shuffleOrder);
-      int childCount = mediaSourceHolders.size();
-      firstPeriodInChildIndices = new int[childCount];
-      firstWindowInChildIndices = new int[childCount];
-      timelines = new Timeline[childCount];
-      uids = new Object[childCount];
-      childIndexByUid = new HashMap<>();
-      int index = 0;
-      int windowCount = 0;
-      int periodCount = 0;
-      for (MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
-        timelines[index] = mediaSourceHolder.mediaSource.getTimeline();
-        firstWindowInChildIndices[index] = windowCount;
-        firstPeriodInChildIndices[index] = periodCount;
-        windowCount += timelines[index].getWindowCount();
-        periodCount += timelines[index].getPeriodCount();
-        uids[index] = mediaSourceHolder.uid;
-        childIndexByUid.put(uids[index], index++);
-      }
-      this.windowCount = windowCount;
-      this.periodCount = periodCount;
-    }
-
-    @Override
-    protected int getChildIndexByPeriodIndex(int periodIndex) {
-      return Util.binarySearchFloor(firstPeriodInChildIndices, periodIndex + 1, false, false);
-    }
-
-    @Override
-    protected int getChildIndexByWindowIndex(int windowIndex) {
-      return Util.binarySearchFloor(firstWindowInChildIndices, windowIndex + 1, false, false);
-    }
-
-    @Override
-    protected int getChildIndexByChildUid(Object childUid) {
-      Integer index = childIndexByUid.get(childUid);
-      return index == null ? C.INDEX_UNSET : index;
-    }
-
-    @Override
-    protected Timeline getTimelineByChildIndex(int childIndex) {
-      return timelines[childIndex];
-    }
-
-    @Override
-    protected int getFirstPeriodIndexByChildIndex(int childIndex) {
-      return firstPeriodInChildIndices[childIndex];
-    }
-
-    @Override
-    protected int getFirstWindowIndexByChildIndex(int childIndex) {
-      return firstWindowInChildIndices[childIndex];
-    }
-
-    @Override
-    protected Object getChildUidByChildIndex(int childIndex) {
-      return uids[childIndex];
-    }
-
-    @Override
-    public int getWindowCount() {
-      return windowCount;
-    }
-
-    @Override
-    public int getPeriodCount() {
-      return periodCount;
-    }
-  }
-
-  private static final class MediaSourceAndListener {
-
-    public final MediaSource mediaSource;
-    public final MediaSource.MediaSourceCaller caller;
-    public final MediaSourceEventListener eventListener;
-
-    public MediaSourceAndListener(
-        MediaSource mediaSource,
-        MediaSource.MediaSourceCaller caller,
-        MediaSourceEventListener eventListener) {
-      this.mediaSource = mediaSource;
-      this.caller = caller;
-      this.eventListener = eventListener;
-    }
-  }
-
-  private final class ForwardingEventListener implements MediaSourceEventListener {
-
-    private final Playlist.MediaSourceHolder id;
-    private EventDispatcher eventDispatcher;
-
-    public ForwardingEventListener(Playlist.MediaSourceHolder id) {
-      eventDispatcher = Playlist.this.eventDispatcher;
-      this.id = id;
-    }
-
-    @Override
-    public void onMediaPeriodCreated(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.mediaPeriodCreated();
-      }
-    }
-
-    @Override
-    public void onMediaPeriodReleased(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.mediaPeriodReleased();
-      }
-    }
-
-    @Override
-    public void onLoadStarted(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadStarted(loadEventData, mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onLoadCompleted(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadCompleted(loadEventData, mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onLoadCanceled(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadCanceled(loadEventData, mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onLoadError(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData,
-        IOException error,
-        boolean wasCanceled) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadError(loadEventData, mediaLoadData, error, wasCanceled);
-      }
-    }
-
-    @Override
-    public void onReadingStarted(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.readingStarted();
-      }
-    }
-
-    @Override
-    public void onUpstreamDiscarded(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.upstreamDiscarded(mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onDownstreamFormatChanged(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.downstreamFormatChanged(mediaLoadData);
-      }
-    }
-
-    /** Updates the event dispatcher and returns whether the event should be dispatched. */
-    private boolean maybeUpdateEventDispatcher(
-        int childWindowIndex, @Nullable MediaSource.MediaPeriodId childMediaPeriodId) {
-      @Nullable MediaSource.MediaPeriodId mediaPeriodId = null;
-      if (childMediaPeriodId != null) {
-        mediaPeriodId = getMediaPeriodIdForChildMediaPeriodId(id, childMediaPeriodId);
-        if (mediaPeriodId == null) {
-          // Media period not found. Ignore event.
-          return false;
-        }
-      }
-      int windowIndex = getWindowIndexForChildWindowIndex(id, childWindowIndex);
-      if (eventDispatcher.windowIndex != windowIndex
-          || !Util.areEqual(eventDispatcher.mediaPeriodId, mediaPeriodId)) {
-        eventDispatcher =
-            Playlist.this.eventDispatcher.withParameters(
-                windowIndex, mediaPeriodId, /* mediaTimeOffsetMs= */ 0L);
-      }
-      return true;
-    }
-  }
-}
-
diff --git a/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java b/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
index de0d481..a757652 100644
--- a/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
+++ b/core/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
@@ -15,7 +15,12 @@
  */
 package com.google.android.exoplayer2;
 
+import android.annotation.SuppressLint;
+import androidx.annotation.IntDef;
 import com.google.android.exoplayer2.util.MimeTypes;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Defines the capabilities of a {@link Renderer}.
@@ -23,10 +28,22 @@ import com.google.android.exoplayer2.util.MimeTypes;
 public interface RendererCapabilities {
 
   /**
-   * A mask to apply to the result of {@link #supportsFormat(Format)} to obtain one of
-   * {@link #FORMAT_HANDLED}, {@link #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_DRM},
-   * {@link #FORMAT_UNSUPPORTED_SUBTYPE} and {@link #FORMAT_UNSUPPORTED_TYPE}.
+   * Level of renderer support for a format. One of {@link #FORMAT_HANDLED}, {@link
+   * #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_DRM}, {@link
+   * #FORMAT_UNSUPPORTED_SUBTYPE} or {@link #FORMAT_UNSUPPORTED_TYPE}.
    */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    FORMAT_HANDLED,
+    FORMAT_EXCEEDS_CAPABILITIES,
+    FORMAT_UNSUPPORTED_DRM,
+    FORMAT_UNSUPPORTED_SUBTYPE,
+    FORMAT_UNSUPPORTED_TYPE
+  })
+  @interface FormatSupport {}
+
+  /** A mask to apply to {@link Capabilities} to obtain the {@link FormatSupport} only. */
   int FORMAT_SUPPORT_MASK = 0b111;
   /**
    * The {@link Renderer} is capable of rendering the format.
@@ -72,9 +89,15 @@ public interface RendererCapabilities {
   int FORMAT_UNSUPPORTED_TYPE = 0b000;
 
   /**
-   * A mask to apply to the result of {@link #supportsFormat(Format)} to obtain one of
-   * {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and {@link #ADAPTIVE_NOT_SUPPORTED}.
+   * Level of renderer support for adaptive format switches. One of {@link #ADAPTIVE_SEAMLESS},
+   * {@link #ADAPTIVE_NOT_SEAMLESS} or {@link #ADAPTIVE_NOT_SUPPORTED}.
    */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({ADAPTIVE_SEAMLESS, ADAPTIVE_NOT_SEAMLESS, ADAPTIVE_NOT_SUPPORTED})
+  @interface AdaptiveSupport {}
+
+  /** A mask to apply to {@link Capabilities} to obtain the {@link AdaptiveSupport} only. */
   int ADAPTIVE_SUPPORT_MASK = 0b11000;
   /**
    * The {@link Renderer} can seamlessly adapt between formats.
@@ -91,9 +114,15 @@ public interface RendererCapabilities {
   int ADAPTIVE_NOT_SUPPORTED = 0b00000;
 
   /**
-   * A mask to apply to the result of {@link #supportsFormat(Format)} to obtain one of
-   * {@link #TUNNELING_SUPPORTED} and {@link #TUNNELING_NOT_SUPPORTED}.
+   * Level of renderer support for tunneling. One of {@link #TUNNELING_SUPPORTED} or {@link
+   * #TUNNELING_NOT_SUPPORTED}.
    */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TUNNELING_SUPPORTED, TUNNELING_NOT_SUPPORTED})
+  @interface TunnelingSupport {}
+
+  /** A mask to apply to {@link Capabilities} to obtain the {@link TunnelingSupport} only. */
   int TUNNELING_SUPPORT_MASK = 0b100000;
   /**
    * The {@link Renderer} supports tunneled output.
@@ -105,6 +134,133 @@ public interface RendererCapabilities {
   int TUNNELING_NOT_SUPPORTED = 0b000000;
 
   /**
+   * Combined renderer capabilities.
+   *
+   * <p>This is a bitwise OR of {@link FormatSupport}, {@link AdaptiveSupport} and {@link
+   * TunnelingSupport}. Use {@link #getFormatSupport(int)}, {@link #getAdaptiveSupport(int)} or
+   * {@link #getTunnelingSupport(int)} to obtain the individual flags. And use {@link #create(int)}
+   * or {@link #create(int, int, int)} to create the combined capabilities.
+   *
+   * <p>Possible values:
+   *
+   * <ul>
+   *   <li>{@link FormatSupport}: The level of support for the format itself. One of {@link
+   *       #FORMAT_HANDLED}, {@link #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_DRM},
+   *       {@link #FORMAT_UNSUPPORTED_SUBTYPE} and {@link #FORMAT_UNSUPPORTED_TYPE}.
+   *   <li>{@link AdaptiveSupport}: The level of support for adapting from the format to another
+   *       format of the same mime type. One of {@link #ADAPTIVE_SEAMLESS}, {@link
+   *       #ADAPTIVE_NOT_SEAMLESS} and {@link #ADAPTIVE_NOT_SUPPORTED}. Only set if the level of
+   *       support for the format itself is {@link #FORMAT_HANDLED} or {@link
+   *       #FORMAT_EXCEEDS_CAPABILITIES}.
+   *   <li>{@link TunnelingSupport}: The level of support for tunneling. One of {@link
+   *       #TUNNELING_SUPPORTED} and {@link #TUNNELING_NOT_SUPPORTED}. Only set if the level of
+   *       support for the format itself is {@link #FORMAT_HANDLED} or {@link
+   *       #FORMAT_EXCEEDS_CAPABILITIES}.
+   * </ul>
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  // Intentionally empty to prevent assignment or comparison with individual flags without masking.
+  @IntDef({})
+  @interface Capabilities {}
+
+  /**
+   * Returns {@link Capabilities} for the given {@link FormatSupport}.
+   *
+   * <p>The {@link AdaptiveSupport} is set to {@link #ADAPTIVE_NOT_SUPPORTED} and {{@link
+   * TunnelingSupport} is set to {@link #TUNNELING_NOT_SUPPORTED}.
+   *
+   * @param formatSupport The {@link FormatSupport}.
+   * @return The combined {@link Capabilities} of the given {@link FormatSupport}, {@link
+   *     #ADAPTIVE_NOT_SUPPORTED} and {@link #TUNNELING_NOT_SUPPORTED}.
+   */
+  @Capabilities
+  static int create(@FormatSupport int formatSupport) {
+    return create(formatSupport, ADAPTIVE_NOT_SUPPORTED, TUNNELING_NOT_SUPPORTED);
+  }
+
+  /**
+   * Returns {@link Capabilities} combining the given {@link FormatSupport}, {@link AdaptiveSupport}
+   * and {@link TunnelingSupport}.
+   *
+   * @param formatSupport The {@link FormatSupport}.
+   * @param adaptiveSupport The {@link AdaptiveSupport}.
+   * @param tunnelingSupport The {@link TunnelingSupport}.
+   * @return The combined {@link Capabilities}.
+   */
+  // Suppression needed for IntDef casting.
+  @SuppressLint("WrongConstant")
+  @Capabilities
+  static int create(
+      @FormatSupport int formatSupport,
+      @AdaptiveSupport int adaptiveSupport,
+      @TunnelingSupport int tunnelingSupport) {
+    return formatSupport | adaptiveSupport | tunnelingSupport;
+  }
+
+  /**
+   * Returns the {@link FormatSupport} from the combined {@link Capabilities}.
+   *
+   * @param supportFlags The combined {@link Capabilities}.
+   * @return The {@link FormatSupport} only.
+   */
+  // Suppression needed for IntDef casting.
+  @SuppressLint("WrongConstant")
+  @FormatSupport
+  static int getFormatSupport(@Capabilities int supportFlags) {
+    return supportFlags & FORMAT_SUPPORT_MASK;
+  }
+
+  /**
+   * Returns the {@link AdaptiveSupport} from the combined {@link Capabilities}.
+   *
+   * @param supportFlags The combined {@link Capabilities}.
+   * @return The {@link AdaptiveSupport} only.
+   */
+  // Suppression needed for IntDef casting.
+  @SuppressLint("WrongConstant")
+  @AdaptiveSupport
+  static int getAdaptiveSupport(@Capabilities int supportFlags) {
+    return supportFlags & ADAPTIVE_SUPPORT_MASK;
+  }
+
+  /**
+   * Returns the {@link TunnelingSupport} from the combined {@link Capabilities}.
+   *
+   * @param supportFlags The combined {@link Capabilities}.
+   * @return The {@link TunnelingSupport} only.
+   */
+  // Suppression needed for IntDef casting.
+  @SuppressLint("WrongConstant")
+  @TunnelingSupport
+  static int getTunnelingSupport(@Capabilities int supportFlags) {
+    return supportFlags & TUNNELING_SUPPORT_MASK;
+  }
+
+  /**
+   * Returns string representation of a {@link FormatSupport} flag.
+   *
+   * @param formatSupport A {@link FormatSupport} flag.
+   * @return A string representation of the flag.
+   */
+  static String getFormatSupportString(@FormatSupport int formatSupport) {
+    switch (formatSupport) {
+      case RendererCapabilities.FORMAT_HANDLED:
+        return "YES";
+      case RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES:
+        return "NO_EXCEEDS_CAPABILITIES";
+      case RendererCapabilities.FORMAT_UNSUPPORTED_DRM:
+        return "NO_UNSUPPORTED_DRM";
+      case RendererCapabilities.FORMAT_UNSUPPORTED_SUBTYPE:
+        return "NO_UNSUPPORTED_TYPE";
+      case RendererCapabilities.FORMAT_UNSUPPORTED_TYPE:
+        return "NO";
+      default:
+        throw new IllegalStateException();
+    }
+  }
+
+  /**
    * Returns the track type that the {@link Renderer} handles. For example, a video renderer will
    * return {@link C#TRACK_TYPE_VIDEO}, an audio renderer will return {@link C#TRACK_TYPE_AUDIO}, a
    * text renderer will return {@link C#TRACK_TYPE_TEXT}, and so on.
@@ -115,39 +271,23 @@ public interface RendererCapabilities {
   int getTrackType();
 
   /**
-   * Returns the extent to which the {@link Renderer} supports a given format. The returned value is
-   * the bitwise OR of three properties:
-   * <ul>
-   * <li>The level of support for the format itself. One of {@link #FORMAT_HANDLED},
-   * {@link #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_DRM},
-   * {@link #FORMAT_UNSUPPORTED_SUBTYPE} and {@link #FORMAT_UNSUPPORTED_TYPE}.</li>
-   * <li>The level of support for adapting from the format to another format of the same mime type.
-   * One of {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and
-   * {@link #ADAPTIVE_NOT_SUPPORTED}. Only set if the level of support for the format itself is
-   * {@link #FORMAT_HANDLED} or {@link #FORMAT_EXCEEDS_CAPABILITIES}.</li>
-   * <li>The level of support for tunneling. One of {@link #TUNNELING_SUPPORTED} and
-   * {@link #TUNNELING_NOT_SUPPORTED}. Only set if the level of support for the format itself is
-   * {@link #FORMAT_HANDLED} or {@link #FORMAT_EXCEEDS_CAPABILITIES}.</li>
-   * </ul>
-   * The individual properties can be retrieved by performing a bitwise AND with
-   * {@link #FORMAT_SUPPORT_MASK}, {@link #ADAPTIVE_SUPPORT_MASK} and
-   * {@link #TUNNELING_SUPPORT_MASK} respectively.
+   * Returns the extent to which the {@link Renderer} supports a given format.
    *
    * @param format The format.
-   * @return The extent to which the renderer is capable of supporting the given format.
+   * @return The {@link Capabilities} for this format.
    * @throws ExoPlaybackException If an error occurs.
    */
+  @Capabilities
   int supportsFormat(Format format) throws ExoPlaybackException;
 
   /**
    * Returns the extent to which the {@link Renderer} supports adapting between supported formats
-   * that have different mime types.
+   * that have different MIME types.
    *
-   * @return The extent to which the renderer supports adapting between supported formats that have
-   *     different mime types. One of {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and
-   *     {@link #ADAPTIVE_NOT_SUPPORTED}.
+   * @return The {@link AdaptiveSupport} for adapting between supported formats that have different
+   *     MIME types.
    * @throws ExoPlaybackException If an error occurs.
    */
+  @AdaptiveSupport
   int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException;
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index de98023..52b6860 100644
--- a/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -32,7 +32,6 @@ import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.audio.AudioAttributes;
-import com.google.android.exoplayer2.audio.AudioFocusManager;
 import com.google.android.exoplayer2.audio.AudioListener;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.AuxEffectInfo;
@@ -43,7 +42,6 @@ import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextOutput;
@@ -57,6 +55,7 @@ import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
@@ -164,9 +163,7 @@ public class SimpleExoPlayer extends BasePlayer
      * @param bandwidthMeter A {@link BandwidthMeter}.
      * @param looper A {@link Looper} that must be used for all calls to the player.
      * @param analyticsCollector An {@link AnalyticsCollector}.
-     * @param useLazyPreparation Whether playlist items should be prepared lazily. If false, all
-     *     initial preparation steps (e.g., manifest loads) happen immediately. If true, these
-     *     initial preparations are triggered only when the player starts buffering the media.
+     * @param useLazyPreparation Whether media sources should be initialized lazily.
      * @param clock A {@link Clock}. Should always be {@link Clock#DEFAULT}.
      */
     public Builder(
@@ -303,7 +300,6 @@ public class SimpleExoPlayer extends BasePlayer
           loadControl,
           bandwidthMeter,
           analyticsCollector,
-          useLazyPreparation,
           clock,
           looper);
     }
@@ -326,11 +322,14 @@ public class SimpleExoPlayer extends BasePlayer
   private final BandwidthMeter bandwidthMeter;
   private final AnalyticsCollector analyticsCollector;
 
+  private final AudioBecomingNoisyManager audioBecomingNoisyManager;
   private final AudioFocusManager audioFocusManager;
+  private final WakeLockManager wakeLockManager;
 
   @Nullable private Format videoFormat;
   @Nullable private Format audioFormat;
 
+  @Nullable private VideoDecoderOutputBufferRenderer videoDecoderOutputBufferRenderer;
   @Nullable private Surface surface;
   private boolean ownsSurface;
   private @C.VideoScalingMode int videoScalingMode;
@@ -343,12 +342,14 @@ public class SimpleExoPlayer extends BasePlayer
   private int audioSessionId;
   private AudioAttributes audioAttributes;
   private float audioVolume;
+  @Nullable private MediaSource mediaSource;
   private List<Cue> currentCues;
   @Nullable private VideoFrameMetadataListener videoFrameMetadataListener;
   @Nullable private CameraMotionListener cameraMotionListener;
   private boolean hasNotifiedFullWrongThreadWarning;
   @Nullable private PriorityTaskManager priorityTaskManager;
   private boolean isPriorityTaskManagerRegistered;
+  private boolean playerReleased;
 
   /**
    * @param context A {@link Context}.
@@ -358,9 +359,6 @@ public class SimpleExoPlayer extends BasePlayer
    * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
    * @param analyticsCollector A factory for creating the {@link AnalyticsCollector} that will
    *     collect and forward all player events.
-   * @param useLazyPreparation Whether playlist items are prepared lazily. If false, all manifest
-   *     loads and other initial preparation steps happen immediately. If true, these initial
-   *     preparations are triggered only when the player starts buffering the media.
    * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
    *     Clock#DEFAULT}, unless the player is being used from a test.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
@@ -374,7 +372,6 @@ public class SimpleExoPlayer extends BasePlayer
       LoadControl loadControl,
       BandwidthMeter bandwidthMeter,
       AnalyticsCollector analyticsCollector,
-      boolean useLazyPreparation,
       Clock clock,
       Looper looper) {
     this(
@@ -385,14 +382,26 @@ public class SimpleExoPlayer extends BasePlayer
         DrmSessionManager.getDummyDrmSessionManager(),
         bandwidthMeter,
         analyticsCollector,
-        useLazyPreparation,
         clock,
         looper);
   }
 
   /**
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
+   * @param analyticsCollector The {@link AnalyticsCollector} that will collect and forward all
+   *     player events.
+   * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
+   *     Clock#DEFAULT}, unless the player is being used from a test.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
    * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
-   *     BandwidthMeter, AnalyticsCollector, boolean, Clock, Looper)} instead, and pass the {@link
+   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
    *     DrmSessionManager} to the {@link MediaSource} factories.
    */
   @Deprecated
@@ -404,7 +413,6 @@ public class SimpleExoPlayer extends BasePlayer
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       BandwidthMeter bandwidthMeter,
       AnalyticsCollector analyticsCollector,
-      boolean useLazyPreparation,
       Clock clock,
       Looper looper) {
     this.bandwidthMeter = bandwidthMeter;
@@ -435,15 +443,7 @@ public class SimpleExoPlayer extends BasePlayer
 
     // Build the player and associated objects.
     player =
-        new ExoPlayerImpl(
-            renderers,
-            trackSelector,
-            loadControl,
-            bandwidthMeter,
-            analyticsCollector,
-            useLazyPreparation,
-            clock,
-            looper);
+        new ExoPlayerImpl(renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
     analyticsCollector.setPlayer(player);
     addListener(analyticsCollector);
     addListener(componentListener);
@@ -456,7 +456,10 @@ public class SimpleExoPlayer extends BasePlayer
     if (drmSessionManager instanceof DefaultDrmSessionManager) {
       ((DefaultDrmSessionManager) drmSessionManager).addListener(eventHandler, analyticsCollector);
     }
-    audioFocusManager = new AudioFocusManager(context, componentListener);
+    audioBecomingNoisyManager =
+        new AudioBecomingNoisyManager(context, eventHandler, componentListener);
+    audioFocusManager = new AudioFocusManager(context, eventHandler, componentListener);
+    wakeLockManager = new WakeLockManager(context);
   }
 
   @Override
@@ -514,14 +517,16 @@ public class SimpleExoPlayer extends BasePlayer
   @Override
   public void clearVideoSurface() {
     verifyApplicationThread();
-    setVideoSurface(null);
+    removeSurfaceCallbacks();
+    setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ false);
+    maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
   }
 
   @Override
-  public void clearVideoSurface(Surface surface) {
+  public void clearVideoSurface(@Nullable Surface surface) {
     verifyApplicationThread();
     if (surface != null && surface == this.surface) {
-      setVideoSurface(null);
+      clearVideoSurface();
     }
   }
 
@@ -529,18 +534,24 @@ public class SimpleExoPlayer extends BasePlayer
   public void setVideoSurface(@Nullable Surface surface) {
     verifyApplicationThread();
     removeSurfaceCallbacks();
-    setVideoSurfaceInternal(surface, false);
+    if (surface != null) {
+      clearVideoDecoderOutputBufferRenderer();
+    }
+    setVideoSurfaceInternal(surface, /* ownsSurface= */ false);
     int newSurfaceSize = surface == null ? 0 : C.LENGTH_UNSET;
     maybeNotifySurfaceSizeChanged(/* width= */ newSurfaceSize, /* height= */ newSurfaceSize);
   }
 
   @Override
-  public void setVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
+  public void setVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder) {
     verifyApplicationThread();
     removeSurfaceCallbacks();
+    if (surfaceHolder != null) {
+      clearVideoDecoderOutputBufferRenderer();
+    }
     this.surfaceHolder = surfaceHolder;
     if (surfaceHolder == null) {
-      setVideoSurfaceInternal(null, false);
+      setVideoSurfaceInternal(null, /* ownsSurface= */ false);
       maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
     } else {
       surfaceHolder.addCallback(componentListener);
@@ -557,7 +568,7 @@ public class SimpleExoPlayer extends BasePlayer
   }
 
   @Override
-  public void clearVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
+  public void clearVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder) {
     verifyApplicationThread();
     if (surfaceHolder != null && surfaceHolder == this.surfaceHolder) {
       setVideoSurfaceHolder(null);
@@ -565,30 +576,33 @@ public class SimpleExoPlayer extends BasePlayer
   }
 
   @Override
-  public void setVideoSurfaceView(SurfaceView surfaceView) {
+  public void setVideoSurfaceView(@Nullable SurfaceView surfaceView) {
     setVideoSurfaceHolder(surfaceView == null ? null : surfaceView.getHolder());
   }
 
   @Override
-  public void clearVideoSurfaceView(SurfaceView surfaceView) {
+  public void clearVideoSurfaceView(@Nullable SurfaceView surfaceView) {
     clearVideoSurfaceHolder(surfaceView == null ? null : surfaceView.getHolder());
   }
 
   @Override
-  public void setVideoTextureView(TextureView textureView) {
+  public void setVideoTextureView(@Nullable TextureView textureView) {
     verifyApplicationThread();
     removeSurfaceCallbacks();
+    if (textureView != null) {
+      clearVideoDecoderOutputBufferRenderer();
+    }
     this.textureView = textureView;
     if (textureView == null) {
-      setVideoSurfaceInternal(null, true);
+      setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ true);
       maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
     } else {
       if (textureView.getSurfaceTextureListener() != null) {
         Log.w(TAG, "Replacing existing SurfaceTextureListener.");
       }
       textureView.setSurfaceTextureListener(componentListener);
-      SurfaceTexture surfaceTexture = textureView.isAvailable() ? textureView.getSurfaceTexture()
-          : null;
+      SurfaceTexture surfaceTexture =
+          textureView.isAvailable() ? textureView.getSurfaceTexture() : null;
       if (surfaceTexture == null) {
         setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ true);
         maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
@@ -600,7 +614,7 @@ public class SimpleExoPlayer extends BasePlayer
   }
 
   @Override
-  public void clearVideoTextureView(TextureView textureView) {
+  public void clearVideoTextureView(@Nullable TextureView textureView) {
     verifyApplicationThread();
     if (textureView != null && textureView == this.textureView) {
       setVideoTextureView(null);
@@ -608,6 +622,32 @@ public class SimpleExoPlayer extends BasePlayer
   }
 
   @Override
+  public void setVideoDecoderOutputBufferRenderer(
+      @Nullable VideoDecoderOutputBufferRenderer videoDecoderOutputBufferRenderer) {
+    verifyApplicationThread();
+    if (videoDecoderOutputBufferRenderer != null) {
+      clearVideoSurface();
+    }
+    setVideoDecoderOutputBufferRendererInternal(videoDecoderOutputBufferRenderer);
+  }
+
+  @Override
+  public void clearVideoDecoderOutputBufferRenderer() {
+    verifyApplicationThread();
+    setVideoDecoderOutputBufferRendererInternal(/* videoDecoderOutputBufferRenderer= */ null);
+  }
+
+  @Override
+  public void clearVideoDecoderOutputBufferRenderer(
+      @Nullable VideoDecoderOutputBufferRenderer videoDecoderOutputBufferRenderer) {
+    verifyApplicationThread();
+    if (videoDecoderOutputBufferRenderer != null
+        && videoDecoderOutputBufferRenderer == this.videoDecoderOutputBufferRenderer) {
+      clearVideoDecoderOutputBufferRenderer();
+    }
+  }
+
+  @Override
   public void addAudioListener(AudioListener listener) {
     audioListeners.add(listener);
   }
@@ -625,6 +665,9 @@ public class SimpleExoPlayer extends BasePlayer
   @Override
   public void setAudioAttributes(AudioAttributes audioAttributes, boolean handleAudioFocus) {
     verifyApplicationThread();
+    if (playerReleased) {
+      return;
+    }
     if (!Util.areEqual(this.audioAttributes, audioAttributes)) {
       this.audioAttributes = audioAttributes;
       for (Renderer renderer : renderers) {
@@ -698,12 +741,12 @@ public class SimpleExoPlayer extends BasePlayer
 
   /**
    * Sets the stream type for audio playback, used by the underlying audio track.
-   * <p>
-   * Setting the stream type during playback may introduce a short gap in audio output as the audio
-   * track is recreated. A new audio session id will also be generated.
-   * <p>
-   * Calling this method overwrites any attributes set previously by calling
-   * {@link #setAudioAttributes(AudioAttributes)}.
+   *
+   * <p>Setting the stream type during playback may introduce a short gap in audio output as the
+   * audio track is recreated. A new audio session id will also be generated.
+   *
+   * <p>Calling this method overwrites any attributes set previously by calling {@link
+   * #setAudioAttributes(AudioAttributes)}.
    *
    * @deprecated Use {@link #setAudioAttributes(AudioAttributes)}.
    * @param streamType The stream type for audio playback.
@@ -753,6 +796,25 @@ public class SimpleExoPlayer extends BasePlayer
   }
 
   /**
+   * Sets whether the player should pause automatically when audio is rerouted from a headset to
+   * device speakers. See the <a
+   * href="https://developer.android.com/guide/topics/media-apps/volume-and-earphones#becoming-noisy">audio
+   * becoming noisy</a> documentation for more information.
+   *
+   * <p>This feature is not enabled by default.
+   *
+   * @param handleAudioBecomingNoisy Whether the player should pause automatically when audio is
+   *     rerouted from a headset to device speakers.
+   */
+  public void setHandleAudioBecomingNoisy(boolean handleAudioBecomingNoisy) {
+    verifyApplicationThread();
+    if (playerReleased) {
+      return;
+    }
+    audioBecomingNoisyManager.setEnabled(handleAudioBecomingNoisy);
+  }
+
+  /**
    * Sets a {@link PriorityTaskManager}, or null to clear a previously set priority task manager.
    *
    * <p>The priority {@link C#PRIORITY_PLAYBACK} will be set while the player is loading.
@@ -1103,133 +1165,32 @@ public class SimpleExoPlayer extends BasePlayer
   }
 
   @Override
-  @Deprecated
   public void retry() {
     verifyApplicationThread();
-    prepare();
-  }
-
-  @Override
-  public void prepare() {
-    verifyApplicationThread();
-    @AudioFocusManager.PlayerCommand
-    int playerCommand = audioFocusManager.handlePrepare(getPlayWhenReady());
-    updatePlayWhenReady(getPlayWhenReady(), playerCommand);
-    player.prepare();
+    if (mediaSource != null
+        && (getPlaybackError() != null || getPlaybackState() == Player.STATE_IDLE)) {
+      prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
+    }
   }
 
   @Override
-  @Deprecated
-  @SuppressWarnings("deprecation")
   public void prepare(MediaSource mediaSource) {
     prepare(mediaSource, /* resetPosition= */ true, /* resetState= */ true);
   }
 
   @Override
-  @Deprecated
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     verifyApplicationThread();
-    setMediaItems(
-        Collections.singletonList(mediaSource),
-        /* startWindowIndex= */ resetPosition ? 0 : C.INDEX_UNSET,
-        /* startPositionMs= */ C.TIME_UNSET);
-    prepare();
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItems(mediaItems);
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItems(mediaItems, resetPosition);
-  }
-
-  @Override
-  public void setMediaItems(
-      List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItems(mediaItems, startWindowIndex, startPositionMs);
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItem(mediaItem);
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem, long startPositionMs) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItem(mediaItem, startPositionMs);
-  }
-
-  @Override
-  public void addMediaItem(MediaSource mediaSource) {
-    verifyApplicationThread();
-    player.addMediaItem(mediaSource);
-  }
-
-  @Override
-  public void addMediaItem(int index, MediaSource mediaSource) {
-    verifyApplicationThread();
-    player.addMediaItem(index, mediaSource);
-  }
-
-  @Override
-  public void addMediaItems(List<MediaSource> mediaSources) {
-    verifyApplicationThread();
-    player.addMediaItems(mediaSources);
-  }
-
-  @Override
-  public void addMediaItems(int index, List<MediaSource> mediaSources) {
-    verifyApplicationThread();
-    player.addMediaItems(index, mediaSources);
-  }
-
-  @Override
-  public void moveMediaItem(int currentIndex, int newIndex) {
-    verifyApplicationThread();
-    player.moveMediaItem(currentIndex, newIndex);
-  }
-
-  @Override
-  public void moveMediaItems(int fromIndex, int toIndex, int newIndex) {
-    verifyApplicationThread();
-    player.moveMediaItems(fromIndex, toIndex, newIndex);
-  }
-
-  @Override
-  public MediaSource removeMediaItem(int index) {
-    verifyApplicationThread();
-    return player.removeMediaItem(index);
-  }
-
-  @Override
-  public void removeMediaItems(int fromIndex, int toIndex) {
-    verifyApplicationThread();
-    player.removeMediaItems(fromIndex, toIndex);
-  }
-
-  @Override
-  public void clearMediaItems() {
-    verifyApplicationThread();
-    player.clearMediaItems();
-  }
-
-  @Override
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    verifyApplicationThread();
-    player.setShuffleOrder(shuffleOrder);
+    if (this.mediaSource != null) {
+      this.mediaSource.removeEventListener(analyticsCollector);
+      analyticsCollector.resetForNewMediaSource();
+    }
+    this.mediaSource = mediaSource;
+    mediaSource.addEventListener(eventHandler, analyticsCollector);
+    @AudioFocusManager.PlayerCommand
+    int playerCommand = audioFocusManager.handlePrepare(getPlayWhenReady());
+    updatePlayWhenReady(getPlayWhenReady(), playerCommand);
+    player.prepare(mediaSource, resetPosition, resetState);
   }
 
   @Override
@@ -1309,7 +1270,6 @@ public class SimpleExoPlayer extends BasePlayer
 
   @Override
   public void setForegroundMode(boolean foregroundMode) {
-    verifyApplicationThread();
     player.setForegroundMode(foregroundMode);
   }
 
@@ -1317,6 +1277,13 @@ public class SimpleExoPlayer extends BasePlayer
   public void stop(boolean reset) {
     verifyApplicationThread();
     player.stop(reset);
+    if (mediaSource != null) {
+      mediaSource.removeEventListener(analyticsCollector);
+      analyticsCollector.resetForNewMediaSource();
+      if (reset) {
+        mediaSource = null;
+      }
+    }
     audioFocusManager.handleStop();
     currentCues = Collections.emptyList();
   }
@@ -1324,7 +1291,9 @@ public class SimpleExoPlayer extends BasePlayer
   @Override
   public void release() {
     verifyApplicationThread();
+    audioBecomingNoisyManager.setEnabled(false);
     audioFocusManager.handleStop();
+    wakeLockManager.setStayAwake(false);
     player.release();
     removeSurfaceCallbacks();
     if (surface != null) {
@@ -1333,12 +1302,17 @@ public class SimpleExoPlayer extends BasePlayer
       }
       surface = null;
     }
+    if (mediaSource != null) {
+      mediaSource.removeEventListener(analyticsCollector);
+      mediaSource = null;
+    }
     if (isPriorityTaskManagerRegistered) {
       Assertions.checkNotNull(priorityTaskManager).remove(C.PRIORITY_PLAYBACK);
       isPriorityTaskManagerRegistered = false;
     }
     bandwidthMeter.removeEventListener(analyticsCollector);
     currentCues = Collections.emptyList();
+    playerReleased = true;
   }
 
   @Override
@@ -1443,6 +1417,26 @@ public class SimpleExoPlayer extends BasePlayer
     return player.getContentBufferedPosition();
   }
 
+  /**
+   * Sets whether the player should use a {@link android.os.PowerManager.WakeLock} to ensure the
+   * device stays awake for playback, even when the screen is off.
+   *
+   * <p>Enabling this feature requires the {@link android.Manifest.permission#WAKE_LOCK} permission.
+   * It should be used together with a foreground {@link android.app.Service} for use cases where
+   * playback can occur when the screen is off (e.g. background audio playback). It is not useful if
+   * the screen will always be on during playback (e.g. foreground video playback).
+   *
+   * <p>This feature is not enabled by default. If enabled, a WakeLock is held whenever the player
+   * is in the {@link #STATE_READY READY} or {@link #STATE_BUFFERING BUFFERING} states with {@code
+   * playWhenReady = true}.
+   *
+   * @param handleWakeLock Whether the player should use a {@link android.os.PowerManager.WakeLock}
+   *     to ensure the device stays awake for playback, even when the screen is off.
+   */
+  public void setHandleWakeLock(boolean handleWakeLock) {
+    wakeLockManager.setEnabled(handleWakeLock);
+  }
+
   // Internal methods.
 
   private void removeSurfaceCallbacks() {
@@ -1488,6 +1482,20 @@ public class SimpleExoPlayer extends BasePlayer
     this.ownsSurface = ownsSurface;
   }
 
+  private void setVideoDecoderOutputBufferRendererInternal(
+      @Nullable VideoDecoderOutputBufferRenderer videoDecoderOutputBufferRenderer) {
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_VIDEO_DECODER_OUTPUT_BUFFER_RENDERER)
+            .setPayload(videoDecoderOutputBufferRenderer)
+            .send();
+      }
+    }
+    this.videoDecoderOutputBufferRenderer = videoDecoderOutputBufferRenderer;
+  }
+
   private void maybeNotifySurfaceSizeChanged(int width, int height) {
     if (width != surfaceWidth || height != surfaceHeight) {
       surfaceWidth = width;
@@ -1509,13 +1517,13 @@ public class SimpleExoPlayer extends BasePlayer
 
   private void updatePlayWhenReady(
       boolean playWhenReady, @AudioFocusManager.PlayerCommand int playerCommand) {
+    playWhenReady = playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY;
+    @PlaybackSuppressionReason
     int playbackSuppressionReason =
-        playerCommand == AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY
-            ? Player.PLAYBACK_SUPPRESSION_REASON_NONE
-            : Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS;
-    player.setPlayWhenReady(
-        playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY,
-        playbackSuppressionReason);
+        playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY
+            ? Player.PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS
+            : Player.PLAYBACK_SUPPRESSION_REASON_NONE;
+    player.setPlayWhenReady(playWhenReady, playbackSuppressionReason);
   }
 
   private void verifyApplicationThread() {
@@ -1537,6 +1545,7 @@ public class SimpleExoPlayer extends BasePlayer
           SurfaceHolder.Callback,
           TextureView.SurfaceTextureListener,
           AudioFocusManager.PlayerControl,
+          AudioBecomingNoisyManager.EventListener,
           Player.EventListener {
 
     // VideoRendererEventListener implementation
@@ -1550,11 +1559,11 @@ public class SimpleExoPlayer extends BasePlayer
     }
 
     @Override
-    public void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
-        long initializationDurationMs) {
+    public void onVideoDecoderInitialized(
+        String decoderName, long initializedTimestampMs, long initializationDurationMs) {
       for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
-        videoDebugListener.onVideoDecoderInitialized(decoderName, initializedTimestampMs,
-            initializationDurationMs);
+        videoDebugListener.onVideoDecoderInitialized(
+            decoderName, initializedTimestampMs, initializationDurationMs);
       }
     }
 
@@ -1574,8 +1583,8 @@ public class SimpleExoPlayer extends BasePlayer
     }
 
     @Override
-    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio) {
+    public void onVideoSizeChanged(
+        int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
       for (com.google.android.exoplayer2.video.VideoListener videoListener : videoListeners) {
         // Prevent duplicate notification if a listener is both a VideoRendererEventListener and
         // a VideoListener, as they have the same method signature.
@@ -1585,8 +1594,8 @@ public class SimpleExoPlayer extends BasePlayer
         }
       }
       for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
-        videoDebugListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
-            pixelWidthHeightRatio);
+        videoDebugListener.onVideoSizeChanged(
+            width, height, unappliedRotationDegrees, pixelWidthHeightRatio);
       }
     }
 
@@ -1640,11 +1649,11 @@ public class SimpleExoPlayer extends BasePlayer
     }
 
     @Override
-    public void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
-        long initializationDurationMs) {
+    public void onAudioDecoderInitialized(
+        String decoderName, long initializedTimestampMs, long initializationDurationMs) {
       for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
-        audioDebugListener.onAudioDecoderInitialized(decoderName, initializedTimestampMs,
-            initializationDurationMs);
+        audioDebugListener.onAudioDecoderInitialized(
+            decoderName, initializedTimestampMs, initializationDurationMs);
       }
     }
 
@@ -1657,8 +1666,8 @@ public class SimpleExoPlayer extends BasePlayer
     }
 
     @Override
-    public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs,
-        long elapsedSinceLastFeedMs) {
+    public void onAudioSinkUnderrun(
+        int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
       for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
       }
@@ -1707,7 +1716,7 @@ public class SimpleExoPlayer extends BasePlayer
 
     @Override
     public void surfaceDestroyed(SurfaceHolder holder) {
-      setVideoSurfaceInternal(null, false);
+      setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ false);
       maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
     }
 
@@ -1715,7 +1724,7 @@ public class SimpleExoPlayer extends BasePlayer
 
     @Override
     public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) {
-      setVideoSurfaceInternal(new Surface(surfaceTexture), true);
+      setVideoSurfaceInternal(new Surface(surfaceTexture), /* ownsSurface= */ true);
       maybeNotifySurfaceSizeChanged(width, height);
     }
 
@@ -1726,7 +1735,7 @@ public class SimpleExoPlayer extends BasePlayer
 
     @Override
     public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
-      setVideoSurfaceInternal(null, true);
+      setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ true);
       maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
       return true;
     }
@@ -1748,6 +1757,13 @@ public class SimpleExoPlayer extends BasePlayer
       updatePlayWhenReady(getPlayWhenReady(), playerCommand);
     }
 
+    // AudioBecomingNoisyManager.EventListener implementation.
+
+    @Override
+    public void onAudioBecomingNoisy() {
+      setPlayWhenReady(false);
+    }
+
     // Player.EventListener implementation.
 
     @Override
@@ -1762,5 +1778,19 @@ public class SimpleExoPlayer extends BasePlayer
         }
       }
     }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, @State int playbackState) {
+      switch (playbackState) {
+        case Player.STATE_READY:
+        case Player.STATE_BUFFERING:
+          wakeLockManager.setStayAwake(playWhenReady);
+          break;
+        case Player.STATE_ENDED:
+        case Player.STATE_IDLE:
+          wakeLockManager.setStayAwake(false);
+          break;
+      }
+    }
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 458532c..ce1a588 100644
--- a/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -19,7 +19,6 @@ import android.util.Pair;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.ads.AdPlaybackState;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 
 /**
  * A flexible representation of the structure of media. A timeline is able to represent the
@@ -67,8 +66,9 @@ import com.google.android.exoplayer2.util.Util;
  * duration is unknown, since it's continually extending as more content is broadcast. If content
  * only remains available for a limited period of time then the window may start at a non-zero
  * position, defining the region of content that can still be played. The window will have {@link
- * Window#isDynamic} set to true if the stream is still live. Its default position is typically near
- * to the live edge (indicated by the black dot in the figure above).
+ * Window#isLive} set to true to indicate it's a live stream and {@link Window#isDynamic} set to
+ * true as long as we expect changes to the live window. Its default position is typically near to
+ * the live edge (indicated by the black dot in the figure above).
  *
  * <h3>Live stream with indefinite availability</h3>
  *
@@ -159,8 +159,13 @@ public abstract class Timeline {
     public boolean isDynamic;
 
     /**
-     * The index of the first period that belongs to this window.
+     * Whether the media in this window is live. For informational purposes only.
+     *
+     * <p>Check {@link #isDynamic} to know whether this window may still change.
      */
+    public boolean isLive;
+
+    /** The index of the first period that belongs to this window. */
     public int firstPeriodIndex;
 
     /**
@@ -201,6 +206,7 @@ public abstract class Timeline {
         long windowStartTimeMs,
         boolean isSeekable,
         boolean isDynamic,
+        boolean isLive,
         long defaultPositionUs,
         long durationUs,
         int firstPeriodIndex,
@@ -213,6 +219,7 @@ public abstract class Timeline {
       this.windowStartTimeMs = windowStartTimeMs;
       this.isSeekable = isSeekable;
       this.isDynamic = isDynamic;
+      this.isLive = isLive;
       this.defaultPositionUs = defaultPositionUs;
       this.durationUs = durationUs;
       this.firstPeriodIndex = firstPeriodIndex;
@@ -271,46 +278,6 @@ public abstract class Timeline {
       return positionInFirstPeriodUs;
     }
 
-    @Override
-    public boolean equals(@Nullable Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null || !getClass().equals(obj.getClass())) {
-        return false;
-      }
-      Window that = (Window) obj;
-      return Util.areEqual(uid, that.uid)
-          && Util.areEqual(tag, that.tag)
-          && Util.areEqual(manifest, that.manifest)
-          && presentationStartTimeMs == that.presentationStartTimeMs
-          && windowStartTimeMs == that.windowStartTimeMs
-          && isSeekable == that.isSeekable
-          && isDynamic == that.isDynamic
-          && defaultPositionUs == that.defaultPositionUs
-          && durationUs == that.durationUs
-          && firstPeriodIndex == that.firstPeriodIndex
-          && lastPeriodIndex == that.lastPeriodIndex
-          && positionInFirstPeriodUs == that.positionInFirstPeriodUs;
-    }
-
-    @Override
-    public int hashCode() {
-      int result = 7;
-      result = 31 * result + uid.hashCode();
-      result = 31 * result + (tag == null ? 0 : tag.hashCode());
-      result = 31 * result + (manifest == null ? 0 : manifest.hashCode());
-      result = 31 * result + (int) (presentationStartTimeMs ^ (presentationStartTimeMs >>> 32));
-      result = 31 * result + (int) (windowStartTimeMs ^ (windowStartTimeMs >>> 32));
-      result = 31 * result + (isSeekable ? 1 : 0);
-      result = 31 * result + (isDynamic ? 1 : 0);
-      result = 31 * result + (int) (defaultPositionUs ^ (defaultPositionUs >>> 32));
-      result = 31 * result + (int) (durationUs ^ (durationUs >>> 32));
-      result = 31 * result + firstPeriodIndex;
-      result = 31 * result + lastPeriodIndex;
-      result = 31 * result + (int) (positionInFirstPeriodUs ^ (positionInFirstPeriodUs >>> 32));
-      return result;
-    }
   }
 
   /**
@@ -567,34 +534,6 @@ public abstract class Timeline {
       return adPlaybackState.adResumePositionUs;
     }
 
-    @Override
-    public boolean equals(@Nullable Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null || !getClass().equals(obj.getClass())) {
-        return false;
-      }
-      Period that = (Period) obj;
-      return Util.areEqual(id, that.id)
-          && Util.areEqual(uid, that.uid)
-          && windowIndex == that.windowIndex
-          && durationUs == that.durationUs
-          && positionInWindowUs == that.positionInWindowUs
-          && Util.areEqual(adPlaybackState, that.adPlaybackState);
-    }
-
-    @Override
-    public int hashCode() {
-      int result = 7;
-      result = 31 * result + (id == null ? 0 : id.hashCode());
-      result = 31 * result + (uid == null ? 0 : uid.hashCode());
-      result = 31 * result + windowIndex;
-      result = 31 * result + (int) (durationUs ^ (durationUs >>> 32));
-      result = 31 * result + (int) (positionInWindowUs ^ (positionInWindowUs >>> 32));
-      result = 31 * result + (adPlaybackState == null ? 0 : adPlaybackState.hashCode());
-      return result;
-    }
   }
 
   /** An empty timeline. */
diff --git a/core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java b/core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java
new file mode 100644
index 0000000..f498eea
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Log;
+
+/**
+ * Handles a {@link WakeLock}.
+ *
+ * <p>The handling of wake locks requires the {@link android.Manifest.permission#WAKE_LOCK}
+ * permission.
+ */
+/* package */ final class WakeLockManager {
+
+  private static final String TAG = "WakeLockManager";
+  private static final String WAKE_LOCK_TAG = "ExoPlayer:WakeLockManager";
+
+  @Nullable private final PowerManager powerManager;
+  @Nullable private WakeLock wakeLock;
+  private boolean enabled;
+  private boolean stayAwake;
+
+  public WakeLockManager(Context context) {
+    powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+  }
+
+  /**
+   * Sets whether to enable the acquiring and releasing of the {@link WakeLock}.
+   *
+   * <p>By default, wake lock handling is not enabled. Enabling this will acquire the wake lock if
+   * necessary. Disabling this will release the wake lock if it is held.
+   *
+   * @param enabled True if the player should handle a {@link WakeLock}, false otherwise. Please
+   *     note that enabling this requires the {@link android.Manifest.permission#WAKE_LOCK}
+   *     permission.
+   */
+  public void setEnabled(boolean enabled) {
+    if (enabled) {
+      if (wakeLock == null) {
+        if (powerManager == null) {
+          Log.w(TAG, "PowerManager was null, therefore the WakeLock was not created.");
+          return;
+        }
+        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG);
+      }
+    }
+
+    this.enabled = enabled;
+    updateWakeLock();
+  }
+
+  /**
+   * Sets whether to acquire or release the {@link WakeLock}.
+   *
+   * <p>Please note this method requires wake lock handling to be enabled through setEnabled(boolean
+   * enable) to actually have an impact on the {@link WakeLock}.
+   *
+   * @param stayAwake True if the player should acquire the {@link WakeLock}. False if the player
+   *     should release.
+   */
+  public void setStayAwake(boolean stayAwake) {
+    this.stayAwake = stayAwake;
+    updateWakeLock();
+  }
+
+  // WakelockTimeout suppressed because the time the wake lock is needed for is unknown (could be
+  // listening to radio with screen off for multiple hours), therefore we can not determine a
+  // reasonable timeout that would not affect the user.
+  @SuppressLint("WakelockTimeout")
+  private void updateWakeLock() {
+    // Needed for the library nullness check. If enabled is true, the wakelock will not be null.
+    if (wakeLock != null) {
+      if (enabled) {
+        if (stayAwake && !wakeLock.isHeld()) {
+          wakeLock.acquire();
+        } else if (!stayAwake && wakeLock.isHeld()) {
+          wakeLock.release();
+        }
+      } else if (wakeLock.isHeld()) {
+        wakeLock.release();
+      }
+    }
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java b/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
index 2cb160d..dc1089e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
+++ b/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
@@ -22,6 +22,7 @@ import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.PlaybackSuppressionReason;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.Timeline.Window;
@@ -132,8 +133,11 @@ public class AnalyticsCollector
     }
   }
 
-  /** Resets the analytics collector for a new playlist. */
-  public final void resetForNewPlaylist() {
+  /**
+   * Resets the analytics collector for a new media source. Should be called before the player is
+   * prepared with a new media source.
+   */
+  public final void resetForNewMediaSource() {
     // Copying the list is needed because onMediaPeriodReleased will modify the list.
     List<MediaPeriodInfo> mediaPeriodInfos =
         new ArrayList<>(mediaPeriodQueueTracker.mediaPeriodInfoQueue);
@@ -445,6 +449,23 @@ public class AnalyticsCollector
   }
 
   @Override
+  public void onPlaybackSuppressionReasonChanged(
+      @PlaybackSuppressionReason int playbackSuppressionReason) {
+    EventTime eventTime = generatePlayingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onPlaybackSuppressionReasonChanged(eventTime, playbackSuppressionReason);
+    }
+  }
+
+  @Override
+  public void onIsPlayingChanged(boolean isPlaying) {
+    EventTime eventTime = generatePlayingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onIsPlayingChanged(eventTime, isPlaying);
+    }
+  }
+
+  @Override
   public final void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
     EventTime eventTime = generatePlayingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
@@ -805,7 +826,7 @@ public class AnalyticsCollector
     public boolean onMediaPeriodReleased(MediaPeriodId mediaPeriodId) {
       MediaPeriodInfo mediaPeriodInfo = mediaPeriodIdToInfo.remove(mediaPeriodId);
       if (mediaPeriodInfo == null) {
-        // The media period has already been removed from the queue in resetForNewPlaylist().
+        // The media period has already been removed from the queue in resetForNewMediaSource().
         return false;
       }
       mediaPeriodInfoQueue.remove(mediaPeriodInfo);
diff --git a/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java b/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
index 656548d..e16d92d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
@@ -23,6 +23,7 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.Player.PlaybackSuppressionReason;
 import com.google.android.exoplayer2.Player.TimelineChangeReason;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioAttributes;
@@ -133,6 +134,23 @@ public interface AnalyticsListener {
       EventTime eventTime, boolean playWhenReady, @Player.State int playbackState) {}
 
   /**
+   * Called when playback suppression reason changed.
+   *
+   * @param eventTime The event time.
+   * @param playbackSuppressionReason The new {@link PlaybackSuppressionReason}.
+   */
+  default void onPlaybackSuppressionReasonChanged(
+      EventTime eventTime, @PlaybackSuppressionReason int playbackSuppressionReason) {}
+
+  /**
+   * Called when the player starts or stops playing.
+   *
+   * @param eventTime The event time.
+   * @param isPlaying Whether the player is playing.
+   */
+  default void onIsPlayingChanged(EventTime eventTime, boolean isPlaying) {}
+
+  /**
    * Called when the timeline changed.
    *
    * @param eventTime The event time.
diff --git a/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java b/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java
index bd8fb21..b370c89 100644
--- a/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java
+++ b/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java
@@ -38,8 +38,10 @@ public final class PlaybackStats {
    * #PLAYBACK_STATE_JOINING_FOREGROUND}, {@link #PLAYBACK_STATE_JOINING_BACKGROUND}, {@link
    * #PLAYBACK_STATE_PLAYING}, {@link #PLAYBACK_STATE_PAUSED}, {@link #PLAYBACK_STATE_SEEKING},
    * {@link #PLAYBACK_STATE_BUFFERING}, {@link #PLAYBACK_STATE_PAUSED_BUFFERING}, {@link
-   * #PLAYBACK_STATE_SEEK_BUFFERING}, {@link #PLAYBACK_STATE_ENDED}, {@link
-   * #PLAYBACK_STATE_STOPPED}, {@link #PLAYBACK_STATE_FAILED} or {@link #PLAYBACK_STATE_SUSPENDED}.
+   * #PLAYBACK_STATE_SEEK_BUFFERING}, {@link #PLAYBACK_STATE_SUPPRESSED}, {@link
+   * #PLAYBACK_STATE_SUPPRESSED_BUFFERING}, {@link #PLAYBACK_STATE_ENDED}, {@link
+   * #PLAYBACK_STATE_STOPPED}, {@link #PLAYBACK_STATE_FAILED}, {@link
+   * #PLAYBACK_STATE_INTERRUPTED_BY_AD} or {@link #PLAYBACK_STATE_ABANDONED}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -54,10 +56,13 @@ public final class PlaybackStats {
     PLAYBACK_STATE_BUFFERING,
     PLAYBACK_STATE_PAUSED_BUFFERING,
     PLAYBACK_STATE_SEEK_BUFFERING,
+    PLAYBACK_STATE_SUPPRESSED,
+    PLAYBACK_STATE_SUPPRESSED_BUFFERING,
     PLAYBACK_STATE_ENDED,
     PLAYBACK_STATE_STOPPED,
     PLAYBACK_STATE_FAILED,
-    PLAYBACK_STATE_SUSPENDED
+    PLAYBACK_STATE_INTERRUPTED_BY_AD,
+    PLAYBACK_STATE_ABANDONED
   })
   @interface PlaybackState {}
   /** Playback has not started (initial state). */
@@ -72,22 +77,28 @@ public final class PlaybackStats {
   public static final int PLAYBACK_STATE_PAUSED = 4;
   /** Playback is handling a seek. */
   public static final int PLAYBACK_STATE_SEEKING = 5;
-  /** Playback is buffering to restart playback. */
+  /** Playback is buffering to resume active playback. */
   public static final int PLAYBACK_STATE_BUFFERING = 6;
   /** Playback is buffering while paused. */
   public static final int PLAYBACK_STATE_PAUSED_BUFFERING = 7;
   /** Playback is buffering after a seek. */
   public static final int PLAYBACK_STATE_SEEK_BUFFERING = 8;
+  /** Playback is suppressed (e.g. due to audio focus loss). */
+  public static final int PLAYBACK_STATE_SUPPRESSED = 9;
+  /** Playback is suppressed (e.g. due to audio focus loss) while buffering to resume a playback. */
+  public static final int PLAYBACK_STATE_SUPPRESSED_BUFFERING = 10;
   /** Playback has reached the end of the media. */
-  public static final int PLAYBACK_STATE_ENDED = 9;
-  /** Playback is stopped and can be resumed. */
-  public static final int PLAYBACK_STATE_STOPPED = 10;
+  public static final int PLAYBACK_STATE_ENDED = 11;
+  /** Playback is stopped and can be restarted. */
+  public static final int PLAYBACK_STATE_STOPPED = 12;
   /** Playback is stopped due a fatal error and can be retried. */
-  public static final int PLAYBACK_STATE_FAILED = 11;
-  /** Playback is suspended, e.g. because the user left or it is interrupted by another playback. */
-  public static final int PLAYBACK_STATE_SUSPENDED = 12;
+  public static final int PLAYBACK_STATE_FAILED = 13;
+  /** Playback is interrupted by an ad. */
+  public static final int PLAYBACK_STATE_INTERRUPTED_BY_AD = 14;
+  /** Playback is abandoned before reaching the end of the media. */
+  public static final int PLAYBACK_STATE_ABANDONED = 15;
   /** Total number of playback states. */
-  /* package */ static final int PLAYBACK_STATE_COUNT = 13;
+  /* package */ static final int PLAYBACK_STATE_COUNT = 16;
 
   /** Empty playback stats. */
   public static final PlaybackStats EMPTY = merge(/* nothing */ );
diff --git a/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java b/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java
index 8b9f1d1..3430bfc 100644
--- a/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java
@@ -81,6 +81,7 @@ public final class PlaybackStatsListener
   @Nullable private String activeAdPlayback;
   private boolean playWhenReady;
   @Player.State private int playbackState;
+  private boolean isSuppressed;
   private float playbackSpeed;
 
   /**
@@ -169,6 +170,7 @@ public final class PlaybackStatsListener
     PlaybackStatsTracker tracker = new PlaybackStatsTracker(keepHistory, eventTime);
     tracker.onPlayerStateChanged(
         eventTime, playWhenReady, playbackState, /* belongsToPlayback= */ true);
+    tracker.onIsSuppressedChanged(eventTime, isSuppressed, /* belongsToPlayback= */ true);
     tracker.onPlaybackSpeedChanged(eventTime, playbackSpeed);
     playbackStatsTrackers.put(session, tracker);
     sessionStartEventTimes.put(session, eventTime);
@@ -205,7 +207,7 @@ public final class PlaybackStatsListener
             eventTime.currentPlaybackPositionMs,
             eventTime.totalBufferedDurationMs);
     Assertions.checkNotNull(playbackStatsTrackers.get(contentSession))
-        .onSuspended(contentEventTime, /* belongsToPlayback= */ true);
+        .onInterruptedByAd(contentEventTime);
   }
 
   @Override
@@ -222,7 +224,7 @@ public final class PlaybackStatsListener
       tracker.onPlayerStateChanged(
           eventTime, /* playWhenReady= */ true, Player.STATE_ENDED, /* belongsToPlayback= */ false);
     }
-    tracker.onSuspended(eventTime, /* belongsToPlayback= */ false);
+    tracker.onFinished(eventTime);
     PlaybackStats playbackStats = tracker.build(/* isFinal= */ true);
     finishedPlaybackStats = PlaybackStats.merge(finishedPlaybackStats, playbackStats);
     if (callback != null) {
@@ -247,6 +249,19 @@ public final class PlaybackStatsListener
   }
 
   @Override
+  public void onPlaybackSuppressionReasonChanged(
+      EventTime eventTime, int playbackSuppressionReason) {
+    isSuppressed = playbackSuppressionReason != Player.PLAYBACK_SUPPRESSION_REASON_NONE;
+    sessionManager.updateSessions(eventTime);
+    for (String session : playbackStatsTrackers.keySet()) {
+      boolean belongsToPlayback = sessionManager.belongsToSession(eventTime, session);
+      playbackStatsTrackers
+          .get(session)
+          .onIsSuppressedChanged(eventTime, isSuppressed, belongsToPlayback);
+    }
+  }
+
+  @Override
   public void onTimelineChanged(EventTime eventTime, int reason) {
     sessionManager.handleTimelineUpdate(eventTime);
     sessionManager.updateSessions(eventTime);
@@ -456,9 +471,11 @@ public final class PlaybackStatsListener
     private long currentPlaybackStateStartTimeMs;
     private boolean isSeeking;
     private boolean isForeground;
-    private boolean isSuspended;
+    private boolean isInterruptedByAd;
+    private boolean isFinished;
     private boolean playWhenReady;
     @Player.State private int playerPlaybackState;
+    private boolean isSuppressed;
     private boolean hasFatalError;
     private boolean startedLoading;
     private long lastRebufferStartTimeMs;
@@ -515,18 +532,32 @@ public final class PlaybackStatsListener
         hasFatalError = false;
       }
       if (playbackState == Player.STATE_IDLE || playbackState == Player.STATE_ENDED) {
-        isSuspended = false;
+        isInterruptedByAd = false;
       }
       maybeUpdatePlaybackState(eventTime, belongsToPlayback);
     }
 
     /**
+     * Notifies the tracker of a change to the playback suppression (e.g. due to audio focus loss),
+     * including all updates while the playback is not in the foreground.
+     *
+     * @param eventTime The {@link EventTime}.
+     * @param isSuppressed Whether playback is suppressed.
+     * @param belongsToPlayback Whether the {@code eventTime} belongs to the current playback.
+     */
+    public void onIsSuppressedChanged(
+        EventTime eventTime, boolean isSuppressed, boolean belongsToPlayback) {
+      this.isSuppressed = isSuppressed;
+      maybeUpdatePlaybackState(eventTime, belongsToPlayback);
+    }
+
+    /**
      * Notifies the tracker of a position discontinuity or timeline update for the current playback.
      *
      * @param eventTime The {@link EventTime}.
      */
     public void onPositionDiscontinuity(EventTime eventTime) {
-      isSuspended = false;
+      isInterruptedByAd = false;
       maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ true);
     }
 
@@ -561,7 +592,7 @@ public final class PlaybackStatsListener
         fatalErrorHistory.add(Pair.create(eventTime, error));
       }
       hasFatalError = true;
-      isSuspended = false;
+      isInterruptedByAd = false;
       isSeeking = false;
       maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ true);
     }
@@ -587,16 +618,24 @@ public final class PlaybackStatsListener
     }
 
     /**
-     * Notifies the tracker that the current playback has been suspended, e.g. for ad playback or
-     * permanently.
+     * Notifies the tracker that the current playback has been interrupted for ad playback.
      *
      * @param eventTime The {@link EventTime}.
-     * @param belongsToPlayback Whether the {@code eventTime} belongs to the current playback.
      */
-    public void onSuspended(EventTime eventTime, boolean belongsToPlayback) {
-      isSuspended = true;
+    public void onInterruptedByAd(EventTime eventTime) {
+      isInterruptedByAd = true;
       isSeeking = false;
-      maybeUpdatePlaybackState(eventTime, belongsToPlayback);
+      maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ true);
+    }
+
+    /**
+     * Notifies the tracker that the current playback has finished.
+     *
+     * @param eventTime The {@link EventTime}. Not guaranteed to belong to the current playback.
+     */
+    public void onFinished(EventTime eventTime) {
+      isFinished = true;
+      maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ false);
     }
 
     /**
@@ -809,8 +848,9 @@ public final class PlaybackStatsListener
         rebufferCount++;
         lastRebufferStartTimeMs = eventTime.realtimeMs;
       }
-      if (newPlaybackState == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING
-          && currentPlaybackState == PlaybackStats.PLAYBACK_STATE_BUFFERING) {
+      if (isRebufferingState(currentPlaybackState)
+          && currentPlaybackState != PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING
+          && newPlaybackState == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING) {
         pauseBufferCount++;
       }
 
@@ -829,11 +869,11 @@ public final class PlaybackStatsListener
     }
 
     private @PlaybackState int resolveNewPlaybackState() {
-      if (isSuspended) {
+      if (isFinished) {
         // Keep VIDEO_STATE_ENDED if playback naturally ended (or progressed to next item).
         return currentPlaybackState == PlaybackStats.PLAYBACK_STATE_ENDED
             ? PlaybackStats.PLAYBACK_STATE_ENDED
-            : PlaybackStats.PLAYBACK_STATE_SUSPENDED;
+            : PlaybackStats.PLAYBACK_STATE_ABANDONED;
       } else if (isSeeking) {
         // Seeking takes precedence over errors such that we report a seek while in error state.
         return PlaybackStats.PLAYBACK_STATE_SEEKING;
@@ -844,26 +884,34 @@ public final class PlaybackStatsListener
         return startedLoading
             ? PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
             : PlaybackStats.PLAYBACK_STATE_NOT_STARTED;
+      } else if (isInterruptedByAd) {
+        return PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD;
       } else if (playerPlaybackState == Player.STATE_ENDED) {
         return PlaybackStats.PLAYBACK_STATE_ENDED;
       } else if (playerPlaybackState == Player.STATE_BUFFERING) {
         if (currentPlaybackState == PlaybackStats.PLAYBACK_STATE_NOT_STARTED
             || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
             || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND
-            || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_SUSPENDED) {
+            || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD) {
           return PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND;
         }
         if (currentPlaybackState == PlaybackStats.PLAYBACK_STATE_SEEKING
             || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_SEEK_BUFFERING) {
           return PlaybackStats.PLAYBACK_STATE_SEEK_BUFFERING;
         }
-        return playWhenReady
-            ? PlaybackStats.PLAYBACK_STATE_BUFFERING
-            : PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING;
+        if (!playWhenReady) {
+          return PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING;
+        }
+        return isSuppressed
+            ? PlaybackStats.PLAYBACK_STATE_SUPPRESSED_BUFFERING
+            : PlaybackStats.PLAYBACK_STATE_BUFFERING;
       } else if (playerPlaybackState == Player.STATE_READY) {
-        return playWhenReady
-            ? PlaybackStats.PLAYBACK_STATE_PLAYING
-            : PlaybackStats.PLAYBACK_STATE_PAUSED;
+        if (!playWhenReady) {
+          return PlaybackStats.PLAYBACK_STATE_PAUSED;
+        }
+        return isSuppressed
+            ? PlaybackStats.PLAYBACK_STATE_SUPPRESSED
+            : PlaybackStats.PLAYBACK_STATE_PLAYING;
       } else if (playerPlaybackState == Player.STATE_IDLE
           && currentPlaybackState != PlaybackStats.PLAYBACK_STATE_NOT_STARTED) {
         // This case only applies for calls to player.stop(). All other IDLE cases are handled by
@@ -974,7 +1022,8 @@ public final class PlaybackStatsListener
 
     private static boolean isReadyState(@PlaybackState int state) {
       return state == PlaybackStats.PLAYBACK_STATE_PLAYING
-          || state == PlaybackStats.PLAYBACK_STATE_PAUSED;
+          || state == PlaybackStats.PLAYBACK_STATE_PAUSED
+          || state == PlaybackStats.PLAYBACK_STATE_SUPPRESSED;
     }
 
     private static boolean isPausedState(@PlaybackState int state) {
@@ -984,21 +1033,23 @@ public final class PlaybackStatsListener
 
     private static boolean isRebufferingState(@PlaybackState int state) {
       return state == PlaybackStats.PLAYBACK_STATE_BUFFERING
-          || state == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING;
+          || state == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING
+          || state == PlaybackStats.PLAYBACK_STATE_SUPPRESSED_BUFFERING;
     }
 
     private static boolean isInvalidJoinTransition(
         @PlaybackState int oldState, @PlaybackState int newState) {
       if (oldState != PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
           && oldState != PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND
-          && oldState != PlaybackStats.PLAYBACK_STATE_SUSPENDED) {
+          && oldState != PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD) {
         return false;
       }
       return newState != PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
           && newState != PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND
-          && newState != PlaybackStats.PLAYBACK_STATE_SUSPENDED
+          && newState != PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD
           && newState != PlaybackStats.PLAYBACK_STATE_PLAYING
           && newState != PlaybackStats.PLAYBACK_STATE_PAUSED
+          && newState != PlaybackStats.PLAYBACK_STATE_SUPPRESSED
           && newState != PlaybackStats.PLAYBACK_STATE_ENDED;
     }
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java b/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
deleted file mode 100644
index 44bcdfd..0000000
--- a/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.audio;
-
-import android.content.Context;
-import android.media.AudioFocusRequest;
-import android.media.AudioManager;
-import androidx.annotation.IntDef;
-import androidx.annotation.Nullable;
-import androidx.annotation.RequiresApi;
-import androidx.annotation.VisibleForTesting;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Log;
-import com.google.android.exoplayer2.util.Util;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
-
-/** Manages requesting and responding to changes in audio focus. */
-public final class AudioFocusManager {
-
-  /** Interface to allow AudioFocusManager to give commands to a player. */
-  public interface PlayerControl {
-    /**
-     * Called when the volume multiplier on the player should be changed.
-     *
-     * @param volumeMultiplier The new volume multiplier.
-     */
-    void setVolumeMultiplier(float volumeMultiplier);
-
-    /**
-     * Called when a command must be executed on the player.
-     *
-     * @param playerCommand The command that must be executed.
-     */
-    void executePlayerCommand(@PlayerCommand int playerCommand);
-  }
-
-  /**
-   * Player commands. One of {@link #PLAYER_COMMAND_DO_NOT_PLAY}, {@link
-   * #PLAYER_COMMAND_WAIT_FOR_CALLBACK} or {@link #PLAYER_COMMAND_PLAY_WHEN_READY}.
-   */
-  @Documented
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({
-    PLAYER_COMMAND_DO_NOT_PLAY,
-    PLAYER_COMMAND_WAIT_FOR_CALLBACK,
-    PLAYER_COMMAND_PLAY_WHEN_READY,
-  })
-  public @interface PlayerCommand {}
-  /** Do not play. */
-  public static final int PLAYER_COMMAND_DO_NOT_PLAY = -1;
-  /** Do not play now. Wait for callback to play. */
-  public static final int PLAYER_COMMAND_WAIT_FOR_CALLBACK = 0;
-  /** Play freely. */
-  public static final int PLAYER_COMMAND_PLAY_WHEN_READY = 1;
-
-  /** Audio focus state. */
-  @Documented
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({
-    AUDIO_FOCUS_STATE_LOST_FOCUS,
-    AUDIO_FOCUS_STATE_NO_FOCUS,
-    AUDIO_FOCUS_STATE_HAVE_FOCUS,
-    AUDIO_FOCUS_STATE_LOSS_TRANSIENT,
-    AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
-  })
-  private @interface AudioFocusState {}
-  /** No audio focus was held, but has been lost by another app taking it permanently. */
-  private static final int AUDIO_FOCUS_STATE_LOST_FOCUS = -1;
-  /** No audio focus is currently being held. */
-  private static final int AUDIO_FOCUS_STATE_NO_FOCUS = 0;
-  /** The requested audio focus is currently held. */
-  private static final int AUDIO_FOCUS_STATE_HAVE_FOCUS = 1;
-  /** Audio focus has been temporarily lost. */
-  private static final int AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 2;
-  /** Audio focus has been temporarily lost, but playback may continue with reduced volume. */
-  private static final int AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK = 3;
-
-  private static final String TAG = "AudioFocusManager";
-
-  private static final float VOLUME_MULTIPLIER_DUCK = 0.2f;
-  private static final float VOLUME_MULTIPLIER_DEFAULT = 1.0f;
-
-  private final AudioManager audioManager;
-  private final AudioFocusListener focusListener;
-  private final PlayerControl playerControl;
-  @Nullable private AudioAttributes audioAttributes;
-
-  @AudioFocusState private int audioFocusState;
-  @C.AudioFocusGain private int focusGain;
-  private float volumeMultiplier = VOLUME_MULTIPLIER_DEFAULT;
-
-  private @MonotonicNonNull AudioFocusRequest audioFocusRequest;
-  private boolean rebuildAudioFocusRequest;
-
-  /**
-   * Constructs an AudioFocusManager to automatically handle audio focus for a player.
-   *
-   * @param context The current context.
-   * @param playerControl A {@link PlayerControl} to handle commands from this instance.
-   */
-  public AudioFocusManager(Context context, PlayerControl playerControl) {
-    this.audioManager =
-        (AudioManager) context.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
-    this.playerControl = playerControl;
-    this.focusListener = new AudioFocusListener();
-    this.audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
-  }
-
-  /** Gets the current player volume multiplier. */
-  public float getVolumeMultiplier() {
-    return volumeMultiplier;
-  }
-
-  /**
-   * Sets audio attributes that should be used to manage audio focus.
-   *
-   * @param audioAttributes The audio attributes or {@code null} if audio focus should not be
-   *     managed automatically.
-   * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
-   * @param playerState The current player state; {@link ExoPlayer#getPlaybackState()}.
-   * @return A {@link PlayerCommand} to execute on the player.
-   */
-  @PlayerCommand
-  public int setAudioAttributes(
-      @Nullable AudioAttributes audioAttributes, boolean playWhenReady, int playerState) {
-    if (!Util.areEqual(this.audioAttributes, audioAttributes)) {
-      this.audioAttributes = audioAttributes;
-      focusGain = convertAudioAttributesToFocusGain(audioAttributes);
-
-      Assertions.checkArgument(
-          focusGain == C.AUDIOFOCUS_GAIN || focusGain == C.AUDIOFOCUS_NONE,
-          "Automatic handling of audio focus is only available for USAGE_MEDIA and USAGE_GAME.");
-      if (playWhenReady
-          && (playerState == Player.STATE_BUFFERING || playerState == Player.STATE_READY)) {
-        return requestAudioFocus();
-      }
-    }
-
-    return playerState == Player.STATE_IDLE
-        ? handleIdle(playWhenReady)
-        : handlePrepare(playWhenReady);
-  }
-
-  /**
-   * Called by a player as part of {@link ExoPlayer#prepare(MediaSource, boolean, boolean)}.
-   *
-   * @param playWhenReady The current state of {@link ExoPlayer#getPlayWhenReady()}.
-   * @return A {@link PlayerCommand} to execute on the player.
-   */
-  @PlayerCommand
-  public int handlePrepare(boolean playWhenReady) {
-    return playWhenReady ? requestAudioFocus() : PLAYER_COMMAND_DO_NOT_PLAY;
-  }
-
-  /**
-   * Called by the player as part of {@link ExoPlayer#setPlayWhenReady(boolean)}.
-   *
-   * @param playWhenReady The desired value of playWhenReady.
-   * @param playerState The current state of the player.
-   * @return A {@link PlayerCommand} to execute on the player.
-   */
-  @PlayerCommand
-  public int handleSetPlayWhenReady(boolean playWhenReady, int playerState) {
-    if (!playWhenReady) {
-      abandonAudioFocus();
-      return PLAYER_COMMAND_DO_NOT_PLAY;
-    }
-
-    return playerState == Player.STATE_IDLE ? handleIdle(playWhenReady) : requestAudioFocus();
-  }
-
-  /** Called by the player as part of {@link ExoPlayer#stop(boolean)}. */
-  public void handleStop() {
-    abandonAudioFocus(/* forceAbandon= */ true);
-  }
-
-  // Internal methods.
-
-  @VisibleForTesting
-  /* package */ AudioManager.OnAudioFocusChangeListener getFocusListener() {
-    return focusListener;
-  }
-
-  @PlayerCommand
-  private int handleIdle(boolean playWhenReady) {
-    return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
-  }
-
-  @PlayerCommand
-  private int requestAudioFocus() {
-    int focusRequestResult;
-
-    if (focusGain == C.AUDIOFOCUS_NONE) {
-      if (audioFocusState != AUDIO_FOCUS_STATE_NO_FOCUS) {
-        abandonAudioFocus(/* forceAbandon= */ true);
-      }
-      return PLAYER_COMMAND_PLAY_WHEN_READY;
-    }
-
-    if (audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
-      if (Util.SDK_INT >= 26) {
-        focusRequestResult = requestAudioFocusV26();
-      } else {
-        focusRequestResult = requestAudioFocusDefault();
-      }
-      audioFocusState =
-          focusRequestResult == AudioManager.AUDIOFOCUS_REQUEST_GRANTED
-              ? AUDIO_FOCUS_STATE_HAVE_FOCUS
-              : AUDIO_FOCUS_STATE_NO_FOCUS;
-    }
-
-    if (audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
-      return PLAYER_COMMAND_DO_NOT_PLAY;
-    }
-
-    return audioFocusState == AUDIO_FOCUS_STATE_LOSS_TRANSIENT
-        ? PLAYER_COMMAND_WAIT_FOR_CALLBACK
-        : PLAYER_COMMAND_PLAY_WHEN_READY;
-  }
-
-  private void abandonAudioFocus() {
-    abandonAudioFocus(/* forceAbandon= */ false);
-  }
-
-  private void abandonAudioFocus(boolean forceAbandon) {
-    if (focusGain == C.AUDIOFOCUS_NONE && audioFocusState == AUDIO_FOCUS_STATE_NO_FOCUS) {
-      return;
-    }
-
-    if (focusGain != C.AUDIOFOCUS_GAIN
-        || audioFocusState == AUDIO_FOCUS_STATE_LOST_FOCUS
-        || forceAbandon) {
-      if (Util.SDK_INT >= 26) {
-        abandonAudioFocusV26();
-      } else {
-        abandonAudioFocusDefault();
-      }
-      audioFocusState = AUDIO_FOCUS_STATE_NO_FOCUS;
-    }
-  }
-
-  private int requestAudioFocusDefault() {
-    return audioManager.requestAudioFocus(
-        focusListener,
-        Util.getStreamTypeForAudioUsage(Assertions.checkNotNull(audioAttributes).usage),
-        focusGain);
-  }
-
-  @RequiresApi(26)
-  private int requestAudioFocusV26() {
-    if (audioFocusRequest == null || rebuildAudioFocusRequest) {
-      AudioFocusRequest.Builder builder =
-          audioFocusRequest == null
-              ? new AudioFocusRequest.Builder(focusGain)
-              : new AudioFocusRequest.Builder(audioFocusRequest);
-
-      boolean willPauseWhenDucked = willPauseWhenDucked();
-      audioFocusRequest =
-          builder
-              .setAudioAttributes(Assertions.checkNotNull(audioAttributes).getAudioAttributesV21())
-              .setWillPauseWhenDucked(willPauseWhenDucked)
-              .setOnAudioFocusChangeListener(focusListener)
-              .build();
-
-      rebuildAudioFocusRequest = false;
-    }
-    return audioManager.requestAudioFocus(audioFocusRequest);
-  }
-
-  private void abandonAudioFocusDefault() {
-    audioManager.abandonAudioFocus(focusListener);
-  }
-
-  @RequiresApi(26)
-  private void abandonAudioFocusV26() {
-    if (audioFocusRequest != null) {
-      audioManager.abandonAudioFocusRequest(audioFocusRequest);
-    }
-  }
-
-  private boolean willPauseWhenDucked() {
-    return audioAttributes != null && audioAttributes.contentType == C.CONTENT_TYPE_SPEECH;
-  }
-
-  /**
-   * Converts {@link AudioAttributes} to one of the audio focus request.
-   *
-   * <p>This follows the class Javadoc of {@link AudioFocusRequest}.
-   *
-   * @param audioAttributes The audio attributes associated with this focus request.
-   * @return The type of audio focus gain that should be requested.
-   */
-  @C.AudioFocusGain
-  private static int convertAudioAttributesToFocusGain(@Nullable AudioAttributes audioAttributes) {
-
-    if (audioAttributes == null) {
-      // Don't handle audio focus. It may be either video only contents or developers
-      // want to have more finer grained control. (e.g. adding audio focus listener)
-      return C.AUDIOFOCUS_NONE;
-    }
-
-    switch (audioAttributes.usage) {
-        // USAGE_VOICE_COMMUNICATION_SIGNALLING is for DTMF that may happen multiple times
-        // during the phone call when AUDIOFOCUS_GAIN_TRANSIENT is requested for that.
-        // Don't request audio focus here.
-      case C.USAGE_VOICE_COMMUNICATION_SIGNALLING:
-        return C.AUDIOFOCUS_NONE;
-
-        // Javadoc says 'AUDIOFOCUS_GAIN: Examples of uses of this focus gain are for music
-        // playback, for a game or a video player'
-      case C.USAGE_GAME:
-      case C.USAGE_MEDIA:
-        return C.AUDIOFOCUS_GAIN;
-
-        // Special usages: USAGE_UNKNOWN shouldn't be used. Request audio focus to prevent
-        // multiple media playback happen at the same time.
-      case C.USAGE_UNKNOWN:
-        Log.w(
-            TAG,
-            "Specify a proper usage in the audio attributes for audio focus"
-                + " handling. Using AUDIOFOCUS_GAIN by default.");
-        return C.AUDIOFOCUS_GAIN;
-
-        // Javadoc says 'AUDIOFOCUS_GAIN_TRANSIENT: An example is for playing an alarm, or
-        // during a VoIP call'
-      case C.USAGE_ALARM:
-      case C.USAGE_VOICE_COMMUNICATION:
-        return C.AUDIOFOCUS_GAIN_TRANSIENT;
-
-        // Javadoc says 'AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK: Examples are when playing
-        // driving directions or notifications'
-      case C.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
-      case C.USAGE_ASSISTANCE_SONIFICATION:
-      case C.USAGE_NOTIFICATION:
-      case C.USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
-      case C.USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
-      case C.USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
-      case C.USAGE_NOTIFICATION_EVENT:
-      case C.USAGE_NOTIFICATION_RINGTONE:
-        return C.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
-
-        // Javadoc says 'AUDIOFOCUS_GAIN_EXCLUSIVE: This is typically used if you are doing
-        // audio recording or speech recognition'.
-        // Assistant is considered as both recording and notifying developer
-      case C.USAGE_ASSISTANT:
-        if (Util.SDK_INT >= 19) {
-          return C.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
-        } else {
-          return C.AUDIOFOCUS_GAIN_TRANSIENT;
-        }
-
-        // Special usages:
-      case C.USAGE_ASSISTANCE_ACCESSIBILITY:
-        if (audioAttributes.contentType == C.CONTENT_TYPE_SPEECH) {
-          // Voice shouldn't be interrupted by other playback.
-          return C.AUDIOFOCUS_GAIN_TRANSIENT;
-        }
-        return C.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
-      default:
-        Log.w(TAG, "Unidentified audio usage: " + audioAttributes.usage);
-        return C.AUDIOFOCUS_NONE;
-    }
-  }
-
-  // Internal audio focus listener.
-
-  private class AudioFocusListener implements AudioManager.OnAudioFocusChangeListener {
-    @Override
-    public void onAudioFocusChange(int focusChange) {
-      // Convert the platform focus change to internal state.
-      switch (focusChange) {
-        case AudioManager.AUDIOFOCUS_LOSS:
-          audioFocusState = AUDIO_FOCUS_STATE_LOST_FOCUS;
-          break;
-        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
-          audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
-          break;
-        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
-          if (willPauseWhenDucked()) {
-            audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
-          } else {
-            audioFocusState = AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK;
-          }
-          break;
-        case AudioManager.AUDIOFOCUS_GAIN:
-          audioFocusState = AUDIO_FOCUS_STATE_HAVE_FOCUS;
-          break;
-        default:
-          Log.w(TAG, "Unknown focus change type: " + focusChange);
-          // Early return.
-          return;
-      }
-
-      // Handle the internal state (change).
-      switch (audioFocusState) {
-        case AUDIO_FOCUS_STATE_NO_FOCUS:
-          // Focus was not requested; nothing to do.
-          break;
-        case AUDIO_FOCUS_STATE_LOST_FOCUS:
-          playerControl.executePlayerCommand(PLAYER_COMMAND_DO_NOT_PLAY);
-          abandonAudioFocus(/* forceAbandon= */ true);
-          break;
-        case AUDIO_FOCUS_STATE_LOSS_TRANSIENT:
-          playerControl.executePlayerCommand(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
-          break;
-        case AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK:
-          // Volume will be adjusted by the code below.
-          break;
-        case AUDIO_FOCUS_STATE_HAVE_FOCUS:
-          playerControl.executePlayerCommand(PLAYER_COMMAND_PLAY_WHEN_READY);
-          break;
-        default:
-          throw new IllegalStateException("Unknown audio focus state: " + audioFocusState);
-      }
-
-      float volumeMultiplier =
-          (audioFocusState == AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK)
-              ? AudioFocusManager.VOLUME_MULTIPLIER_DUCK
-              : AudioFocusManager.VOLUME_MULTIPLIER_DEFAULT;
-      if (AudioFocusManager.this.volumeMultiplier != volumeMultiplier) {
-        AudioFocusManager.this.volumeMultiplier = volumeMultiplier;
-        playerControl.setVolumeMultiplier(volumeMultiplier);
-      }
-    }
-  }
-}
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
index 1bf141c..f75b2cd 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.audio;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
@@ -23,24 +25,56 @@ import java.nio.ByteOrder;
  * Interface for audio processors, which take audio data as input and transform it, potentially
  * modifying its channel count, encoding and/or sample rate.
  *
- * <p>Call {@link #configure(int, int, int)} to configure the processor to receive input audio, then
- * call {@link #isActive()} to determine whether the processor is active in the new configuration.
- * {@link #queueInput(ByteBuffer)}, {@link #getOutputChannelCount()}, {@link #getOutputEncoding()}
- * and {@link #getOutputSampleRateHz()} may only be called if the processor is active. Call {@link
- * #reset()} to reset the processor to its unconfigured state and release any resources.
- *
  * <p>In addition to being able to modify the format of audio, implementations may allow parameters
  * to be set that affect the output audio and whether the processor is active/inactive.
  */
 public interface AudioProcessor {
 
+  /** PCM audio format that may be handled by an audio processor. */
+  final class AudioFormat {
+    public static final AudioFormat NOT_SET =
+        new AudioFormat(
+            /* sampleRate= */ Format.NO_VALUE,
+            /* channelCount= */ Format.NO_VALUE,
+            /* encoding= */ Format.NO_VALUE);
+
+    /** The sample rate in Hertz. */
+    public final int sampleRate;
+    /** The number of interleaved channels. */
+    public final int channelCount;
+    /** The type of linear PCM encoding. */
+    @C.PcmEncoding public final int encoding;
+    /** The number of bytes used to represent one audio frame. */
+    public final int bytesPerFrame;
+
+    public AudioFormat(int sampleRate, int channelCount, @C.PcmEncoding int encoding) {
+      this.sampleRate = sampleRate;
+      this.channelCount = channelCount;
+      this.encoding = encoding;
+      bytesPerFrame =
+          Util.isEncodingLinearPcm(encoding)
+              ? Util.getPcmFrameSize(encoding, channelCount)
+              : Format.NO_VALUE;
+    }
+
+    @Override
+    public String toString() {
+      return "AudioFormat["
+          + "sampleRate="
+          + sampleRate
+          + ", channelCount="
+          + channelCount
+          + ", encoding="
+          + encoding
+          + ']';
+    }
+  }
+
   /** Exception thrown when a processor can't be configured for a given input audio format. */
-  final class UnhandledFormatException extends Exception {
+  final class UnhandledAudioFormatException extends Exception {
 
-    public UnhandledFormatException(
-        int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
-      super("Unhandled format: " + sampleRateHz + " Hz, " + channelCount + " channels in encoding "
-          + encoding);
+    public UnhandledAudioFormatException(AudioFormat inputAudioFormat) {
+      super("Unhandled format: " + inputAudioFormat);
     }
 
   }
@@ -50,48 +84,25 @@ public interface AudioProcessor {
 
   /**
    * Configures the processor to process input audio with the specified format. After calling this
-   * method, call {@link #isActive()} to determine whether the audio processor is active.
+   * method, call {@link #isActive()} to determine whether the audio processor is active. Returns
+   * the configured output audio format if this instance is active.
    *
-   * <p>If the audio processor is active after configuration, call {@link #getOutputSampleRateHz()},
-   * {@link #getOutputChannelCount()} and {@link #getOutputEncoding()} to get its new output format.
+   * <p>After calling this method, it is necessary to {@link #flush()} the processor to apply the
+   * new configuration. Before applying the new configuration, it is safe to queue input and get
+   * output in the old input/output formats. Call {@link #queueEndOfStream()} when no more input
+   * will be supplied in the old input format.
    *
-   * <p>If this method returns {@code true}, it is necessary to {@link #flush()} the processor
-   * before queueing more data, but you can (optionally) first drain output in the previous
-   * configuration by calling {@link #queueEndOfStream()} and {@link #getOutput()}. If this method
-   * returns {@code false}, it is safe to queue new input immediately.
-   *
-   * @param sampleRateHz The sample rate of input audio in Hz.
-   * @param channelCount The number of interleaved channels in input audio.
-   * @param encoding The encoding of input audio.
-   * @return Whether the processor must be {@link #flush() flushed} before queueing more input.
-   * @throws UnhandledFormatException Thrown if the specified format can't be handled as input.
+   * @param inputAudioFormat The format of audio that will be queued after the next call to {@link
+   *     #flush()}.
+   * @return The configured output audio format if this instance is {@link #isActive() active}.
+   * @throws UnhandledAudioFormatException Thrown if the specified format can't be handled as input.
    */
-  boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
-      throws UnhandledFormatException;
+  AudioFormat configure(AudioFormat inputAudioFormat) throws UnhandledAudioFormatException;
 
   /** Returns whether the processor is configured and will process input buffers. */
   boolean isActive();
 
   /**
-   * Returns the number of audio channels in the data output by the processor. The value may change
-   * as a result of calling {@link #configure(int, int, int)}.
-   */
-  int getOutputChannelCount();
-
-  /**
-   * Returns the audio encoding used in the data output by the processor. The value may change as a
-   * result of calling {@link #configure(int, int, int)}.
-   */
-  @C.PcmEncoding
-  int getOutputEncoding();
-
-  /**
-   * Returns the sample rate of audio output by the processor, in hertz. The value may change as a
-   * result of calling {@link #configure(int, int, int)}.
-   */
-  int getOutputSampleRateHz();
-
-  /**
    * Queues audio data between the position and limit of the input {@code buffer} for processing.
    * {@code buffer} must be a direct byte buffer with native byte order. Its contents are treated as
    * read-only. Its position will be advanced by the number of bytes consumed (which may be zero).
@@ -132,6 +143,6 @@ public interface AudioProcessor {
    */
   void flush();
 
-  /** Resets the processor to its unconfigured state. */
+  /** Resets the processor to its unconfigured state, releasing any resources. */
   void reset();
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java b/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
index 042738b..bf5822c 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Handler;
 import android.os.SystemClock;
 import androidx.annotation.Nullable;
@@ -105,8 +107,8 @@ public interface AudioRendererEventListener {
      * Invokes {@link AudioRendererEventListener#onAudioEnabled(DecoderCounters)}.
      */
     public void enabled(final DecoderCounters decoderCounters) {
-      if (listener != null) {
-        handler.post(() -> listener.onAudioEnabled(decoderCounters));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onAudioEnabled(decoderCounters));
       }
     }
 
@@ -115,11 +117,12 @@ public interface AudioRendererEventListener {
      */
     public void decoderInitialized(final String decoderName,
         final long initializedTimestampMs, final long initializationDurationMs) {
-      if (listener != null) {
+      if (handler != null) {
         handler.post(
             () ->
-                listener.onAudioDecoderInitialized(
-                    decoderName, initializedTimestampMs, initializationDurationMs));
+                castNonNull(listener)
+                    .onAudioDecoderInitialized(
+                        decoderName, initializedTimestampMs, initializationDurationMs));
       }
     }
 
@@ -127,8 +130,8 @@ public interface AudioRendererEventListener {
      * Invokes {@link AudioRendererEventListener#onAudioInputFormatChanged(Format)}.
      */
     public void inputFormatChanged(final Format format) {
-      if (listener != null) {
-        handler.post(() -> listener.onAudioInputFormatChanged(format));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onAudioInputFormatChanged(format));
       }
     }
 
@@ -137,9 +140,11 @@ public interface AudioRendererEventListener {
      */
     public void audioTrackUnderrun(final int bufferSize, final long bufferSizeMs,
         final long elapsedSinceLastFeedMs) {
-      if (listener != null) {
+      if (handler != null) {
         handler.post(
-            () -> listener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs));
+            () ->
+                castNonNull(listener)
+                    .onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs));
       }
     }
 
@@ -148,11 +153,11 @@ public interface AudioRendererEventListener {
      */
     public void disabled(final DecoderCounters counters) {
       counters.ensureUpdated();
-      if (listener != null) {
+      if (handler != null) {
         handler.post(
             () -> {
               counters.ensureUpdated();
-              listener.onAudioDisabled(counters);
+              castNonNull(listener).onAudioDisabled(counters);
             });
       }
     }
@@ -161,11 +166,9 @@ public interface AudioRendererEventListener {
      * Invokes {@link AudioRendererEventListener#onAudioSessionId(int)}.
      */
     public void audioSessionId(final int audioSessionId) {
-      if (listener != null) {
-        handler.post(() -> listener.onAudioSessionId(audioSessionId));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onAudioSessionId(audioSessionId));
       }
     }
-
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java
index a3a85bb..41cb436 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/BaseAudioProcessor.java
@@ -16,24 +16,23 @@
 package com.google.android.exoplayer2.audio;
 
 import androidx.annotation.CallSuper;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
 /**
  * Base class for audio processors that keep an output buffer and an internal buffer that is reused
- * whenever input is queued.
+ * whenever input is queued. Subclasses should override {@link #onConfigure(AudioFormat)} to return
+ * the output audio format for the processor if it's active.
  */
 public abstract class BaseAudioProcessor implements AudioProcessor {
 
-  /** The configured input sample rate, in Hertz, or {@link Format#NO_VALUE} if not configured. */
-  protected int sampleRateHz;
-  /** The configured input channel count, or {@link Format#NO_VALUE} if not configured. */
-  protected int channelCount;
-  /** The configured input encoding, or {@link Format#NO_VALUE} if not configured. */
-  @C.PcmEncoding protected int encoding;
+  /** The current input audio format. */
+  protected AudioFormat inputAudioFormat;
+  /** The current output audio format. */
+  protected AudioFormat outputAudioFormat;
 
+  private AudioFormat pendingInputAudioFormat;
+  private AudioFormat pendingOutputAudioFormat;
   private ByteBuffer buffer;
   private ByteBuffer outputBuffer;
   private boolean inputEnded;
@@ -41,29 +40,23 @@ public abstract class BaseAudioProcessor implements AudioProcessor {
   public BaseAudioProcessor() {
     buffer = EMPTY_BUFFER;
     outputBuffer = EMPTY_BUFFER;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
-    encoding = Format.NO_VALUE;
+    pendingInputAudioFormat = AudioFormat.NOT_SET;
+    pendingOutputAudioFormat = AudioFormat.NOT_SET;
+    inputAudioFormat = AudioFormat.NOT_SET;
+    outputAudioFormat = AudioFormat.NOT_SET;
   }
 
   @Override
-  public boolean isActive() {
-    return sampleRateHz != Format.NO_VALUE;
-  }
-
-  @Override
-  public int getOutputChannelCount() {
-    return channelCount;
-  }
-
-  @Override
-  public int getOutputEncoding() {
-    return encoding;
+  public final AudioFormat configure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    pendingInputAudioFormat = inputAudioFormat;
+    pendingOutputAudioFormat = onConfigure(inputAudioFormat);
+    return isActive() ? pendingOutputAudioFormat : AudioFormat.NOT_SET;
   }
 
   @Override
-  public int getOutputSampleRateHz() {
-    return sampleRateHz;
+  public boolean isActive() {
+    return pendingOutputAudioFormat != AudioFormat.NOT_SET;
   }
 
   @Override
@@ -91,6 +84,8 @@ public abstract class BaseAudioProcessor implements AudioProcessor {
   public final void flush() {
     outputBuffer = EMPTY_BUFFER;
     inputEnded = false;
+    inputAudioFormat = pendingInputAudioFormat;
+    outputAudioFormat = pendingOutputAudioFormat;
     onFlush();
   }
 
@@ -98,26 +93,13 @@ public abstract class BaseAudioProcessor implements AudioProcessor {
   public final void reset() {
     flush();
     buffer = EMPTY_BUFFER;
-    sampleRateHz = Format.NO_VALUE;
-    channelCount = Format.NO_VALUE;
-    encoding = Format.NO_VALUE;
+    pendingInputAudioFormat = AudioFormat.NOT_SET;
+    pendingOutputAudioFormat = AudioFormat.NOT_SET;
+    inputAudioFormat = AudioFormat.NOT_SET;
+    outputAudioFormat = AudioFormat.NOT_SET;
     onReset();
   }
 
-  /** Sets the input format of this processor, returning whether the input format has changed. */
-  protected final boolean setInputFormat(
-      int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
-    if (sampleRateHz == this.sampleRateHz
-        && channelCount == this.channelCount
-        && encoding == this.encoding) {
-      return false;
-    }
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
-    this.encoding = encoding;
-    return true;
-  }
-
   /**
    * Replaces the current output buffer with a buffer of at least {@code count} bytes and returns
    * it. Callers should write to the returned buffer then {@link ByteBuffer#flip()} it so it can be
@@ -138,6 +120,12 @@ public abstract class BaseAudioProcessor implements AudioProcessor {
     return outputBuffer.hasRemaining();
   }
 
+  /** Called when the processor is configured for a new input format. */
+  protected AudioFormat onConfigure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    return AudioFormat.NOT_SET;
+  }
+
   /** Called when the end-of-stream is queued to the processor. */
   protected void onQueueEndOfStream() {
     // Do nothing.
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
index ea15532..4fb6af1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
@@ -19,22 +19,20 @@ import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.nio.ByteBuffer;
-import java.util.Arrays;
 
 /**
  * An {@link AudioProcessor} that applies a mapping from input channels onto specified output
  * channels. This can be used to reorder, duplicate or discard channels.
  */
+@SuppressWarnings("nullness:initialization.fields.uninitialized")
 /* package */ final class ChannelMappingAudioProcessor extends BaseAudioProcessor {
 
   @Nullable private int[] pendingOutputChannels;
-
-  private boolean active;
   @Nullable private int[] outputChannels;
 
   /**
-   * Resets the channel mapping. After calling this method, call {@link #configure(int, int, int)}
-   * to start using the new channel map.
+   * Resets the channel mapping. After calling this method, call {@link #configure(AudioFormat)} to
+   * start using the new channel map.
    *
    * @param outputChannels The mapping from input to output channel indices, or {@code null} to
    *     leave the input unchanged.
@@ -45,42 +43,28 @@ import java.util.Arrays;
   }
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
-      throws UnhandledFormatException {
-    boolean outputChannelsChanged = !Arrays.equals(pendingOutputChannels, outputChannels);
-    outputChannels = pendingOutputChannels;
-
-    int[] outputChannels = this.outputChannels;
+  public AudioFormat onConfigure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    @Nullable int[] outputChannels = pendingOutputChannels;
     if (outputChannels == null) {
-      active = false;
-      return outputChannelsChanged;
-    }
-    if (encoding != C.ENCODING_PCM_16BIT) {
-      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+      return AudioFormat.NOT_SET;
     }
-    if (!outputChannelsChanged && !setInputFormat(sampleRateHz, channelCount, encoding)) {
-      return false;
+
+    if (inputAudioFormat.encoding != C.ENCODING_PCM_16BIT) {
+      throw new UnhandledAudioFormatException(inputAudioFormat);
     }
 
-    active = channelCount != outputChannels.length;
+    boolean active = inputAudioFormat.channelCount != outputChannels.length;
     for (int i = 0; i < outputChannels.length; i++) {
       int channelIndex = outputChannels[i];
-      if (channelIndex >= channelCount) {
-        throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+      if (channelIndex >= inputAudioFormat.channelCount) {
+        throw new UnhandledAudioFormatException(inputAudioFormat);
       }
       active |= (channelIndex != i);
     }
-    return true;
-  }
-
-  @Override
-  public boolean isActive() {
-    return active;
-  }
-
-  @Override
-  public int getOutputChannelCount() {
-    return outputChannels == null ? channelCount : outputChannels.length;
+    return active
+        ? new AudioFormat(inputAudioFormat.sampleRate, outputChannels.length, C.ENCODING_PCM_16BIT)
+        : AudioFormat.NOT_SET;
   }
 
   @Override
@@ -88,24 +72,28 @@ import java.util.Arrays;
     int[] outputChannels = Assertions.checkNotNull(this.outputChannels);
     int position = inputBuffer.position();
     int limit = inputBuffer.limit();
-    int frameCount = (limit - position) / (2 * channelCount);
-    int outputSize = frameCount * outputChannels.length * 2;
+    int frameCount = (limit - position) / inputAudioFormat.bytesPerFrame;
+    int outputSize = frameCount * outputAudioFormat.bytesPerFrame;
     ByteBuffer buffer = replaceOutputBuffer(outputSize);
     while (position < limit) {
       for (int channelIndex : outputChannels) {
         buffer.putShort(inputBuffer.getShort(position + 2 * channelIndex));
       }
-      position += channelCount * 2;
+      position += inputAudioFormat.bytesPerFrame;
     }
     inputBuffer.position(limit);
     buffer.flip();
   }
 
   @Override
+  protected void onFlush() {
+    outputChannels = pendingOutputChannels;
+  }
+
+  @Override
   protected void onReset() {
     outputChannels = null;
     pendingOutputChannels = null;
-    active = false;
   }
 
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 65d9973..27823e3 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -27,6 +27,7 @@ import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.audio.AudioProcessor.UnhandledAudioFormatException;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
@@ -246,7 +247,7 @@ public final class DefaultAudioSink implements AudioSink {
   private final ArrayDeque<PlaybackParametersCheckpoint> playbackParametersCheckpoints;
 
   @Nullable private Listener listener;
-  /** Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}). */
+  /** Used to keep the audio session active on pre-V21 builds (see {@link #initialize(long)}). */
   @Nullable private AudioTrack keepSessionIdAudioTrack;
 
   @Nullable private Configuration pendingConfiguration;
@@ -432,22 +433,25 @@ public final class DefaultAudioSink implements AudioSink {
         shouldConvertHighResIntPcmToFloat
             ? toFloatPcmAvailableAudioProcessors
             : toIntPcmAvailableAudioProcessors;
-    boolean flushAudioProcessors = false;
     if (processingEnabled) {
       trimmingAudioProcessor.setTrimFrameCount(trimStartFrames, trimEndFrames);
       channelMappingAudioProcessor.setChannelMap(outputChannels);
+      AudioProcessor.AudioFormat inputAudioFormat =
+          new AudioProcessor.AudioFormat(sampleRate, channelCount, encoding);
+      AudioProcessor.AudioFormat outputAudioFormat = inputAudioFormat;
       for (AudioProcessor audioProcessor : availableAudioProcessors) {
         try {
-          flushAudioProcessors |= audioProcessor.configure(sampleRate, channelCount, encoding);
-        } catch (AudioProcessor.UnhandledFormatException e) {
+          outputAudioFormat = audioProcessor.configure(inputAudioFormat);
+        } catch (UnhandledAudioFormatException e) {
           throw new ConfigurationException(e);
         }
         if (audioProcessor.isActive()) {
-          channelCount = audioProcessor.getOutputChannelCount();
-          sampleRate = audioProcessor.getOutputSampleRateHz();
-          encoding = audioProcessor.getOutputEncoding();
+          inputAudioFormat = outputAudioFormat;
         }
       }
+      sampleRate = outputAudioFormat.sampleRate;
+      channelCount = outputAudioFormat.channelCount;
+      encoding = outputAudioFormat.encoding;
     }
 
     int outputChannelConfig = getChannelConfig(channelCount, isInputPcm);
@@ -473,11 +477,7 @@ public final class DefaultAudioSink implements AudioSink {
             processingEnabled,
             canApplyPlaybackParameters,
             availableAudioProcessors);
-    // If we have a pending configuration already, we always drain audio processors as the preceding
-    // configuration may have required it (even if this one doesn't).
-    boolean drainAudioProcessors = flushAudioProcessors || this.pendingConfiguration != null;
-    if (isInitialized()
-        && (!pendingConfiguration.canReuseAudioTrack(configuration) || drainAudioProcessors)) {
+    if (isInitialized()) {
       this.pendingConfiguration = pendingConfiguration;
     } else {
       configuration = pendingConfiguration;
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
index 2274d53..a75e675 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.audio;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 
@@ -29,27 +30,21 @@ import java.nio.ByteBuffer;
   private static final double PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR = 1.0 / 0x7FFFFFFF;
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
-      throws UnhandledFormatException {
-    if (!Util.isEncodingHighResolutionIntegerPcm(encoding)) {
-      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+  public AudioFormat onConfigure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    if (!Util.isEncodingHighResolutionIntegerPcm(inputAudioFormat.encoding)) {
+      throw new UnhandledAudioFormatException(inputAudioFormat);
     }
-    return setInputFormat(sampleRateHz, channelCount, encoding);
-  }
-
-  @Override
-  public boolean isActive() {
-    return Util.isEncodingHighResolutionIntegerPcm(encoding);
-  }
-
-  @Override
-  public int getOutputEncoding() {
-    return C.ENCODING_PCM_FLOAT;
+    return Util.isEncodingHighResolutionIntegerPcm(inputAudioFormat.encoding)
+        ? new AudioFormat(
+            inputAudioFormat.sampleRate, inputAudioFormat.channelCount, C.ENCODING_PCM_FLOAT)
+        : AudioFormat.NOT_SET;
   }
 
   @Override
   public void queueInput(ByteBuffer inputBuffer) {
-    boolean isInput32Bit = encoding == C.ENCODING_PCM_32BIT;
+    Assertions.checkState(Util.isEncodingHighResolutionIntegerPcm(inputAudioFormat.encoding));
+    boolean isInput32Bit = inputAudioFormat.encoding == C.ENCODING_PCM_32BIT;
     int position = inputBuffer.position();
     int limit = inputBuffer.limit();
     int size = limit - position;
@@ -65,7 +60,7 @@ import java.nio.ByteBuffer;
                 | ((inputBuffer.get(i + 3) & 0xFF) << 24);
         writePcm32BitFloat(pcm32BitInteger, buffer);
       }
-    } else {
+    } else { // Input is 24-bit PCM.
       for (int i = position; i < limit; i += 3) {
         int pcm32BitInteger =
             ((inputBuffer.get(i) & 0xFF) << 8)
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 34f8363..096f4cc 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -31,6 +31,7 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.PlayerMessage.Target;
+import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener.EventDispatcher;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -41,6 +42,7 @@ import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.mediacodec.MediaFormatUtil;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -88,10 +90,7 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   private boolean codecNeedsDiscardChannelsWorkaround;
   private boolean codecNeedsEosBufferTimestampWorkaround;
   private android.media.MediaFormat passthroughMediaFormat;
-  private @C.Encoding int pcmEncoding;
-  private int channelCount;
-  private int encoderDelay;
-  private int encoderPadding;
+  @Nullable private Format inputFormat;
   private long currentPositionUs;
   private boolean allowFirstBufferPositionDiscontinuity;
   private boolean allowPositionDiscontinuity;
@@ -102,6 +101,7 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
    */
+  @SuppressWarnings("deprecation")
   public MediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector) {
     this(
         context,
@@ -120,7 +120,12 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @deprecated Use {@link #MediaCodecAudioRenderer(Context, MediaCodecSelector, boolean, Handler,
+   *     AudioRendererEventListener, AudioSink)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public MediaCodecAudioRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -142,6 +147,7 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
+  @SuppressWarnings("deprecation")
   public MediaCodecAudioRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -169,7 +175,12 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link #MediaCodecAudioRenderer(Context, MediaCodecSelector, boolean, Handler,
+   *     AudioRendererEventListener, AudioSink)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public MediaCodecAudioRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -204,7 +215,12 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    *     default capabilities (no encoded audio passthrough support) should be assumed.
    * @param audioProcessors Optional {@link AudioProcessor}s that will process PCM audio before
    *     output.
+   * @deprecated Use {@link #MediaCodecAudioRenderer(Context, MediaCodecSelector, boolean, Handler,
+   *     AudioRendererEventListener, AudioSink)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public MediaCodecAudioRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -238,7 +254,12 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioSink The sink to which audio will be output.
+   * @deprecated Use {@link #MediaCodecAudioRenderer(Context, MediaCodecSelector, boolean, Handler,
+   *     AudioRendererEventListener, AudioSink)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public MediaCodecAudioRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -261,6 +282,36 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioSink The sink to which audio will be output.
+   */
+  @SuppressWarnings("deprecation")
+  public MediaCodecAudioRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      boolean enableDecoderFallback,
+      @Nullable Handler eventHandler,
+      @Nullable AudioRendererEventListener eventListener,
+      AudioSink audioSink) {
+    this(
+        context,
+        mediaCodecSelector,
+        /* drmSessionManager= */ null,
+        /* playClearSamplesWithoutKeys= */ false,
+        enableDecoderFallback,
+        eventHandler,
+        eventListener,
+        audioSink);
+  }
+
+  /**
+   * @param context A context.
+   * @param mediaCodecSelector A decoder selector.
    * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
    *     content is not required.
    * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
@@ -275,7 +326,11 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioSink The sink to which audio will be output.
+   * @deprecated Use {@link #MediaCodecAudioRenderer(Context, MediaCodecSelector, boolean, Handler,
+   *     AudioRendererEventListener, AudioSink)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
   public MediaCodecAudioRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -301,6 +356,7 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   }
 
   @Override
+  @Capabilities
   protected int supportsFormat(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
@@ -308,8 +364,9 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
       throws DecoderQueryException {
     String mimeType = format.sampleMimeType;
     if (!MimeTypes.isAudio(mimeType)) {
-      return FORMAT_UNSUPPORTED_TYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
     }
+    @TunnelingSupport
     int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     boolean supportsFormatDrm =
         format.drmInitData == null
@@ -319,38 +376,45 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
     if (supportsFormatDrm
         && allowPassthrough(format.channelCount, mimeType)
         && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
-      return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
+      return RendererCapabilities.create(FORMAT_HANDLED, ADAPTIVE_NOT_SEAMLESS, tunnelingSupport);
     }
     if ((MimeTypes.AUDIO_RAW.equals(mimeType)
             && !audioSink.supportsOutput(format.channelCount, format.pcmEncoding))
         || !audioSink.supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       // Assume the decoder outputs 16-bit PCM, unless the input is raw.
-      return FORMAT_UNSUPPORTED_SUBTYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_SUBTYPE);
     }
     List<MediaCodecInfo> decoderInfos =
         getDecoderInfos(mediaCodecSelector, format, /* requiresSecureDecoder= */ false);
     if (decoderInfos.isEmpty()) {
-      return FORMAT_UNSUPPORTED_SUBTYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_SUBTYPE);
     }
     if (!supportsFormatDrm) {
-      return FORMAT_UNSUPPORTED_DRM;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_DRM);
     }
     // Check capabilities for the first decoder in the list, which takes priority.
     MediaCodecInfo decoderInfo = decoderInfos.get(0);
     boolean isFormatSupported = decoderInfo.isFormatSupported(format);
+    @AdaptiveSupport
     int adaptiveSupport =
         isFormatSupported && decoderInfo.isSeamlessAdaptationSupported(format)
             ? ADAPTIVE_SEAMLESS
             : ADAPTIVE_NOT_SEAMLESS;
+    @FormatSupport
     int formatSupport = isFormatSupported ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return adaptiveSupport | tunnelingSupport | formatSupport;
+    return RendererCapabilities.create(formatSupport, adaptiveSupport, tunnelingSupport);
   }
 
   @Override
   protected List<MediaCodecInfo> getDecoderInfos(
       MediaCodecSelector mediaCodecSelector, Format format, boolean requiresSecureDecoder)
       throws DecoderQueryException {
-    if (allowPassthrough(format.channelCount, format.sampleMimeType)) {
+    @Nullable String mimeType = format.sampleMimeType;
+    if (mimeType == null) {
+      return Collections.emptyList();
+    }
+    if (allowPassthrough(format.channelCount, mimeType)) {
+      @Nullable
       MediaCodecInfo passthroughDecoderInfo = mediaCodecSelector.getPassthroughDecoderInfo();
       if (passthroughDecoderInfo != null) {
         return Collections.singletonList(passthroughDecoderInfo);
@@ -358,9 +422,9 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
     }
     List<MediaCodecInfo> decoderInfos =
         mediaCodecSelector.getDecoderInfos(
-            format.sampleMimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
+            mimeType, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
     decoderInfos = MediaCodecUtil.getDecoderInfosSortedByFormatSupport(decoderInfos, format);
-    if (MimeTypes.AUDIO_E_AC3_JOC.equals(format.sampleMimeType)) {
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
       // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
       List<MediaCodecInfo> decoderInfosWithEac3 = new ArrayList<>(decoderInfos);
       decoderInfosWithEac3.addAll(
@@ -426,14 +490,37 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
     } else if (codecInfo.isSeamlessAdaptationSupported(
         oldFormat, newFormat, /* isNewFormatComplete= */ true)) {
       return KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION;
-    } else if (areCodecConfigurationCompatible(oldFormat, newFormat)) {
+    } else if (canKeepCodecWithFlush(oldFormat, newFormat)) {
       return KEEP_CODEC_RESULT_YES_WITH_FLUSH;
     } else {
       return KEEP_CODEC_RESULT_NO;
     }
   }
 
+  /**
+   * Returns whether the codec can be flushed and reused when switching to a new format. Reuse is
+   * generally possible when the codec would be configured in an identical way after the format
+   * change (excluding {@link MediaFormat#KEY_MAX_INPUT_SIZE} and configuration that does not come
+   * from the {@link Format}).
+   *
+   * @param oldFormat The first format.
+   * @param newFormat The second format.
+   * @return Whether the codec can be flushed and reused when switching to a new format.
+   */
+  protected boolean canKeepCodecWithFlush(Format oldFormat, Format newFormat) {
+    // Flush and reuse the codec if the audio format and initialization data matches. For Opus, we
+    // don't flush and reuse the codec because the decoder may discard samples after flushing, which
+    // would result in audio being dropped just after a stream change (see [Internal: b/143450854]).
+    return Util.areEqual(oldFormat.sampleMimeType, newFormat.sampleMimeType)
+        && oldFormat.channelCount == newFormat.channelCount
+        && oldFormat.sampleRate == newFormat.sampleRate
+        && oldFormat.pcmEncoding == newFormat.pcmEncoding
+        && oldFormat.initializationDataEquals(newFormat)
+        && !MimeTypes.AUDIO_OPUS.equals(oldFormat.sampleMimeType);
+  }
+
   @Override
+  @Nullable
   public MediaClock getMediaClock() {
     return this;
   }
@@ -462,38 +549,31 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   @Override
   protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {
     super.onInputFormatChanged(formatHolder);
-    Format newFormat = formatHolder.format;
-    eventDispatcher.inputFormatChanged(newFormat);
-    // If the input format is anything other than PCM then we assume that the audio decoder will
-    // output 16-bit PCM.
-    pcmEncoding = MimeTypes.AUDIO_RAW.equals(newFormat.sampleMimeType) ? newFormat.pcmEncoding
-        : C.ENCODING_PCM_16BIT;
-    channelCount = newFormat.channelCount;
-    encoderDelay = newFormat.encoderDelay;
-    encoderPadding = newFormat.encoderPadding;
+    inputFormat = formatHolder.format;
+    eventDispatcher.inputFormatChanged(inputFormat);
   }
 
   @Override
-  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
+  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputMediaFormat)
       throws ExoPlaybackException {
     @C.Encoding int encoding;
-    MediaFormat format;
+    MediaFormat mediaFormat;
     if (passthroughMediaFormat != null) {
-      format = passthroughMediaFormat;
+      mediaFormat = passthroughMediaFormat;
       encoding =
           getPassthroughEncoding(
-              format.getInteger(MediaFormat.KEY_CHANNEL_COUNT),
-              format.getString(MediaFormat.KEY_MIME));
+              mediaFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT),
+              mediaFormat.getString(MediaFormat.KEY_MIME));
     } else {
-      format = outputFormat;
-      encoding = pcmEncoding;
+      mediaFormat = outputMediaFormat;
+      encoding = getPcmEncoding(inputFormat);
     }
-    int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
-    int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
+    int channelCount = mediaFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
+    int sampleRate = mediaFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE);
     int[] channelMap;
-    if (codecNeedsDiscardChannelsWorkaround && channelCount == 6 && this.channelCount < 6) {
-      channelMap = new int[this.channelCount];
-      for (int i = 0; i < this.channelCount; i++) {
+    if (codecNeedsDiscardChannelsWorkaround && channelCount == 6 && inputFormat.channelCount < 6) {
+      channelMap = new int[inputFormat.channelCount];
+      for (int i = 0; i < inputFormat.channelCount; i++) {
         channelMap[i] = i;
       }
     } else {
@@ -501,10 +581,17 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
     }
 
     try {
-      audioSink.configure(encoding, channelCount, sampleRate, 0, channelMap, encoderDelay,
-          encoderPadding);
+      audioSink.configure(
+          encoding,
+          channelCount,
+          sampleRate,
+          0,
+          channelMap,
+          inputFormat.encoderDelay,
+          inputFormat.encoderPadding);
     } catch (AudioSink.ConfigurationException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      // TODO(internal: b/145658993) Use outputFormat instead.
+      throw createRendererException(e, inputFormat);
     }
   }
 
@@ -515,7 +602,8 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   @C.Encoding
   protected int getPassthroughEncoding(int channelCount, String mimeType) {
     if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
-      if (audioSink.supportsOutput(channelCount, C.ENCODING_E_AC3_JOC)) {
+      // E-AC3 JOC is object-based so the output channel count is arbitrary.
+      if (audioSink.supportsOutput(/* channelCount= */ Format.NO_VALUE, C.ENCODING_E_AC3_JOC)) {
         return MimeTypes.getEncoding(MimeTypes.AUDIO_E_AC3_JOC);
       }
       // E-AC3 receivers can decode JOC streams, but in 2-D rather than 3-D, so try to fall back.
@@ -730,7 +818,8 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
         return true;
       }
     } catch (AudioSink.InitializationException | AudioSink.WriteException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      // TODO(internal: b/145658993) Use outputFormat instead.
+      throw createRendererException(e, inputFormat);
     }
     return false;
   }
@@ -740,7 +829,8 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
     try {
       audioSink.playToEndOfStream();
     } catch (AudioSink.WriteException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      // TODO(internal: b/145658993) Use outputFormat instead.
+      throw createRendererException(e, inputFormat);
     }
   }
 
@@ -769,7 +859,7 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
    * will allow possible adaptation to other compatible formats in {@code streamFormats}.
    *
    * @param codecInfo A {@link MediaCodecInfo} describing the decoder.
-   * @param format The format for which the codec is being configured.
+   * @param format The {@link Format} for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return A suitable maximum input size.
    */
@@ -791,10 +881,10 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   }
 
   /**
-   * Returns a maximum input buffer size for a given format.
+   * Returns a maximum input buffer size for a given {@link Format}.
    *
    * @param codecInfo A {@link MediaCodecInfo} describing the decoder.
-   * @param format The format.
+   * @param format The {@link Format}.
    * @return A maximum input buffer size in bytes, or {@link Format#NO_VALUE} if a maximum could not
    *     be determined.
    */
@@ -812,33 +902,15 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
   }
 
   /**
-   * Returns whether two {@link Format}s will cause the same codec to be configured in an identical
-   * way, excluding {@link MediaFormat#KEY_MAX_INPUT_SIZE} and configuration that does not come from
-   * the {@link Format}.
-   *
-   * @param oldFormat The first format.
-   * @param newFormat The second format.
-   * @return Whether the two formats will cause a codec to be configured in an identical way,
-   *     excluding {@link MediaFormat#KEY_MAX_INPUT_SIZE} and configuration that does not come from
-   *     the {@link Format}.
-   */
-  protected boolean areCodecConfigurationCompatible(Format oldFormat, Format newFormat) {
-    return Util.areEqual(oldFormat.sampleMimeType, newFormat.sampleMimeType)
-        && oldFormat.channelCount == newFormat.channelCount
-        && oldFormat.sampleRate == newFormat.sampleRate
-        && oldFormat.initializationDataEquals(newFormat);
-  }
-
-  /**
    * Returns the framework {@link MediaFormat} that can be used to configure a {@link MediaCodec}
    * for decoding the given {@link Format} for playback.
    *
-   * @param format The format of the media.
+   * @param format The {@link Format} of the media.
    * @param codecMimeType The MIME type handled by the codec.
    * @param codecMaxInputSize The maximum input size supported by the codec.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
-   * @return The framework media format.
+   * @return The framework {@link MediaFormat}.
    */
   @SuppressLint("InlinedApi")
   protected MediaFormat getMediaFormat(
@@ -920,6 +992,15 @@ public class MediaCodecAudioRenderer extends MediaCodecRenderer implements Media
             || Util.DEVICE.startsWith("ms01"));
   }
 
+  @C.Encoding
+  private static int getPcmEncoding(Format format) {
+    // If the format is anything other than PCM then we assume that the audio decoder will output
+    // 16-bit PCM.
+    return MimeTypes.AUDIO_RAW.equals(format.sampleMimeType)
+        ? format.pcmEncoding
+        : C.ENCODING_PCM_16BIT;
+  }
+
   private final class AudioSinkListener implements AudioSink.Listener {
 
     @Override
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
index d0c057b..1bfa189 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
@@ -26,23 +26,17 @@ import java.nio.ByteBuffer;
 /* package */ final class ResamplingAudioProcessor extends BaseAudioProcessor {
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
-      throws UnhandledFormatException {
+  public AudioFormat onConfigure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    @C.PcmEncoding int encoding = inputAudioFormat.encoding;
     if (encoding != C.ENCODING_PCM_8BIT && encoding != C.ENCODING_PCM_16BIT
         && encoding != C.ENCODING_PCM_24BIT && encoding != C.ENCODING_PCM_32BIT) {
-      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+      throw new UnhandledAudioFormatException(inputAudioFormat);
     }
-    return setInputFormat(sampleRateHz, channelCount, encoding);
-  }
-
-  @Override
-  public boolean isActive() {
-    return encoding != C.ENCODING_INVALID && encoding != C.ENCODING_PCM_16BIT;
-  }
-
-  @Override
-  public int getOutputEncoding() {
-    return C.ENCODING_PCM_16BIT;
+    return encoding != C.ENCODING_PCM_16BIT
+        ? new AudioFormat(
+            inputAudioFormat.sampleRate, inputAudioFormat.channelCount, C.ENCODING_PCM_16BIT)
+        : AudioFormat.NOT_SET;
   }
 
   @Override
@@ -52,7 +46,7 @@ import java.nio.ByteBuffer;
     int limit = inputBuffer.limit();
     int size = limit - position;
     int resampledSize;
-    switch (encoding) {
+    switch (inputAudioFormat.encoding) {
       case C.ENCODING_PCM_8BIT:
         resampledSize = size * 2;
         break;
@@ -74,7 +68,7 @@ import java.nio.ByteBuffer;
 
     // Resample the little endian input and update the input/output buffers.
     ByteBuffer buffer = replaceOutputBuffer(resampledSize);
-    switch (encoding) {
+    switch (inputAudioFormat.encoding) {
       case C.ENCODING_PCM_8BIT:
         // 8->16 bit resampling. Shift each byte from [0, 256) to [-128, 128) and scale up.
         for (int i = position; i < limit; i++) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
index caf8a61..2a98d2f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
@@ -98,14 +98,14 @@ public final class SilenceSkippingAudioProcessor extends BaseAudioProcessor {
   }
 
   /**
-   * Sets whether to skip silence in the input. Calling this method will discard any data buffered
-   * within the processor, and may update the value returned by {@link #isActive()}.
+   * Sets whether to skip silence in the input. This method may only be called after draining data
+   * through the processor. The value returned by {@link #isActive()} may change, and the processor
+   * must be {@link #flush() flushed} before queueing more data.
    *
    * @param enabled Whether to skip silence in the input.
    */
   public void setEnabled(boolean enabled) {
     this.enabled = enabled;
-    flush();
   }
 
   /**
@@ -119,18 +119,17 @@ public final class SilenceSkippingAudioProcessor extends BaseAudioProcessor {
   // AudioProcessor implementation.
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
-      throws UnhandledFormatException {
-    if (encoding != C.ENCODING_PCM_16BIT) {
-      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+  public AudioFormat onConfigure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    if (inputAudioFormat.encoding != C.ENCODING_PCM_16BIT) {
+      throw new UnhandledAudioFormatException(inputAudioFormat);
     }
-    bytesPerFrame = channelCount * 2;
-    return setInputFormat(sampleRateHz, channelCount, encoding);
+    return enabled ? inputAudioFormat : AudioFormat.NOT_SET;
   }
 
   @Override
   public boolean isActive() {
-    return super.isActive() && enabled;
+    return enabled;
   }
 
   @Override
@@ -165,7 +164,8 @@ public final class SilenceSkippingAudioProcessor extends BaseAudioProcessor {
 
   @Override
   protected void onFlush() {
-    if (isActive()) {
+    if (enabled) {
+      bytesPerFrame = inputAudioFormat.bytesPerFrame;
       int maybeSilenceBufferSize = durationUsToFrames(MINIMUM_SILENCE_DURATION_US) * bytesPerFrame;
       if (maybeSilenceBuffer.length != maybeSilenceBufferSize) {
         maybeSilenceBuffer = new byte[maybeSilenceBufferSize];
@@ -317,7 +317,7 @@ public final class SilenceSkippingAudioProcessor extends BaseAudioProcessor {
    * Returns the number of input frames corresponding to {@code durationUs} microseconds of audio.
    */
   private int durationUsToFrames(long durationUs) {
-    return (int) ((durationUs * sampleRateHz) / C.MICROS_PER_SECOND);
+    return (int) ((durationUs * inputAudioFormat.sampleRate) / C.MICROS_PER_SECOND);
   }
 
   /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 32516e7..6087020 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -28,6 +28,7 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.PlayerMessage.Target;
+import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener.EventDispatcher;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
@@ -217,31 +218,34 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
   }
 
   @Override
+  @Nullable
   public MediaClock getMediaClock() {
     return this;
   }
 
   @Override
+  @Capabilities
   public final int supportsFormat(Format format) {
     if (!MimeTypes.isAudio(format.sampleMimeType)) {
-      return FORMAT_UNSUPPORTED_TYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
     }
-    int formatSupport = supportsFormatInternal(drmSessionManager, format);
+    @FormatSupport int formatSupport = supportsFormatInternal(drmSessionManager, format);
     if (formatSupport <= FORMAT_UNSUPPORTED_DRM) {
-      return formatSupport;
+      return RendererCapabilities.create(formatSupport);
     }
+    @TunnelingSupport
     int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
-    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
+    return RendererCapabilities.create(formatSupport, ADAPTIVE_NOT_SEAMLESS, tunnelingSupport);
   }
 
   /**
-   * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for {@link
-   * #supportsFormat(Format)}.
+   * Returns the {@link FormatSupport} for the given {@link Format}.
    *
    * @param drmSessionManager The renderer's {@link DrmSessionManager}.
    * @param format The format, which has an audio {@link Format#sampleMimeType}.
-   * @return The extent to which the renderer supports the format itself.
+   * @return The {@link FormatSupport} for this {@link Format}.
    */
+  @FormatSupport
   protected abstract int supportsFormatInternal(
       @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format);
 
@@ -260,7 +264,7 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
       try {
         audioSink.playToEndOfStream();
       } catch (AudioSink.WriteException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
+        throw createRendererException(e, inputFormat);
       }
       return;
     }
@@ -297,7 +301,7 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
         TraceUtil.endSection();
       } catch (AudioDecoderException | AudioSink.ConfigurationException
           | AudioSink.InitializationException | AudioSink.WriteException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
+        throw createRendererException(e, inputFormat);
       }
       decoderCounters.ensureUpdated();
     }
@@ -473,12 +477,14 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
   }
 
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+    if (decoderDrmSession == null
+        || (!bufferEncrypted
+            && (playClearSamplesWithoutKeys || decoderDrmSession.playClearSamplesWithoutKeys()))) {
       return false;
     }
     @DrmSession.State int drmSessionState = decoderDrmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(decoderDrmSession.getError(), getIndex());
+      throw createRendererException(decoderDrmSession.getError(), inputFormat);
     }
     return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
   }
@@ -488,7 +494,8 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
     try {
       audioSink.playToEndOfStream();
     } catch (AudioSink.WriteException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      // TODO(internal: b/145658993) Use outputFormat for the call from drainOutputBuffer.
+      throw createRendererException(e, inputFormat);
     }
   }
 
@@ -639,7 +646,7 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
           codecInitializedTimestamp - codecInitializingTimestamp);
       decoderCounters.decoderInitCount++;
     } catch (AudioDecoderException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, inputFormat);
     }
   }
 
@@ -657,12 +664,12 @@ public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements
   }
 
   private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(sourceDrmSession, session);
+    DrmSession.replaceSession(sourceDrmSession, session);
     sourceDrmSession = session;
   }
 
   private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(decoderDrmSession, session);
+    DrmSession.replaceSession(decoderDrmSession, session);
     decoderDrmSession = session;
   }
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
index bd32e5e..b9a59cd 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/SonicAudioProcessor.java
@@ -17,7 +17,6 @@ package com.google.android.exoplayer2.audio;
 
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.C.Encoding;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -62,12 +61,14 @@ public final class SonicAudioProcessor implements AudioProcessor {
    */
   private static final int MIN_BYTES_FOR_SPEEDUP_CALCULATION = 1024;
 
-  private int channelCount;
-  private int sampleRateHz;
+  private int pendingOutputSampleRate;
   private float speed;
   private float pitch;
-  private int outputSampleRateHz;
-  private int pendingOutputSampleRateHz;
+
+  private AudioFormat pendingInputAudioFormat;
+  private AudioFormat pendingOutputAudioFormat;
+  private AudioFormat inputAudioFormat;
+  private AudioFormat outputAudioFormat;
 
   private boolean pendingSonicRecreation;
   @Nullable private Sonic sonic;
@@ -84,18 +85,20 @@ public final class SonicAudioProcessor implements AudioProcessor {
   public SonicAudioProcessor() {
     speed = 1f;
     pitch = 1f;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
-    outputSampleRateHz = Format.NO_VALUE;
+    pendingInputAudioFormat = AudioFormat.NOT_SET;
+    pendingOutputAudioFormat = AudioFormat.NOT_SET;
+    inputAudioFormat = AudioFormat.NOT_SET;
+    outputAudioFormat = AudioFormat.NOT_SET;
     buffer = EMPTY_BUFFER;
     shortBuffer = buffer.asShortBuffer();
     outputBuffer = EMPTY_BUFFER;
-    pendingOutputSampleRateHz = SAMPLE_RATE_NO_CHANGE;
+    pendingOutputSampleRate = SAMPLE_RATE_NO_CHANGE;
   }
 
   /**
-   * Sets the playback speed. Calling this method will discard any data buffered within the
-   * processor, and may update the value returned by {@link #isActive()}.
+   * Sets the playback speed. This method may only be called after draining data through the
+   * processor. The value returned by {@link #isActive()} may change, and the processor must be
+   * {@link #flush() flushed} before queueing more data.
    *
    * @param speed The requested new playback speed.
    * @return The actual new playback speed.
@@ -106,13 +109,13 @@ public final class SonicAudioProcessor implements AudioProcessor {
       this.speed = speed;
       pendingSonicRecreation = true;
     }
-    flush();
     return speed;
   }
 
   /**
-   * Sets the playback pitch. Calling this method will discard any data buffered within the
-   * processor, and may update the value returned by {@link #isActive()}.
+   * Sets the playback pitch. This method may only be called after draining data through the
+   * processor. The value returned by {@link #isActive()} may change, and the processor must be
+   * {@link #flush() flushed} before queueing more data.
    *
    * @param pitch The requested new pitch.
    * @return The actual new pitch.
@@ -123,20 +126,19 @@ public final class SonicAudioProcessor implements AudioProcessor {
       this.pitch = pitch;
       pendingSonicRecreation = true;
     }
-    flush();
     return pitch;
   }
 
   /**
-   * Sets the sample rate for output audio, in hertz. Pass {@link #SAMPLE_RATE_NO_CHANGE} to output
-   * audio at the same sample rate as the input. After calling this method, call
-   * {@link #configure(int, int, int)} to start using the new sample rate.
+   * Sets the sample rate for output audio, in Hertz. Pass {@link #SAMPLE_RATE_NO_CHANGE} to output
+   * audio at the same sample rate as the input. After calling this method, call {@link
+   * #configure(AudioFormat)} to configure the processor with the new sample rate.
    *
-   * @param sampleRateHz The sample rate for output audio, in hertz.
-   * @see #configure(int, int, int)
+   * @param sampleRateHz The sample rate for output audio, in Hertz.
+   * @see #configure(AudioFormat)
    */
   public void setOutputSampleRateHz(int sampleRateHz) {
-    pendingOutputSampleRateHz = sampleRateHz;
+    pendingOutputSampleRate = sampleRateHz;
   }
 
   /**
@@ -149,55 +151,39 @@ public final class SonicAudioProcessor implements AudioProcessor {
    */
   public long scaleDurationForSpeedup(long duration) {
     if (outputBytes >= MIN_BYTES_FOR_SPEEDUP_CALCULATION) {
-      return outputSampleRateHz == sampleRateHz
+      return outputAudioFormat.sampleRate == inputAudioFormat.sampleRate
           ? Util.scaleLargeTimestamp(duration, inputBytes, outputBytes)
-          : Util.scaleLargeTimestamp(duration, inputBytes * outputSampleRateHz,
-              outputBytes * sampleRateHz);
+          : Util.scaleLargeTimestamp(
+              duration,
+              inputBytes * outputAudioFormat.sampleRate,
+              outputBytes * inputAudioFormat.sampleRate);
     } else {
       return (long) ((double) speed * duration);
     }
   }
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @Encoding int encoding)
-      throws UnhandledFormatException {
-    if (encoding != C.ENCODING_PCM_16BIT) {
-      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
-    }
-    int outputSampleRateHz = pendingOutputSampleRateHz == SAMPLE_RATE_NO_CHANGE
-        ? sampleRateHz : pendingOutputSampleRateHz;
-    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount
-        && this.outputSampleRateHz == outputSampleRateHz) {
-      return false;
+  public AudioFormat configure(AudioFormat inputAudioFormat) throws UnhandledAudioFormatException {
+    if (inputAudioFormat.encoding != C.ENCODING_PCM_16BIT) {
+      throw new UnhandledAudioFormatException(inputAudioFormat);
     }
-    this.sampleRateHz = sampleRateHz;
-    this.channelCount = channelCount;
-    this.outputSampleRateHz = outputSampleRateHz;
+    int outputSampleRateHz =
+        pendingOutputSampleRate == SAMPLE_RATE_NO_CHANGE
+            ? inputAudioFormat.sampleRate
+            : pendingOutputSampleRate;
+    pendingInputAudioFormat = inputAudioFormat;
+    pendingOutputAudioFormat =
+        new AudioFormat(outputSampleRateHz, inputAudioFormat.channelCount, C.ENCODING_PCM_16BIT);
     pendingSonicRecreation = true;
-    return true;
+    return pendingOutputAudioFormat;
   }
 
   @Override
   public boolean isActive() {
-    return sampleRateHz != Format.NO_VALUE
+    return pendingOutputAudioFormat.sampleRate != Format.NO_VALUE
         && (Math.abs(speed - 1f) >= CLOSE_THRESHOLD
             || Math.abs(pitch - 1f) >= CLOSE_THRESHOLD
-            || outputSampleRateHz != sampleRateHz);
-  }
-
-  @Override
-  public int getOutputChannelCount() {
-    return channelCount;
-  }
-
-  @Override
-  public int getOutputEncoding() {
-    return C.ENCODING_PCM_16BIT;
-  }
-
-  @Override
-  public int getOutputSampleRateHz() {
-    return outputSampleRateHz;
+            || pendingOutputAudioFormat.sampleRate != pendingInputAudioFormat.sampleRate);
   }
 
   @Override
@@ -249,8 +235,16 @@ public final class SonicAudioProcessor implements AudioProcessor {
   @Override
   public void flush() {
     if (isActive()) {
+      inputAudioFormat = pendingInputAudioFormat;
+      outputAudioFormat = pendingOutputAudioFormat;
       if (pendingSonicRecreation) {
-        sonic = new Sonic(sampleRateHz, channelCount, speed, pitch, outputSampleRateHz);
+        sonic =
+            new Sonic(
+                inputAudioFormat.sampleRate,
+                inputAudioFormat.channelCount,
+                speed,
+                pitch,
+                outputAudioFormat.sampleRate);
       } else if (sonic != null) {
         sonic.flush();
       }
@@ -265,13 +259,14 @@ public final class SonicAudioProcessor implements AudioProcessor {
   public void reset() {
     speed = 1f;
     pitch = 1f;
-    channelCount = Format.NO_VALUE;
-    sampleRateHz = Format.NO_VALUE;
-    outputSampleRateHz = Format.NO_VALUE;
+    pendingInputAudioFormat = AudioFormat.NOT_SET;
+    pendingOutputAudioFormat = AudioFormat.NOT_SET;
+    inputAudioFormat = AudioFormat.NOT_SET;
+    outputAudioFormat = AudioFormat.NOT_SET;
     buffer = EMPTY_BUFFER;
     shortBuffer = buffer.asShortBuffer();
     outputBuffer = EMPTY_BUFFER;
-    pendingOutputSampleRateHz = SAMPLE_RATE_NO_CHANGE;
+    pendingOutputSampleRate = SAMPLE_RATE_NO_CHANGE;
     pendingSonicRecreation = false;
     sonic = null;
     inputBytes = 0;
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
index 6e4c977..8f39dd1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/TeeAudioProcessor.java
@@ -64,8 +64,9 @@ public final class TeeAudioProcessor extends BaseAudioProcessor {
   }
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding) {
-    return setInputFormat(sampleRateHz, channelCount, encoding);
+  public AudioFormat onConfigure(AudioFormat inputAudioFormat) {
+    // This processor is always active (if passed to the sink) and outputs its input.
+    return inputAudioFormat;
   }
 
   @Override
@@ -79,9 +80,19 @@ public final class TeeAudioProcessor extends BaseAudioProcessor {
   }
 
   @Override
-  protected void onFlush() {
+  protected void onQueueEndOfStream() {
+    flushSinkIfActive();
+  }
+
+  @Override
+  protected void onReset() {
+    flushSinkIfActive();
+  }
+
+  private void flushSinkIfActive() {
     if (isActive()) {
-      audioBufferSink.flush(sampleRateHz, channelCount, encoding);
+      audioBufferSink.flush(
+          inputAudioFormat.sampleRate, inputAudioFormat.channelCount, inputAudioFormat.encoding);
     }
   }
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java b/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
index c9e9f92..9437e4a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/audio/TrimmingAudioProcessor.java
@@ -24,11 +24,9 @@ import java.nio.ByteBuffer;
 
   @C.PcmEncoding private static final int OUTPUT_ENCODING = C.ENCODING_PCM_16BIT;
 
-  private boolean isActive;
   private int trimStartFrames;
   private int trimEndFrames;
-  private int bytesPerFrame;
-  private boolean receivedInputSinceConfigure;
+  private boolean reconfigurationPending;
 
   private int pendingTrimStartBytes;
   private byte[] endBuffer;
@@ -42,7 +40,7 @@ import java.nio.ByteBuffer;
 
   /**
    * Sets the number of audio frames to trim from the start and end of audio passed to this
-   * processor. After calling this method, call {@link #configure(int, int, int)} to apply the new
+   * processor. After calling this method, call {@link #configure(AudioFormat)} to apply the new
    * trimming frame counts.
    *
    * @param trimStartFrames The number of audio frames to trim from the start of audio.
@@ -68,28 +66,13 @@ import java.nio.ByteBuffer;
   }
 
   @Override
-  public boolean configure(int sampleRateHz, int channelCount, @C.PcmEncoding int encoding)
-      throws UnhandledFormatException {
-    if (encoding != OUTPUT_ENCODING) {
-      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+  public AudioFormat onConfigure(AudioFormat inputAudioFormat)
+      throws UnhandledAudioFormatException {
+    if (inputAudioFormat.encoding != OUTPUT_ENCODING) {
+      throw new UnhandledAudioFormatException(inputAudioFormat);
     }
-    if (endBufferSize > 0) {
-      trimmedFrameCount += endBufferSize / bytesPerFrame;
-    }
-    bytesPerFrame = Util.getPcmFrameSize(OUTPUT_ENCODING, channelCount);
-    endBuffer = new byte[trimEndFrames * bytesPerFrame];
-    endBufferSize = 0;
-    pendingTrimStartBytes = trimStartFrames * bytesPerFrame;
-    boolean wasActive = isActive;
-    isActive = trimStartFrames != 0 || trimEndFrames != 0;
-    receivedInputSinceConfigure = false;
-    setInputFormat(sampleRateHz, channelCount, encoding);
-    return wasActive != isActive;
-  }
-
-  @Override
-  public boolean isActive() {
-    return isActive;
+    reconfigurationPending = true;
+    return trimStartFrames != 0 || trimEndFrames != 0 ? inputAudioFormat : AudioFormat.NOT_SET;
   }
 
   @Override
@@ -101,11 +84,10 @@ import java.nio.ByteBuffer;
     if (remaining == 0) {
       return;
     }
-    receivedInputSinceConfigure = true;
 
     // Trim any pending start bytes from the input buffer.
     int trimBytes = Math.min(remaining, pendingTrimStartBytes);
-    trimmedFrameCount += trimBytes / bytesPerFrame;
+    trimmedFrameCount += trimBytes / inputAudioFormat.bytesPerFrame;
     pendingTrimStartBytes -= trimBytes;
     inputBuffer.position(position + trimBytes);
     if (pendingTrimStartBytes > 0) {
@@ -142,30 +124,41 @@ import java.nio.ByteBuffer;
     buffer.flip();
   }
 
-  @SuppressWarnings("ReferenceEquality")
   @Override
   public ByteBuffer getOutput() {
     if (super.isEnded() && endBufferSize > 0) {
       // Because audio processors may be drained in the middle of the stream we assume that the
-      // contents of the end buffer need to be output. For gapless transitions, configure will be
-      // always be called, which clears the end buffer as needed. When audio is actually ending we
-      // play the padding data which is incorrect. This behavior can be fixed once we have the
-      // timestamps associated with input buffers.
+      // contents of the end buffer need to be output. For gapless transitions, configure will
+      // always be called, so the end buffer is cleared in onQueueEndOfStream.
       replaceOutputBuffer(endBufferSize).put(endBuffer, 0, endBufferSize).flip();
       endBufferSize = 0;
     }
     return super.getOutput();
   }
 
-  @SuppressWarnings("ReferenceEquality")
   @Override
   public boolean isEnded() {
     return super.isEnded() && endBufferSize == 0;
   }
 
   @Override
+  protected void onQueueEndOfStream() {
+    if (reconfigurationPending) {
+      // Trim audio in the end buffer.
+      if (endBufferSize > 0) {
+        trimmedFrameCount += endBufferSize / inputAudioFormat.bytesPerFrame;
+      }
+      endBufferSize = 0;
+    }
+  }
+
+  @Override
   protected void onFlush() {
-    if (receivedInputSinceConfigure) {
+    if (reconfigurationPending) {
+      reconfigurationPending = false;
+      endBuffer = new byte[trimEndFrames * inputAudioFormat.bytesPerFrame];
+      pendingTrimStartBytes = trimStartFrames * inputAudioFormat.bytesPerFrame;
+    } else {
       // Audio processors are flushed after initial configuration, so we leave the pending trim
       // start byte count unmodified if the processor was just configured. Otherwise we (possibly
       // incorrectly) assume that this is a seek to a non-zero position. We should instead check the
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java b/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
index 14e813c..432cc66 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
@@ -41,14 +41,13 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
-import org.checkerframework.checker.nullness.compatqual.NullableType;
 import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /** A {@link DrmSession} that supports playbacks using {@link ExoMediaDrm}. */
 @TargetApi(18)
-public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T> {
+/* package */ class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T> {
 
   /** Thrown when an unexpected exception or error is thrown during provisioning or key requests. */
   public static final class UnexpectedDrmSessionException extends IOException {
@@ -106,8 +105,9 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
   private final ProvisioningManager<T> provisioningManager;
   private final ReleaseCallback<T> releaseCallback;
   private final @DefaultDrmSessionManager.Mode int mode;
+  private final boolean playClearSamplesWithoutKeys;
   private final boolean isPlaceholderSession;
-  @Nullable private final HashMap<String, String> optionalKeyRequestParameters;
+  private final HashMap<String, String> keyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
 
@@ -121,8 +121,8 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
   @Nullable private RequestHandler requestHandler;
   @Nullable private T mediaCrypto;
   @Nullable private DrmSessionException lastException;
-  private byte @NullableType [] sessionId;
-  private byte @MonotonicNonNull [] offlineLicenseKeySetId;
+  @Nullable private byte[] sessionId;
+  @MonotonicNonNull private byte[] offlineLicenseKeySetId;
 
   @Nullable private KeyRequest currentKeyRequest;
   @Nullable private ProvisionRequest currentProvisionRequest;
@@ -140,13 +140,15 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
    * @param isPlaceholderSession Whether this session is not expected to acquire any keys.
    * @param offlineLicenseKeySetId The offline license key set identifier, or null when not using
    *     offline keys.
-   * @param optionalKeyRequestParameters The optional key request parameters.
+   * @param keyRequestParameters Key request parameters.
    * @param callback The media DRM callback.
    * @param playbackLooper The playback looper.
    * @param eventDispatcher The dispatcher for DRM session manager events.
    * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy} for key and provisioning
    *     requests.
    */
+  // the constructor does not initialize fields: sessionId
+  @SuppressWarnings("nullness:initialization.fields.uninitialized")
   public DefaultDrmSession(
       UUID uuid,
       ExoMediaDrm<T> mediaDrm,
@@ -154,9 +156,10 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
       ReleaseCallback<T> releaseCallback,
       @Nullable List<SchemeData> schemeDatas,
       @DefaultDrmSessionManager.Mode int mode,
+      boolean playClearSamplesWithoutKeys,
       boolean isPlaceholderSession,
       @Nullable byte[] offlineLicenseKeySetId,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters,
+      HashMap<String, String> keyRequestParameters,
       MediaDrmCallback callback,
       Looper playbackLooper,
       EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher,
@@ -170,6 +173,7 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
     this.releaseCallback = releaseCallback;
     this.mediaDrm = mediaDrm;
     this.mode = mode;
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     this.isPlaceholderSession = isPlaceholderSession;
     if (offlineLicenseKeySetId != null) {
       this.offlineLicenseKeySetId = offlineLicenseKeySetId;
@@ -177,7 +181,7 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
     } else {
       this.schemeDatas = Collections.unmodifiableList(Assertions.checkNotNull(schemeDatas));
     }
-    this.optionalKeyRequestParameters = optionalKeyRequestParameters;
+    this.keyRequestParameters = keyRequestParameters;
     this.callback = callback;
     this.eventDispatcher = eventDispatcher;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
@@ -229,6 +233,11 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
   }
 
   @Override
+  public boolean playClearSamplesWithoutKeys() {
+    return playClearSamplesWithoutKeys;
+  }
+
+  @Override
   public final @Nullable DrmSessionException getError() {
     return state == STATE_ERROR ? lastException : null;
   }
@@ -251,7 +260,8 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
   }
 
   @Override
-  public void acquireReference() {
+  public void acquire() {
+    Assertions.checkState(referenceCount >= 0);
     if (++referenceCount == 1) {
       Assertions.checkState(state == STATE_OPENING);
       requestHandlerThread = new HandlerThread("DrmRequestHandler");
@@ -264,7 +274,7 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
   }
 
   @Override
-  public void releaseReference() {
+  public void release() {
     if (--referenceCount == 0) {
       // Assigning null to various non-null variables for clean-up.
       state = STATE_RELEASED;
@@ -347,7 +357,6 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
   @RequiresNonNull("sessionId")
   private void doLicense(boolean allowRetry) {
     if (isPlaceholderSession) {
-      state = STATE_OPENED_WITH_KEYS;
       return;
     }
     byte[] sessionId = Util.castNonNull(this.sessionId);
@@ -399,7 +408,7 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
       mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
       return true;
     } catch (Exception e) {
-      Log.e(TAG, "Error trying to restore Widevine keys.", e);
+      Log.e(TAG, "Error trying to restore keys.", e);
       onError(e);
     }
     return false;
@@ -416,8 +425,7 @@ public class DefaultDrmSession<T extends ExoMediaCrypto> implements DrmSession<T
 
   private void postKeyRequest(byte[] scope, int type, boolean allowRetry) {
     try {
-      currentKeyRequest =
-          mediaDrm.getKeyRequest(scope, schemeDatas, type, optionalKeyRequestParameters);
+      currentKeyRequest = mediaDrm.getKeyRequest(scope, schemeDatas, type, keyRequestParameters);
       Util.castNonNull(requestHandler)
           .post(MSG_KEYS, Assertions.checkNotNull(currentKeyRequest), allowRetry);
     } catch (Exception e) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java b/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java
index fa5b60e..297f26b 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionEventListener.java
@@ -24,7 +24,7 @@ public interface DefaultDrmSessionEventListener {
   default void onDrmSessionAcquired() {}
 
   /** Called each time keys are loaded. */
-  void onDrmKeysLoaded();
+  default void onDrmKeysLoaded() {}
 
   /**
    * Called when a drm error occurs.
@@ -38,13 +38,13 @@ public interface DefaultDrmSessionEventListener {
    *
    * @param error The corresponding exception.
    */
-  void onDrmSessionManagerError(Exception error);
+  default void onDrmSessionManagerError(Exception error) {}
 
   /** Called each time offline keys are restored. */
-  void onDrmKeysRestored();
+  default void onDrmKeysRestored() {}
 
   /** Called each time offline keys are removed. */
-  void onDrmKeysRemoved();
+  default void onDrmKeysRemoved() {}
 
   /** Called each time a drm session is released. */
   default void onDrmSessionReleased() {}
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 759f88c..1c27d74 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -20,11 +20,9 @@ import android.annotation.TargetApi;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import android.text.TextUtils;
 import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.drm.DefaultDrmSession.ProvisioningManager;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.OnEventListener;
@@ -38,14 +36,162 @@ import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.UUID;
 
 /** A {@link DrmSessionManager} that supports playbacks using {@link ExoMediaDrm}. */
 @TargetApi(18)
-public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
-    implements DrmSessionManager<T>, ProvisioningManager<T> {
+public class DefaultDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T> {
+
+  /**
+   * Builder for {@link DefaultDrmSessionManager} instances.
+   *
+   * <p>See {@link #Builder} for the list of default values.
+   */
+  public static final class Builder {
+
+    private final HashMap<String, String> keyRequestParameters;
+    private UUID uuid;
+    private ExoMediaDrm.Provider<ExoMediaCrypto> exoMediaDrmProvider;
+    private boolean multiSession;
+    private int[] useDrmSessionsForClearContentTrackTypes;
+    private boolean playClearSamplesWithoutKeys;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
+
+    /**
+     * Creates a builder with default values. The default values are:
+     *
+     * <ul>
+     *   <li>{@link #setKeyRequestParameters keyRequestParameters}: An empty map.
+     *   <li>{@link #setUuidAndExoMediaDrmProvider UUID}: {@link C#WIDEVINE_UUID}.
+     *   <li>{@link #setUuidAndExoMediaDrmProvider ExoMediaDrm.Provider}: {@link
+     *       FrameworkMediaDrm#DEFAULT_PROVIDER}.
+     *   <li>{@link #setMultiSession multiSession}: {@code false}.
+     *   <li>{@link #setUseDrmSessionsForClearContent useDrmSessionsForClearContent}: No tracks.
+     *   <li>{@link #setPlayClearSamplesWithoutKeys playClearSamplesWithoutKeys}: {@code false}.
+     *   <li>{@link #setLoadErrorHandlingPolicy LoadErrorHandlingPolicy}: {@link
+     *       DefaultLoadErrorHandlingPolicy}.
+     * </ul>
+     */
+    @SuppressWarnings("unchecked")
+    public Builder() {
+      keyRequestParameters = new HashMap<>();
+      uuid = C.WIDEVINE_UUID;
+      exoMediaDrmProvider = (ExoMediaDrm.Provider) FrameworkMediaDrm.DEFAULT_PROVIDER;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
+      useDrmSessionsForClearContentTrackTypes = new int[0];
+    }
+
+    /**
+     * Sets the key request parameters to pass as the last argument to {@link
+     * ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}.
+     *
+     * <p>Custom data for PlayReady should be set under {@link #PLAYREADY_CUSTOM_DATA_KEY}.
+     *
+     * @param keyRequestParameters A map with parameters.
+     * @return This builder.
+     */
+    public Builder setKeyRequestParameters(Map<String, String> keyRequestParameters) {
+      this.keyRequestParameters.clear();
+      this.keyRequestParameters.putAll(Assertions.checkNotNull(keyRequestParameters));
+      return this;
+    }
+
+    /**
+     * Sets the UUID of the DRM scheme and the {@link ExoMediaDrm.Provider} to use.
+     *
+     * @param uuid The UUID of the DRM scheme.
+     * @param exoMediaDrmProvider The {@link ExoMediaDrm.Provider}.
+     * @return This builder.
+     */
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    public Builder setUuidAndExoMediaDrmProvider(
+        UUID uuid, ExoMediaDrm.Provider exoMediaDrmProvider) {
+      this.uuid = Assertions.checkNotNull(uuid);
+      this.exoMediaDrmProvider = Assertions.checkNotNull(exoMediaDrmProvider);
+      return this;
+    }
+
+    /**
+     * Sets whether this session manager is allowed to acquire multiple simultaneous sessions.
+     *
+     * <p>Users should pass false when a single key request will obtain all keys required to decrypt
+     * the associated content. {@code multiSession} is required when content uses key rotation.
+     *
+     * @param multiSession Whether this session manager is allowed to acquire multiple simultaneous
+     *     sessions.
+     * @return This builder.
+     */
+    public Builder setMultiSession(boolean multiSession) {
+      this.multiSession = multiSession;
+      return this;
+    }
+
+    /**
+     * Sets whether this session manager should attach {@link DrmSession DrmSessions} to the clear
+     * sections of the media content.
+     *
+     * <p>Using {@link DrmSession DrmSessions} for clear content avoids the recreation of decoders
+     * when transitioning between clear and encrypted sections of content.
+     *
+     * @param useDrmSessionsForClearContentTrackTypes The track types ({@link C#TRACK_TYPE_AUDIO}
+     *     and/or {@link C#TRACK_TYPE_VIDEO}) for which to use a {@link DrmSession} regardless of
+     *     whether the content is clear or encrypted.
+     * @return This builder.
+     * @throws IllegalArgumentException If {@code useDrmSessionsForClearContentTrackTypes} contains
+     *     track types other than {@link C#TRACK_TYPE_AUDIO} and {@link C#TRACK_TYPE_VIDEO}.
+     */
+    public Builder setUseDrmSessionsForClearContent(
+        int... useDrmSessionsForClearContentTrackTypes) {
+      for (int trackType : useDrmSessionsForClearContentTrackTypes) {
+        Assertions.checkArgument(
+            trackType == C.TRACK_TYPE_VIDEO || trackType == C.TRACK_TYPE_AUDIO);
+      }
+      this.useDrmSessionsForClearContentTrackTypes =
+          useDrmSessionsForClearContentTrackTypes.clone();
+      return this;
+    }
+
+    /**
+     * Sets whether clear samples within protected content should be played when keys for the
+     * encrypted part of the content have yet to be loaded.
+     *
+     * @param playClearSamplesWithoutKeys Whether clear samples within protected content should be
+     *     played when keys for the encrypted part of the content have yet to be loaded.
+     * @return This builder.
+     */
+    public Builder setPlayClearSamplesWithoutKeys(boolean playClearSamplesWithoutKeys) {
+      this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+      return this;
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy} for key and provisioning requests.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This builder.
+     */
+    public Builder setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
+      this.loadErrorHandlingPolicy = Assertions.checkNotNull(loadErrorHandlingPolicy);
+      return this;
+    }
+
+    /** Builds a {@link DefaultDrmSessionManager} instance. */
+    public DefaultDrmSessionManager<ExoMediaCrypto> build(MediaDrmCallback mediaDrmCallback) {
+      return new DefaultDrmSessionManager<>(
+          uuid,
+          exoMediaDrmProvider,
+          mediaDrmCallback,
+          keyRequestParameters,
+          multiSession,
+          useDrmSessionsForClearContentTrackTypes,
+          playClearSamplesWithoutKeys,
+          loadErrorHandlingPolicy);
+    }
+  }
 
   /**
    * Signals that the {@link DrmInitData} passed to {@link #acquireSession} does not contain does
@@ -59,7 +205,8 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
   }
 
   /**
-   * The key to use when passing CustomData to a PlayReady instance in an optional parameter map.
+   * A key for specifying PlayReady custom data in the key request parameters passed to {@link
+   * Builder#setKeyRequestParameters(Map)}.
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
 
@@ -88,18 +235,23 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
   private static final String TAG = "DefaultDrmSessionMgr";
 
   private final UUID uuid;
-  private final ExoMediaDrm<T> mediaDrm;
+  private final ExoMediaDrm.Provider<T> exoMediaDrmProvider;
   private final MediaDrmCallback callback;
-  @Nullable private final HashMap<String, String> optionalKeyRequestParameters;
+  private final HashMap<String, String> keyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final boolean multiSession;
-  private final boolean allowPlaceholderSessions;
+  private final int[] useDrmSessionsForClearContentTrackTypes;
+  private final boolean playClearSamplesWithoutKeys;
+  private final ProvisioningManagerImpl provisioningManagerImpl;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
 
   private final List<DefaultDrmSession<T>> sessions;
   private final List<DefaultDrmSession<T>> provisioningSessions;
 
+  private int prepareCallsCount;
+  @Nullable private ExoMediaDrm<T> exoMediaDrm;
   @Nullable private DefaultDrmSession<T> placeholderDrmSession;
+  @Nullable private DefaultDrmSession<T> noMultiSessionDrmSession;
   @Nullable private Looper playbackLooper;
   private int mode;
   @Nullable private byte[] offlineLicenseKeySetId;
@@ -107,171 +259,112 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
   /* package */ volatile @Nullable MediaDrmHandler mediaDrmHandler;
 
   /**
-   * Instantiates a new instance using the Widevine scheme.
-   *
-   * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
-   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
-   */
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
-      MediaDrmCallback callback, @Nullable HashMap<String, String> optionalKeyRequestParameters)
-      throws UnsupportedDrmException {
-    return newFrameworkInstance(C.WIDEVINE_UUID, callback, optionalKeyRequestParameters);
-  }
-
-  /**
-   * Instantiates a new instance using the PlayReady scheme.
-   *
-   * <p>Note that PlayReady is unsupported by most Android devices, with the exception of Android TV
-   * devices, which do provide support.
-   *
-   * @param callback Performs key and provisioning requests.
-   * @param customData Optional custom data to include in requests generated by the instance.
-   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
-   */
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
-      MediaDrmCallback callback, @Nullable String customData) throws UnsupportedDrmException {
-    HashMap<String, String> optionalKeyRequestParameters;
-    if (!TextUtils.isEmpty(customData)) {
-      optionalKeyRequestParameters = new HashMap<>();
-      optionalKeyRequestParameters.put(PLAYREADY_CUSTOM_DATA_KEY, customData);
-    } else {
-      optionalKeyRequestParameters = null;
-    }
-    return newFrameworkInstance(C.PLAYREADY_UUID, callback, optionalKeyRequestParameters);
-  }
-
-  /**
-   * Instantiates a new instance.
-   *
-   * @param uuid The UUID of the drm scheme.
-   * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
-   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
-   */
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
-      UUID uuid,
-      MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters)
-      throws UnsupportedDrmException {
-    return new DefaultDrmSessionManager<>(
-        uuid,
-        FrameworkMediaDrm.newInstance(uuid),
-        callback,
-        optionalKeyRequestParameters,
-        /* multiSession= */ false,
-        INITIAL_DRM_REQUEST_RETRY_COUNT);
-  }
-
-  /**
    * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param exoMediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
+   * @param keyRequestParameters An optional map of parameters to pass as the last argument to
+   *     {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
+   * @deprecated Use {@link Builder} instead.
    */
+  @SuppressWarnings("deprecation")
+  @Deprecated
   public DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm<T> exoMediaDrm,
       MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters) {
+      @Nullable HashMap<String, String> keyRequestParameters) {
     this(
         uuid,
-        mediaDrm,
+        exoMediaDrm,
         callback,
-        optionalKeyRequestParameters,
+        keyRequestParameters == null ? new HashMap<>() : keyRequestParameters,
         /* multiSession= */ false,
         INITIAL_DRM_REQUEST_RETRY_COUNT);
   }
 
   /**
    * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param exoMediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
+   * @param keyRequestParameters An optional map of parameters to pass as the last argument to
+   *     {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @param multiSession A boolean that specify whether multiple key session support is enabled.
    *     Default is false.
+   * @deprecated Use {@link Builder} instead.
    */
+  @Deprecated
   public DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm<T> exoMediaDrm,
       MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters,
+      @Nullable HashMap<String, String> keyRequestParameters,
       boolean multiSession) {
     this(
         uuid,
-        mediaDrm,
+        exoMediaDrm,
         callback,
-        optionalKeyRequestParameters,
+        keyRequestParameters == null ? new HashMap<>() : keyRequestParameters,
         multiSession,
         INITIAL_DRM_REQUEST_RETRY_COUNT);
   }
 
   /**
    * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param exoMediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
+   * @param keyRequestParameters An optional map of parameters to pass as the last argument to
+   *     {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @param multiSession A boolean that specify whether multiple key session support is enabled.
    *     Default is false.
    * @param initialDrmRequestRetryCount The number of times to retry for initial provisioning and
    *     key request before reporting error.
+   * @deprecated Use {@link Builder} instead.
    */
+  @Deprecated
   public DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm<T> exoMediaDrm,
       MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters,
+      @Nullable HashMap<String, String> keyRequestParameters,
       boolean multiSession,
       int initialDrmRequestRetryCount) {
     this(
         uuid,
-        mediaDrm,
+        new ExoMediaDrm.AppManagedProvider<>(exoMediaDrm),
         callback,
-        optionalKeyRequestParameters,
+        keyRequestParameters == null ? new HashMap<>() : keyRequestParameters,
         multiSession,
-        /* allowPlaceholderSessions= */ false,
+        /* useDrmSessionsForClearContentTrackTypes= */ new int[0],
+        /* playClearSamplesWithoutKeys= */ false,
         new DefaultLoadErrorHandlingPolicy(initialDrmRequestRetryCount));
   }
 
+  // the constructor does not initialize fields: offlineLicenseKeySetId
+  @SuppressWarnings("nullness:initialization.fields.uninitialized")
   private DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm.Provider<T> exoMediaDrmProvider,
       MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters,
+      HashMap<String, String> keyRequestParameters,
       boolean multiSession,
-      boolean allowPlaceholderSessions,
+      int[] useDrmSessionsForClearContentTrackTypes,
+      boolean playClearSamplesWithoutKeys,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
     Assertions.checkNotNull(uuid);
-    Assertions.checkNotNull(mediaDrm);
     Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid), "Use C.CLEARKEY_UUID instead");
     this.uuid = uuid;
-    this.mediaDrm = mediaDrm;
+    this.exoMediaDrmProvider = exoMediaDrmProvider;
     this.callback = callback;
-    this.optionalKeyRequestParameters = optionalKeyRequestParameters;
+    this.keyRequestParameters = keyRequestParameters;
     this.eventDispatcher = new EventDispatcher<>();
     this.multiSession = multiSession;
-    boolean canAcquirePlaceholderSessions =
-        !FrameworkMediaCrypto.class.equals(mediaDrm.getExoMediaCryptoType())
-            || !FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC;
-    // TODO: Allow customization once this class has a Builder.
-    this.allowPlaceholderSessions = canAcquirePlaceholderSessions && allowPlaceholderSessions;
+    this.useDrmSessionsForClearContentTrackTypes = useDrmSessionsForClearContentTrackTypes;
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
+    provisioningManagerImpl = new ProvisioningManagerImpl();
     mode = MODE_PLAYBACK;
     sessions = new ArrayList<>();
     provisioningSessions = new ArrayList<>();
-    if (multiSession && C.WIDEVINE_UUID.equals(uuid) && Util.SDK_INT >= 19) {
-      // TODO: Enabling session sharing probably doesn't do anything useful here. It would only be
-      // useful if DefaultDrmSession instances were aware of one another's state, which is not
-      // implemented. Or if custom renderers are being used that allow playback to proceed before
-      // keys, which seems unlikely to be true in practice.
-      mediaDrm.setPropertyString("sessionSharing", "enable");
-    }
-    mediaDrm.setOnEventListener(new MediaDrmEventListener());
   }
 
   /**
@@ -294,57 +387,9 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
   }
 
   /**
-   * Provides access to {@link ExoMediaDrm#getPropertyString(String)}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The key to request.
-   * @return The retrieved property.
-   */
-  public final String getPropertyString(String key) {
-    return mediaDrm.getPropertyString(key);
-  }
-
-  /**
-   * Provides access to {@link ExoMediaDrm#setPropertyString(String, String)}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The property to write.
-   * @param value The value to write.
-   */
-  public final void setPropertyString(String key, String value) {
-    mediaDrm.setPropertyString(key, value);
-  }
-
-  /**
-   * Provides access to {@link ExoMediaDrm#getPropertyByteArray(String)}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The key to request.
-   * @return The retrieved property.
-   */
-  public final byte[] getPropertyByteArray(String key) {
-    return mediaDrm.getPropertyByteArray(key);
-  }
-
-  /**
-   * Provides access to {@link ExoMediaDrm#setPropertyByteArray(String, byte[])}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The property to write.
-   * @param value The value to write.
-   */
-  public final void setPropertyByteArray(String key, byte[] value) {
-    mediaDrm.setPropertyByteArray(key, value);
-  }
-
-  /**
    * Sets the mode, which determines the role of sessions acquired from the instance. This must be
    * called before {@link #acquireSession(Looper, DrmInitData)} or {@link
-   * #acquirePlaceholderSession(Looper)} is called.
+   * #acquirePlaceholderSession} is called.
    *
    * <p>By default, the mode is {@link #MODE_PLAYBACK} and a streaming license is requested when
    * required.
@@ -377,6 +422,23 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
   // DrmSessionManager implementation.
 
   @Override
+  public final void prepare() {
+    if (prepareCallsCount++ == 0) {
+      Assertions.checkState(exoMediaDrm == null);
+      exoMediaDrm = exoMediaDrmProvider.acquireExoMediaDrm(uuid);
+      exoMediaDrm.setOnEventListener(new MediaDrmEventListener());
+    }
+  }
+
+  @Override
+  public final void release() {
+    if (--prepareCallsCount == 0) {
+      Assertions.checkNotNull(exoMediaDrm).release();
+      exoMediaDrm = null;
+    }
+  }
+
+  @Override
   public boolean canAcquireSession(DrmInitData drmInitData) {
     if (offlineLicenseKeySetId != null) {
       // An offline license can be restored so a session can always be acquired.
@@ -410,19 +472,27 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
 
   @Override
   @Nullable
-  public DrmSession<T> acquirePlaceholderSession(Looper playbackLooper) {
+  public DrmSession<T> acquirePlaceholderSession(Looper playbackLooper, int trackType) {
     assertExpectedPlaybackLooper(playbackLooper);
-    if (!allowPlaceholderSessions || mediaDrm.getExoMediaCryptoType() == null) {
+    ExoMediaDrm<T> exoMediaDrm = Assertions.checkNotNull(this.exoMediaDrm);
+    boolean avoidPlaceholderDrmSessions =
+        FrameworkMediaCrypto.class.equals(exoMediaDrm.getExoMediaCryptoType())
+            && FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC;
+    // Avoid attaching a session to sparse formats.
+    if (avoidPlaceholderDrmSessions
+        || Util.linearSearch(useDrmSessionsForClearContentTrackTypes, trackType) == C.INDEX_UNSET
+        || exoMediaDrm.getExoMediaCryptoType() == null) {
       return null;
     }
     maybeCreateMediaDrmHandler(playbackLooper);
     if (placeholderDrmSession == null) {
       DefaultDrmSession<T> placeholderDrmSession =
-          createNewDefaultSession(/* schemeDatas= */ null, /* isPlaceholderSession= */ true);
+          createNewDefaultSession(
+              /* schemeDatas= */ Collections.emptyList(), /* isPlaceholderSession= */ true);
       sessions.add(placeholderDrmSession);
       this.placeholderDrmSession = placeholderDrmSession;
     }
-    placeholderDrmSession.acquireReference();
+    placeholderDrmSession.acquire();
     return placeholderDrmSession;
   }
 
@@ -431,7 +501,7 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
     assertExpectedPlaybackLooper(playbackLooper);
     maybeCreateMediaDrmHandler(playbackLooper);
 
-    List<SchemeData> schemeDatas = null;
+    @Nullable List<SchemeData> schemeDatas = null;
     if (offlineLicenseKeySetId == null) {
       schemeDatas = getSchemeDatas(drmInitData, uuid, false);
       if (schemeDatas.isEmpty()) {
@@ -441,9 +511,9 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
       }
     }
 
-    DefaultDrmSession<T> session;
+    @Nullable DefaultDrmSession<T> session;
     if (!multiSession) {
-      session = sessions.isEmpty() ? null : sessions.get(0);
+      session = noMultiSessionDrmSession;
     } else {
       // Only use an existing session if it has matching init data.
       session = null;
@@ -458,47 +528,21 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
     if (session == null) {
       // Create a new session.
       session = createNewDefaultSession(schemeDatas, /* isPlaceholderSession= */ false);
+      if (!multiSession) {
+        noMultiSessionDrmSession = session;
+      }
       sessions.add(session);
     }
-    session.acquireReference();
+    session.acquire();
     return session;
   }
 
   @Override
   @Nullable
   public Class<T> getExoMediaCryptoType(DrmInitData drmInitData) {
-    return canAcquireSession(drmInitData) ? mediaDrm.getExoMediaCryptoType() : null;
-  }
-
-  // ProvisioningManager implementation.
-
-  @Override
-  public void provisionRequired(DefaultDrmSession<T> session) {
-    if (provisioningSessions.contains(session)) {
-      // The session has already requested provisioning.
-      return;
-    }
-    provisioningSessions.add(session);
-    if (provisioningSessions.size() == 1) {
-      // This is the first session requesting provisioning, so have it perform the operation.
-      session.provision();
-    }
-  }
-
-  @Override
-  public void onProvisionCompleted() {
-    for (DefaultDrmSession<T> session : provisioningSessions) {
-      session.onProvisionCompleted();
-    }
-    provisioningSessions.clear();
-  }
-
-  @Override
-  public void onProvisionError(Exception error) {
-    for (DefaultDrmSession<T> session : provisioningSessions) {
-      session.onProvisionError(error);
-    }
-    provisioningSessions.clear();
+    return canAcquireSession(drmInitData)
+        ? Assertions.checkNotNull(exoMediaDrm).getExoMediaCryptoType()
+        : null;
   }
 
   // Internal methods.
@@ -516,16 +560,20 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
 
   private DefaultDrmSession<T> createNewDefaultSession(
       @Nullable List<SchemeData> schemeDatas, boolean isPlaceholderSession) {
+    Assertions.checkNotNull(exoMediaDrm);
+    // Placeholder sessions should always play clear samples without keys.
+    boolean playClearSamplesWithoutKeys = this.playClearSamplesWithoutKeys | isPlaceholderSession;
     return new DefaultDrmSession<>(
         uuid,
-        mediaDrm,
-        /* provisioningManager= */ this,
+        exoMediaDrm,
+        /* provisioningManager= */ provisioningManagerImpl,
         /* releaseCallback= */ this::onSessionReleased,
         schemeDatas,
         mode,
+        playClearSamplesWithoutKeys,
         isPlaceholderSession,
         offlineLicenseKeySetId,
-        optionalKeyRequestParameters,
+        keyRequestParameters,
         callback,
         Assertions.checkNotNull(playbackLooper),
         eventDispatcher,
@@ -537,6 +585,9 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
     if (placeholderDrmSession == drmSession) {
       placeholderDrmSession = null;
     }
+    if (noMultiSessionDrmSession == drmSession) {
+      noMultiSessionDrmSession = null;
+    }
     if (provisioningSessions.size() > 1 && provisioningSessions.get(0) == drmSession) {
       // Other sessions were waiting for the released session to complete a provision operation.
       // We need to have one of those sessions perform the provision operation instead.
@@ -594,6 +645,37 @@ public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
     }
   }
 
+  private class ProvisioningManagerImpl implements DefaultDrmSession.ProvisioningManager<T> {
+    @Override
+    public void provisionRequired(DefaultDrmSession<T> session) {
+      if (provisioningSessions.contains(session)) {
+        // The session has already requested provisioning.
+        return;
+      }
+      provisioningSessions.add(session);
+      if (provisioningSessions.size() == 1) {
+        // This is the first session requesting provisioning, so have it perform the operation.
+        session.provision();
+      }
+    }
+
+    @Override
+    public void onProvisionCompleted() {
+      for (DefaultDrmSession<T> session : provisioningSessions) {
+        session.onProvisionCompleted();
+      }
+      provisioningSessions.clear();
+    }
+
+    @Override
+    public void onProvisionError(Exception error) {
+      for (DefaultDrmSession<T> session : provisioningSessions) {
+        session.onProvisionError(error);
+      }
+      provisioningSessions.clear();
+    }
+  }
+
   private class MediaDrmEventListener implements OnEventListener<T> {
 
     @Override
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index 722ab94..35358f0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -30,21 +30,21 @@ import java.util.Map;
 public interface DrmSession<T extends ExoMediaCrypto> {
 
   /**
-   * Invokes {@code newSession's} {@link #acquireReference()} and {@code previousSession's} {@link
-   * #releaseReference()} in that order. Null arguments are ignored. Does nothing if {@code
-   * previousSession} and {@code newSession} are the same session.
+   * Invokes {@code newSession's} {@link #acquire()} and {@code previousSession's} {@link
+   * #release()} in that order. Null arguments are ignored. Does nothing if {@code previousSession}
+   * and {@code newSession} are the same session.
    */
-  static <T extends ExoMediaCrypto> void replaceSessionReferences(
+  static <T extends ExoMediaCrypto> void replaceSession(
       @Nullable DrmSession<T> previousSession, @Nullable DrmSession<T> newSession) {
     if (previousSession == newSession) {
       // Do nothing.
       return;
     }
     if (newSession != null) {
-      newSession.acquireReference();
+      newSession.acquire();
     }
     if (previousSession != null) {
-      previousSession.releaseReference();
+      previousSession.release();
     }
   }
 
@@ -77,13 +77,9 @@ public interface DrmSession<T extends ExoMediaCrypto> {
    * The session is being opened.
    */
   int STATE_OPENING = 2;
-  /**
-   * The session is open, but does not yet have the keys required for decryption.
-   */
+  /** The session is open, but does not have keys required for decryption. */
   int STATE_OPENED = 3;
-  /**
-   * The session is open and has the keys required for decryption.
-   */
+  /** The session is open and has keys required for decryption. */
   int STATE_OPENED_WITH_KEYS = 4;
 
   /**
@@ -93,6 +89,11 @@ public interface DrmSession<T extends ExoMediaCrypto> {
    */
   @State int getState();
 
+  /** Returns whether this session allows playback of clear samples prior to keys being loaded. */
+  default boolean playClearSamplesWithoutKeys() {
+    return false;
+  }
+
   /**
    * Returns the cause of the error state, or null if {@link #getState()} is not {@link
    * #STATE_ERROR}.
@@ -130,16 +131,14 @@ public interface DrmSession<T extends ExoMediaCrypto> {
   byte[] getOfflineLicenseKeySetId();
 
   /**
-   * Increments the reference count for this session. A non-zero reference count session will keep
-   * any acquired resources.
+   * Increments the reference count. When the caller no longer needs to use the instance, it must
+   * call {@link #release()} to decrement the reference count.
    */
-  void acquireReference();
+  void acquire();
 
   /**
-   * Decreases by one the reference count for this session. A session that reaches a zero reference
-   * count will release any resources it holds.
-   *
-   * <p>The session must not be used after its reference count has been reduced to 0.
+   * Decrements the reference count. If the reference count drops to 0 underlying resources are
+   * released, and the instance cannot be re-used.
    */
-  void releaseReference();
+  void release();
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java b/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
index 46f9458..146c5d7 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
@@ -16,12 +16,9 @@
 package com.google.android.exoplayer2.drm;
 
 import android.os.Looper;
-import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
 
 /**
  * Manages a DRM session.
@@ -58,26 +55,6 @@ public interface DrmSessionManager<T extends ExoMediaCrypto> {
         }
       };
 
-  /** Flags that control the handling of DRM protected content. */
-  @Documented
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef(
-      flag = true,
-      value = {FLAG_PLAY_CLEAR_SAMPLES_WITHOUT_KEYS})
-  @interface Flags {}
-
-  /**
-   * When this flag is set, clear samples of an encrypted region may be rendered when no keys are
-   * available.
-   *
-   * <p>Encrypted media may contain clear (un-encrypted) regions. For example a media file may start
-   * with a short clear region so as to allow playback to begin in parallel with key acquisition.
-   * When this flag is set, consumers of sample data are permitted to access the clear regions of
-   * encrypted media files when the associated {@link DrmSession} has not yet obtained the keys
-   * necessary for the encrypted regions of the media.
-   */
-  int FLAG_PLAY_CLEAR_SAMPLES_WITHOUT_KEYS = 1;
-
   /**
    * Acquires any required resources.
    *
@@ -104,27 +81,29 @@ public interface DrmSessionManager<T extends ExoMediaCrypto> {
   boolean canAcquireSession(DrmInitData drmInitData);
 
   /**
-   * Returns a {@link DrmSession} with an acquired reference that does not execute key requests.
-   * Returns null if placeholder sessions are not supported by this DRM session manager.
+   * Returns a {@link DrmSession} that does not execute key requests, with an incremented reference
+   * count. When the caller no longer needs to use the instance, it must call {@link
+   * DrmSession#release()} to decrement the reference count.
    *
    * <p>Placeholder {@link DrmSession DrmSessions} may be used to configure secure decoders for
-   * playback of clear samples, which reduces the costs of transitioning between clear and encrypted
-   * content periods.
+   * playback of clear content periods. This can reduce the cost of transitioning between clear and
+   * encrypted content periods.
    *
    * @param playbackLooper The looper associated with the media playback thread.
+   * @param trackType The type of the track to acquire a placeholder session for. Must be one of the
+   *     {@link C}{@code .TRACK_TYPE_*} constants.
    * @return The placeholder DRM session, or null if this DRM session manager does not support
    *     placeholder sessions.
    */
   @Nullable
-  default DrmSession<T> acquirePlaceholderSession(Looper playbackLooper) {
+  default DrmSession<T> acquirePlaceholderSession(Looper playbackLooper, int trackType) {
     return null;
   }
 
   /**
-   * Returns a {@link DrmSession} with an acquired reference for the specified {@link DrmInitData}.
-   *
-   * <p>The caller must call {@link DrmSession#releaseReference} to decrement the session's
-   * reference count when the session is no longer required.
+   * Returns a {@link DrmSession} for the specified {@link DrmInitData}, with an incremented
+   * reference count. When the caller no longer needs to use the instance, it must call {@link
+   * DrmSession#release()} to decrement the reference count.
    *
    * @param playbackLooper The looper associated with the media playback thread.
    * @param drmInitData DRM initialization data. All contained {@link SchemeData}s must contain
@@ -133,12 +112,6 @@ public interface DrmSessionManager<T extends ExoMediaCrypto> {
    */
   DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitData);
 
-  /** Returns flags that control the handling of DRM protected content. */
-  @Flags
-  default int getFlags() {
-    return 0;
-  }
-
   /**
    * Returns the {@link ExoMediaCrypto} type returned by sessions acquired using the given {@link
    * DrmInitData}, or null if a session cannot be acquired with the given {@link DrmInitData}.
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/DummyExoMediaDrm.java b/core/src/main/java/com/google/android/exoplayer2/drm/DummyExoMediaDrm.java
index f7b24cf..b619d94 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/DummyExoMediaDrm.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/DummyExoMediaDrm.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.drm;
 
 import android.media.MediaDrmException;
+import android.os.PersistableBundle;
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
 import com.google.android.exoplayer2.util.Util;
@@ -105,6 +106,12 @@ public final class DummyExoMediaDrm<T extends ExoMediaCrypto> implements ExoMedi
   }
 
   @Override
+  @Nullable
+  public PersistableBundle getMetrics() {
+    return null;
+  }
+
+  @Override
   public String getPropertyString(String propertyName) {
     return "";
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java b/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
index d40cf60..0028e47 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/ErrorStateDrmSession.java
@@ -34,6 +34,11 @@ public final class ErrorStateDrmSession<T extends ExoMediaCrypto> implements Drm
   }
 
   @Override
+  public boolean playClearSamplesWithoutKeys() {
+    return false;
+  }
+
+  @Override
   @Nullable
   public DrmSessionException getError() {
     return error;
@@ -58,12 +63,12 @@ public final class ErrorStateDrmSession<T extends ExoMediaCrypto> implements Drm
   }
 
   @Override
-  public void acquireReference() {
+  public void acquire() {
     // Do nothing.
   }
 
   @Override
-  public void releaseReference() {
+  public void release() {
     // Do nothing.
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java b/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
index 9846a76..b6ee644 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/ExoMediaDrm.java
@@ -21,6 +21,7 @@ import android.media.MediaDrm;
 import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
 import android.os.Handler;
+import android.os.PersistableBundle;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import java.util.HashMap;
@@ -30,6 +31,16 @@ import java.util.UUID;
 
 /**
  * Used to obtain keys for decrypting protected media streams. See {@link android.media.MediaDrm}.
+ *
+ * <h3>Reference counting</h3>
+ *
+ * <p>Access to an instance is managed by reference counting, where {@link #acquire()} increments
+ * the reference count and {@link #release()} decrements it. When the reference count drops to 0
+ * underlying resources are released, and the instance cannot be re-used.
+ *
+ * <p>Each new instance has an initial reference count of 1. Hence application code that creates a
+ * new instance does not normally need to call {@link #acquire()}, and must call {@link #release()}
+ * when the instance is no longer required.
  */
 public interface ExoMediaDrm<T extends ExoMediaCrypto> {
 
@@ -37,26 +48,25 @@ public interface ExoMediaDrm<T extends ExoMediaCrypto> {
   interface Provider<T extends ExoMediaCrypto> {
 
     /**
-     * Returns an {@link ExoMediaDrm} instance with acquired ownership for the DRM scheme identified
-     * by the given UUID.
-     *
-     * <p>Each call to this method must have a corresponding call to {@link ExoMediaDrm#release()}
-     * to ensure correct resource management.
+     * Returns an {@link ExoMediaDrm} instance with an incremented reference count. When the caller
+     * no longer needs to use the instance, it must call {@link ExoMediaDrm#release()} to decrement
+     * the reference count.
      */
     ExoMediaDrm<T> acquireExoMediaDrm(UUID uuid);
   }
 
   /**
-   * {@link Provider} implementation which provides an {@link ExoMediaDrm} instance owned by the
-   * app.
+   * Provides an {@link ExoMediaDrm} instance owned by the app.
    *
-   * <p>This provider should be used to manually handle {@link ExoMediaDrm} resources.
+   * <p>Note that when using this provider the app will have instantiated the {@link ExoMediaDrm}
+   * instance, and remains responsible for calling {@link ExoMediaDrm#release()} on the instance
+   * when it's no longer being used.
    */
   final class AppManagedProvider<T extends ExoMediaCrypto> implements Provider<T> {
 
     private final ExoMediaDrm<T> exoMediaDrm;
 
-    /** Creates an instance, which provides the given {@link ExoMediaDrm}. */
+    /** Creates an instance that provides the given {@link ExoMediaDrm}. */
     public AppManagedProvider(ExoMediaDrm<T> exoMediaDrm) {
       this.exoMediaDrm = exoMediaDrm;
     }
@@ -268,17 +278,17 @@ public interface ExoMediaDrm<T extends ExoMediaCrypto> {
   Map<String, String> queryKeyStatus(byte[] sessionId);
 
   /**
-   * Acquires ownership over this instance, which must be released by calling {@link #release()}.
+   * Increments the reference count. When the caller no longer needs to use the instance, it must
+   * call {@link #release()} to decrement the reference count.
+   *
+   * <p>A new instance will have an initial reference count of 1, and therefore it is not normally
+   * necessary for application code to call this method.
    */
   void acquire();
 
   /**
-   * Releases ownership of this instance. If a call to this method causes this instance to have no
-   * acquired ownerships, releases the underlying resources.
-   *
-   * <p>Callers of this method must not make any further use of this instance.
-   *
-   * @see MediaDrm#release()
+   * Decrements the reference count. If the reference count drops to 0 underlying resources are
+   * released, and the instance cannot be re-used.
    */
   void release();
 
@@ -288,6 +298,14 @@ public interface ExoMediaDrm<T extends ExoMediaCrypto> {
   void restoreKeys(byte[] sessionId, byte[] keySetId);
 
   /**
+   * Returns drm metrics. May be null if unavailable.
+   *
+   * @see MediaDrm#getMetrics()
+   */
+  @Nullable
+  PersistableBundle getMetrics();
+
+  /**
    * @see MediaDrm#getPropertyString(String)
    */
   String getPropertyString(String propertyName);
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index 42050d7..8ac92b0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -23,8 +23,10 @@ import android.media.MediaDrm;
 import android.media.MediaDrmException;
 import android.media.NotProvisionedException;
 import android.media.UnsupportedSchemeException;
+import android.os.PersistableBundle;
 import android.text.TextUtils;
 import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
@@ -42,24 +44,24 @@ import java.util.List;
 import java.util.Map;
 import java.util.UUID;
 
-/**
- * An {@link ExoMediaDrm} implementation that wraps the framework {@link MediaDrm}.
- */
+/** An {@link ExoMediaDrm} implementation that wraps the framework {@link MediaDrm}. */
 @TargetApi(23)
+@RequiresApi(18)
 public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto> {
 
+  private static final String TAG = "FrameworkMediaDrm";
+
   /**
    * {@link ExoMediaDrm.Provider} that returns a new {@link FrameworkMediaDrm} for the requested
    * UUID. Returns a {@link DummyExoMediaDrm} if the protection scheme identified by the given UUID
    * is not supported by the device.
-   *
-   * <p>This provider should be used to make ExoPlayer handle {@link ExoMediaDrm} resources.
    */
   public static final Provider<FrameworkMediaCrypto> DEFAULT_PROVIDER =
       uuid -> {
         try {
           return newInstance(uuid);
         } catch (UnsupportedDrmException e) {
+          Log.e(TAG, "Failed to instantiate a FrameworkMediaDrm for uuid: " + uuid + ".");
           return new DummyExoMediaDrm<>();
         }
       };
@@ -68,15 +70,14 @@ public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto
   private static final String MOCK_LA_URL_VALUE = "https://x";
   private static final String MOCK_LA_URL = "<LA_URL>" + MOCK_LA_URL_VALUE + "</LA_URL>";
   private static final int UTF_16_BYTES_PER_CHARACTER = 2;
-  private static final String TAG = "FrameworkMediaDrm";
 
   private final UUID uuid;
   private final MediaDrm mediaDrm;
   private int referenceCount;
 
   /**
-   * Creates an instance with an {@link #acquire() acquired reference} for the specified scheme
-   * UUID.
+   * Creates an instance with an initial reference count of 1. {@link #release()} must be called on
+   * the instance when it's no longer required.
    *
    * @param uuid The scheme uuid.
    * @return The created instance.
@@ -224,6 +225,16 @@ public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto
   }
 
   @Override
+  @Nullable
+  @TargetApi(28)
+  public PersistableBundle getMetrics() {
+    if (Util.SDK_INT < 28) {
+      return null;
+    }
+    return mediaDrm.getMetrics();
+  }
+
+  @Override
   public String getPropertyString(String propertyName) {
     return mediaDrm.getPropertyString(propertyName);
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
index 03c199b..93a7585 100644
--- a/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
+++ b/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -15,24 +15,27 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import android.annotation.TargetApi;
 import android.media.MediaDrm;
 import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.util.Pair;
 import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.Mode;
 import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.util.Assertions;
-import java.util.HashMap;
+import java.util.Collections;
+import java.util.Map;
 import java.util.UUID;
 
-/**
- * Helper class to download, renew and release offline licenses.
- */
+/** Helper class to download, renew and release offline licenses. */
+@TargetApi(18)
+@RequiresApi(18)
 public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
 
   private static final DrmInitData DUMMY_DRM_INIT_DATA = new DrmInitData();
@@ -87,21 +90,21 @@ public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
    * @param forceDefaultLicenseUrl Whether to use {@code defaultLicenseUrl} for key requests that
    *     include their own license URL.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   *     to {@link MediaDrm#getKeyRequest}. May be null.
    * @return A new instance which uses Widevine CDM.
    * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
    *     instantiated.
-   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
-   *     MediaDrmCallback, HashMap)
+   * @see DefaultDrmSessionManager.Builder
    */
   public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
       String defaultLicenseUrl,
       boolean forceDefaultLicenseUrl,
       Factory httpDataSourceFactory,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters)
+      @Nullable Map<String, String> optionalKeyRequestParameters)
       throws UnsupportedDrmException {
-    return new OfflineLicenseHelper<>(C.WIDEVINE_UUID,
-        FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID),
+    return new OfflineLicenseHelper<>(
+        C.WIDEVINE_UUID,
+        FrameworkMediaDrm.DEFAULT_PROVIDER,
         new HttpMediaDrmCallback(defaultLicenseUrl, forceDefaultLicenseUrl, httpDataSourceFactory),
         optionalKeyRequestParameters);
   }
@@ -110,18 +113,18 @@ public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
    * Constructs an instance. Call {@link #release()} when the instance is no longer required.
    *
    * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param mediaDrmProvider A {@link ExoMediaDrm.Provider}.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
-   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
-   *     MediaDrmCallback, HashMap)
+   *     to {@link MediaDrm#getKeyRequest}. May be null.
+   * @see DefaultDrmSessionManager.Builder
    */
+  @SuppressWarnings("unchecked")
   public OfflineLicenseHelper(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm.Provider<T> mediaDrmProvider,
       MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters) {
+      @Nullable Map<String, String> optionalKeyRequestParameters) {
     handlerThread = new HandlerThread("OfflineLicenseHelper");
     handlerThread.start();
     conditionVariable = new ConditionVariable();
@@ -147,40 +150,19 @@ public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
             conditionVariable.open();
           }
         };
+    if (optionalKeyRequestParameters == null) {
+      optionalKeyRequestParameters = Collections.emptyMap();
+    }
     drmSessionManager =
-        new DefaultDrmSessionManager<>(uuid, mediaDrm, callback, optionalKeyRequestParameters);
+        (DefaultDrmSessionManager<T>)
+            new DefaultDrmSessionManager.Builder()
+                .setUuidAndExoMediaDrmProvider(uuid, mediaDrmProvider)
+                .setKeyRequestParameters(optionalKeyRequestParameters)
+                .build(callback);
     drmSessionManager.addListener(new Handler(handlerThread.getLooper()), eventListener);
   }
 
   /**
-   * @see DefaultDrmSessionManager#getPropertyByteArray
-   */
-  public synchronized byte[] getPropertyByteArray(String key) {
-    return drmSessionManager.getPropertyByteArray(key);
-  }
-
-  /**
-   * @see DefaultDrmSessionManager#setPropertyByteArray
-   */
-  public synchronized void setPropertyByteArray(String key, byte[] value) {
-    drmSessionManager.setPropertyByteArray(key, value);
-  }
-
-  /**
-   * @see DefaultDrmSessionManager#getPropertyString
-   */
-  public synchronized String getPropertyString(String key) {
-    return drmSessionManager.getPropertyString(key);
-  }
-
-  /**
-   * @see DefaultDrmSessionManager#setPropertyString
-   */
-  public synchronized void setPropertyString(String key, String value) {
-    drmSessionManager.setPropertyString(key, value);
-  }
-
-  /**
    * Downloads an offline license.
    *
    * @param drmInitData The {@link DrmInitData} for the content whose license is to be downloaded.
@@ -229,13 +211,15 @@ public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
   public synchronized Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)
       throws DrmSessionException {
     Assertions.checkNotNull(offlineLicenseKeySetId);
+    drmSessionManager.prepare();
     DrmSession<T> drmSession =
         openBlockingKeyRequest(
             DefaultDrmSessionManager.MODE_QUERY, offlineLicenseKeySetId, DUMMY_DRM_INIT_DATA);
     DrmSessionException error = drmSession.getError();
     Pair<Long, Long> licenseDurationRemainingSec =
         WidevineUtil.getLicenseDurationRemainingSec(drmSession);
-    drmSession.releaseReference();
+    drmSession.release();
+    drmSessionManager.release();
     if (error != null) {
       if (error.getCause() instanceof KeysExpiredException) {
         return Pair.create(0L, 0L);
@@ -255,11 +239,13 @@ public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
   private byte[] blockingKeyRequest(
       @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, DrmInitData drmInitData)
       throws DrmSessionException {
+    drmSessionManager.prepare();
     DrmSession<T> drmSession = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId,
         drmInitData);
     DrmSessionException error = drmSession.getError();
     byte[] keySetId = drmSession.getOfflineLicenseKeySetId();
-    drmSession.releaseReference();
+    drmSession.release();
+    drmSessionManager.release();
     if (error != null) {
       throw error;
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 083f31b..a9151a1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -89,6 +89,10 @@ public interface Extractor {
    * {@link #RESULT_SEEK} is returned. If the extractor reached the end of the data provided by the
    * {@link ExtractorInput}, then {@link #RESULT_END_OF_INPUT} is returned.
    *
+   * <p>When this method throws an {@link IOException} or an {@link InterruptedException},
+   * extraction may continue by providing an {@link ExtractorInput} with an unchanged {@link
+   * ExtractorInput#getPosition() read position} to a subsequent call to this method.
+   *
    * @param input The {@link ExtractorInput} from which data should be read.
    * @param seekPosition If {@link #RESULT_SEEK} is returned, this holder is updated to hold the
    *     position of the required data.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
index e454bd5..04d85b8 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.MimeTypes;
 
@@ -195,7 +196,7 @@ public final class MpegAudioHeader {
   /** MPEG audio header version. */
   public int version;
   /** The mime type. */
-  public String mimeType;
+  @Nullable public String mimeType;
   /** Size of the frame associated with this header, in bytes. */
   public int frameSize;
   /** Sample rate in samples per second. */
@@ -223,5 +224,4 @@ public final class MpegAudioHeader {
     this.bitrate = bitrate;
     this.samplesPerFrame = samplesPerFrame;
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java b/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
index 0cb55df..15a98ab 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
@@ -25,7 +25,7 @@ import com.google.android.exoplayer2.util.Assertions;
 public interface SeekMap {
 
   /** A {@link SeekMap} that does not support seeking. */
-  final class Unseekable implements SeekMap {
+  class Unseekable implements SeekMap {
 
     private final long durationUs;
     private final SeekPoints startSeekPoints;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 56ba01b..b30fbf1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -224,7 +224,7 @@ public class MatroskaExtractor implements Extractor {
    * BlockAddID value for ITU T.35 metadata in a VP9 track. See also
    * https://www.webmproject.org/docs/container/.
    */
-  private static final int BLOCK_ADD_ID_VP9_ITU_T_35 = 4;
+  private static final int BLOCK_ADDITIONAL_ID_VP9_ITU_T_35 = 4;
 
   private static final int LACING_NONE = 0;
   private static final int LACING_XIPH = 1;
@@ -236,27 +236,26 @@ public class MatroskaExtractor implements Extractor {
   private static final int FOURCC_COMPRESSION_VC1 = 0x31435657;
 
   /**
-   * A template for the prefix that must be added to each subrip sample. The 12 byte end timecode
-   * starting at {@link #SUBRIP_PREFIX_END_TIMECODE_OFFSET} is set to a dummy value, and must be
-   * replaced with the duration of the subtitle.
-   * <p>
-   * Equivalent to the UTF-8 string: "1\n00:00:00,000 --> 00:00:00,000\n".
+   * A template for the prefix that must be added to each subrip sample.
+   *
+   * <p>The display time of each subtitle is passed as {@code timeUs} to {@link
+   * TrackOutput#sampleMetadata}. The start and end timecodes in this template are relative to
+   * {@code timeUs}. Hence the start timecode is always zero. The 12 byte end timecode starting at
+   * {@link #SUBRIP_PREFIX_END_TIMECODE_OFFSET} is set to a dummy value, and must be replaced with
+   * the duration of the subtitle.
+   *
+   * <p>Equivalent to the UTF-8 string: "1\n00:00:00,000 --> 00:00:00,000\n".
    */
-  private static final byte[] SUBRIP_PREFIX = new byte[] {49, 10, 48, 48, 58, 48, 48, 58, 48, 48,
-      44, 48, 48, 48, 32, 45, 45, 62, 32, 48, 48, 58, 48, 48, 58, 48, 48, 44, 48, 48, 48, 10};
+  private static final byte[] SUBRIP_PREFIX =
+      new byte[] {
+        49, 10, 48, 48, 58, 48, 48, 58, 48, 48, 44, 48, 48, 48, 32, 45, 45, 62, 32, 48, 48, 58, 48,
+        48, 58, 48, 48, 44, 48, 48, 48, 10
+      };
   /**
    * The byte offset of the end timecode in {@link #SUBRIP_PREFIX}.
    */
   private static final int SUBRIP_PREFIX_END_TIMECODE_OFFSET = 19;
   /**
-   * A special end timecode indicating that a subrip subtitle should be displayed until the next
-   * subtitle, or until the end of the media in the case of the last subtitle.
-   * <p>
-   * Equivalent to the UTF-8 string: "            ".
-   */
-  private static final byte[] SUBRIP_TIMECODE_EMPTY =
-      new byte[] {32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32};
-  /**
    * The value by which to divide a time in microseconds to convert it to the unit of the last value
    * in a subrip timecode (milliseconds).
    */
@@ -272,14 +271,21 @@ public class MatroskaExtractor implements Extractor {
   private static final byte[] SSA_DIALOGUE_FORMAT = Util.getUtf8Bytes("Format: Start, End, "
       + "ReadOrder, Layer, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
   /**
-   * A template for the prefix that must be added to each SSA sample. The 10 byte end timecode
-   * starting at {@link #SSA_PREFIX_END_TIMECODE_OFFSET} is set to a dummy value, and must be
-   * replaced with the duration of the subtitle.
-   * <p>
-   * Equivalent to the UTF-8 string: "Dialogue: 0:00:00:00,0:00:00:00,".
+   * A template for the prefix that must be added to each SSA sample.
+   *
+   * <p>The display time of each subtitle is passed as {@code timeUs} to {@link
+   * TrackOutput#sampleMetadata}. The start and end timecodes in this template are relative to
+   * {@code timeUs}. Hence the start timecode is always zero. The 12 byte end timecode starting at
+   * {@link #SUBRIP_PREFIX_END_TIMECODE_OFFSET} is set to a dummy value, and must be replaced with
+   * the duration of the subtitle.
+   *
+   * <p>Equivalent to the UTF-8 string: "Dialogue: 0:00:00:00,0:00:00:00,".
    */
-  private static final byte[] SSA_PREFIX = new byte[] {68, 105, 97, 108, 111, 103, 117, 101, 58, 32,
-      48, 58, 48, 48, 58, 48, 48, 58, 48, 48, 44, 48, 58, 48, 48, 58, 48, 48, 58, 48, 48, 44};
+  private static final byte[] SSA_PREFIX =
+      new byte[] {
+        68, 105, 97, 108, 111, 103, 117, 101, 58, 32, 48, 58, 48, 48, 58, 48, 48, 58, 48, 48, 44,
+        48, 58, 48, 48, 58, 48, 48, 58, 48, 48, 44
+      };
   /**
    * The byte offset of the end timecode in {@link #SSA_PREFIX}.
    */
@@ -290,14 +296,6 @@ public class MatroskaExtractor implements Extractor {
    */
   private static final long SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR = 10000;
   /**
-   * A special end timecode indicating that an SSA subtitle should be displayed until the next
-   * subtitle, or until the end of the media in the case of the last subtitle.
-   * <p>
-   * Equivalent to the UTF-8 string: "          ".
-   */
-  private static final byte[] SSA_TIMECODE_EMPTY =
-      new byte[] {32, 32, 32, 32, 32, 32, 32, 32, 32, 32};
-  /**
    * The format of an SSA timecode.
    */
   private static final String SSA_TIMECODE_FORMAT = "%01d:%02d:%02d:%02d";
@@ -334,7 +332,7 @@ public class MatroskaExtractor implements Extractor {
   private final ParsableByteArray subtitleSample;
   private final ParsableByteArray encryptionInitializationVector;
   private final ParsableByteArray encryptionSubsampleData;
-  private final ParsableByteArray blockAddData;
+  private final ParsableByteArray blockAdditionalData;
   private ByteBuffer encryptionSubsampleDataBuffer;
 
   private long segmentContentSize;
@@ -362,31 +360,33 @@ public class MatroskaExtractor implements Extractor {
   private LongArray cueClusterPositions;
   private boolean seenClusterPositionForCurrentCuePoint;
 
+  // Reading state.
+  private boolean haveOutputSample;
+
   // Block reading state.
   private int blockState;
   private long blockTimeUs;
   private long blockDurationUs;
-  private int blockLacingSampleIndex;
-  private int blockLacingSampleCount;
-  private int[] blockLacingSampleSizes;
+  private int blockSampleIndex;
+  private int blockSampleCount;
+  private int[] blockSampleSizes;
   private int blockTrackNumber;
   private int blockTrackNumberLength;
   @C.BufferFlags
   private int blockFlags;
-  private int blockAddId;
+  private int blockAdditionalId;
+  private boolean blockHasReferenceBlock;
 
-  // Sample reading state.
+  // Sample writing state.
   private int sampleBytesRead;
+  private int sampleBytesWritten;
+  private int sampleCurrentNalBytesRemaining;
   private boolean sampleEncodingHandled;
   private boolean sampleSignalByteRead;
-  private boolean sampleInitializationVectorRead;
   private boolean samplePartitionCountRead;
-  private byte sampleSignalByte;
   private int samplePartitionCount;
-  private int sampleCurrentNalBytesRemaining;
-  private int sampleBytesWritten;
-  private boolean sampleRead;
-  private boolean sampleSeenReferenceBlock;
+  private byte sampleSignalByte;
+  private boolean sampleInitializationVectorRead;
 
   // Extractor outputs.
   private ExtractorOutput extractorOutput;
@@ -414,7 +414,7 @@ public class MatroskaExtractor implements Extractor {
     subtitleSample = new ParsableByteArray();
     encryptionInitializationVector = new ParsableByteArray(ENCRYPTION_IV_SIZE);
     encryptionSubsampleData = new ParsableByteArray();
-    blockAddData = new ParsableByteArray();
+    blockAdditionalData = new ParsableByteArray();
   }
 
   @Override
@@ -434,7 +434,7 @@ public class MatroskaExtractor implements Extractor {
     blockState = BLOCK_STATE_START;
     reader.reset();
     varintReader.reset();
-    resetSample();
+    resetWriteSampleData();
     for (int i = 0; i < tracks.size(); i++) {
       tracks.valueAt(i).reset();
     }
@@ -448,9 +448,9 @@ public class MatroskaExtractor implements Extractor {
   @Override
   public final int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    sampleRead = false;
+    haveOutputSample = false;
     boolean continueReading = true;
-    while (continueReading && !sampleRead) {
+    while (continueReading && !haveOutputSample) {
       continueReading = reader.read(input);
       if (continueReading && maybeSeekForCues(seekPosition, input.getPosition())) {
         return Extractor.RESULT_SEEK;
@@ -625,7 +625,7 @@ public class MatroskaExtractor implements Extractor {
         }
         break;
       case ID_BLOCK_GROUP:
-        sampleSeenReferenceBlock = false;
+        blockHasReferenceBlock = false;
         break;
       case ID_CONTENT_ENCODING:
         // TODO: check and fail if more than one content encoding is present.
@@ -682,11 +682,24 @@ public class MatroskaExtractor implements Extractor {
           // We've skipped this block (due to incompatible track number).
           return;
         }
-        // If the ReferenceBlock element was not found for this sample, then it is a keyframe.
-        if (!sampleSeenReferenceBlock) {
-          blockFlags |= C.BUFFER_FLAG_KEY_FRAME;
+        // Commit sample metadata.
+        int sampleOffset = 0;
+        for (int i = 0; i < blockSampleCount; i++) {
+          sampleOffset += blockSampleSizes[i];
+        }
+        Track track = tracks.get(blockTrackNumber);
+        for (int i = 0; i < blockSampleCount; i++) {
+          long sampleTimeUs = blockTimeUs + (i * track.defaultSampleDurationNs) / 1000;
+          int sampleFlags = blockFlags;
+          if (i == 0 && !blockHasReferenceBlock) {
+            // If the ReferenceBlock element was not found in this block, then the first frame is a
+            // keyframe.
+            sampleFlags |= C.BUFFER_FLAG_KEY_FRAME;
+          }
+          int sampleSize = blockSampleSizes[i];
+          sampleOffset -= sampleSize; // The offset is to the end of the sample.
+          commitSampleToOutput(track, sampleTimeUs, sampleFlags, sampleSize, sampleOffset);
         }
-        commitSampleToOutput(tracks.get(blockTrackNumber), blockTimeUs);
         blockState = BLOCK_STATE_START;
         break;
       case ID_CONTENT_ENCODING:
@@ -795,7 +808,7 @@ public class MatroskaExtractor implements Extractor {
         currentTrack.audioBitDepth = (int) value;
         break;
       case ID_REFERENCE_BLOCK:
-        sampleSeenReferenceBlock = true;
+        blockHasReferenceBlock = true;
         break;
       case ID_CONTENT_ENCODING_ORDER:
         // This extractor only supports one ContentEncoding element and hence the order has to be 0.
@@ -937,7 +950,7 @@ public class MatroskaExtractor implements Extractor {
         }
         break;
       case ID_BLOCK_ADD_ID:
-        blockAddId = (int) value;
+        blockAdditionalId = (int) value;
         break;
       default:
         break;
@@ -1093,43 +1106,38 @@ public class MatroskaExtractor implements Extractor {
           readScratch(input, 3);
           int lacing = (scratch.data[2] & 0x06) >> 1;
           if (lacing == LACING_NONE) {
-            blockLacingSampleCount = 1;
-            blockLacingSampleSizes = ensureArrayCapacity(blockLacingSampleSizes, 1);
-            blockLacingSampleSizes[0] = contentSize - blockTrackNumberLength - 3;
+            blockSampleCount = 1;
+            blockSampleSizes = ensureArrayCapacity(blockSampleSizes, 1);
+            blockSampleSizes[0] = contentSize - blockTrackNumberLength - 3;
           } else {
-            if (id != ID_SIMPLE_BLOCK) {
-              throw new ParserException("Lacing only supported in SimpleBlocks.");
-            }
-
             // Read the sample count (1 byte).
             readScratch(input, 4);
-            blockLacingSampleCount = (scratch.data[3] & 0xFF) + 1;
-            blockLacingSampleSizes =
-                ensureArrayCapacity(blockLacingSampleSizes, blockLacingSampleCount);
+            blockSampleCount = (scratch.data[3] & 0xFF) + 1;
+            blockSampleSizes = ensureArrayCapacity(blockSampleSizes, blockSampleCount);
             if (lacing == LACING_FIXED_SIZE) {
               int blockLacingSampleSize =
-                  (contentSize - blockTrackNumberLength - 4) / blockLacingSampleCount;
-              Arrays.fill(blockLacingSampleSizes, 0, blockLacingSampleCount, blockLacingSampleSize);
+                  (contentSize - blockTrackNumberLength - 4) / blockSampleCount;
+              Arrays.fill(blockSampleSizes, 0, blockSampleCount, blockLacingSampleSize);
             } else if (lacing == LACING_XIPH) {
               int totalSamplesSize = 0;
               int headerSize = 4;
-              for (int sampleIndex = 0; sampleIndex < blockLacingSampleCount - 1; sampleIndex++) {
-                blockLacingSampleSizes[sampleIndex] = 0;
+              for (int sampleIndex = 0; sampleIndex < blockSampleCount - 1; sampleIndex++) {
+                blockSampleSizes[sampleIndex] = 0;
                 int byteValue;
                 do {
                   readScratch(input, ++headerSize);
                   byteValue = scratch.data[headerSize - 1] & 0xFF;
-                  blockLacingSampleSizes[sampleIndex] += byteValue;
+                  blockSampleSizes[sampleIndex] += byteValue;
                 } while (byteValue == 0xFF);
-                totalSamplesSize += blockLacingSampleSizes[sampleIndex];
+                totalSamplesSize += blockSampleSizes[sampleIndex];
               }
-              blockLacingSampleSizes[blockLacingSampleCount - 1] =
+              blockSampleSizes[blockSampleCount - 1] =
                   contentSize - blockTrackNumberLength - headerSize - totalSamplesSize;
             } else if (lacing == LACING_EBML) {
               int totalSamplesSize = 0;
               int headerSize = 4;
-              for (int sampleIndex = 0; sampleIndex < blockLacingSampleCount - 1; sampleIndex++) {
-                blockLacingSampleSizes[sampleIndex] = 0;
+              for (int sampleIndex = 0; sampleIndex < blockSampleCount - 1; sampleIndex++) {
+                blockSampleSizes[sampleIndex] = 0;
                 readScratch(input, ++headerSize);
                 if (scratch.data[headerSize - 1] == 0) {
                   throw new ParserException("No valid varint length mask found");
@@ -1157,11 +1165,13 @@ public class MatroskaExtractor implements Extractor {
                   throw new ParserException("EBML lacing sample size out of range.");
                 }
                 int intReadValue = (int) readValue;
-                blockLacingSampleSizes[sampleIndex] = sampleIndex == 0
-                    ? intReadValue : blockLacingSampleSizes[sampleIndex - 1] + intReadValue;
-                totalSamplesSize += blockLacingSampleSizes[sampleIndex];
+                blockSampleSizes[sampleIndex] =
+                    sampleIndex == 0
+                        ? intReadValue
+                        : blockSampleSizes[sampleIndex - 1] + intReadValue;
+                totalSamplesSize += blockSampleSizes[sampleIndex];
               }
-              blockLacingSampleSizes[blockLacingSampleCount - 1] =
+              blockSampleSizes[blockSampleCount - 1] =
                   contentSize - blockTrackNumberLength - headerSize - totalSamplesSize;
             } else {
               // Lacing is always in the range 0--3.
@@ -1177,23 +1187,31 @@ public class MatroskaExtractor implements Extractor {
           blockFlags = (isKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0)
               | (isInvisible ? C.BUFFER_FLAG_DECODE_ONLY : 0);
           blockState = BLOCK_STATE_DATA;
-          blockLacingSampleIndex = 0;
+          blockSampleIndex = 0;
         }
 
         if (id == ID_SIMPLE_BLOCK) {
-          // For SimpleBlock, we have metadata for each sample here.
-          while (blockLacingSampleIndex < blockLacingSampleCount) {
-            writeSampleData(input, track, blockLacingSampleSizes[blockLacingSampleIndex]);
-            long sampleTimeUs = blockTimeUs
-                + (blockLacingSampleIndex * track.defaultSampleDurationNs) / 1000;
-            commitSampleToOutput(track, sampleTimeUs);
-            blockLacingSampleIndex++;
+          // For SimpleBlock, we can write sample data and immediately commit the corresponding
+          // sample metadata.
+          while (blockSampleIndex < blockSampleCount) {
+            int sampleSize = writeSampleData(input, track, blockSampleSizes[blockSampleIndex]);
+            long sampleTimeUs =
+                blockTimeUs + (blockSampleIndex * track.defaultSampleDurationNs) / 1000;
+            commitSampleToOutput(track, sampleTimeUs, blockFlags, sampleSize, /* offset= */ 0);
+            blockSampleIndex++;
           }
           blockState = BLOCK_STATE_START;
         } else {
-          // For Block, we send the metadata at the end of the BlockGroup element since we'll know
-          // if the sample is a keyframe or not only at that point.
-          writeSampleData(input, track, blockLacingSampleSizes[0]);
+          // For Block, we need to wait until the end of the BlockGroup element before committing
+          // sample metadata. This is so that we can handle ReferenceBlock (which can be used to
+          // infer whether the first sample in the block is a keyframe), and BlockAdditions (which
+          // can contain additional sample data to append) contained in the block group. Just output
+          // the sample data, storing the final sample sizes for when we commit the metadata.
+          while (blockSampleIndex < blockSampleCount) {
+            blockSampleSizes[blockSampleIndex] =
+                writeSampleData(input, track, blockSampleSizes[blockSampleIndex]);
+            blockSampleIndex++;
+          }
         }
 
         break;
@@ -1201,7 +1219,8 @@ public class MatroskaExtractor implements Extractor {
         if (blockState != BLOCK_STATE_DATA) {
           return;
         }
-        handleBlockAdditionalData(tracks.get(blockTrackNumber), blockAddId, input, contentSize);
+        handleBlockAdditionalData(
+            tracks.get(blockTrackNumber), blockAdditionalId, input, contentSize);
         break;
       default:
         throw new ParserException("Unexpected id: " + id);
@@ -1209,59 +1228,52 @@ public class MatroskaExtractor implements Extractor {
   }
 
   protected void handleBlockAdditionalData(
-      Track track, int blockAddId, ExtractorInput input, int contentSize)
+      Track track, int blockAdditionalId, ExtractorInput input, int contentSize)
       throws IOException, InterruptedException {
-    if (blockAddId == BLOCK_ADD_ID_VP9_ITU_T_35 && CODEC_ID_VP9.equals(track.codecId)) {
-      blockAddData.reset(contentSize);
-      input.readFully(blockAddData.data, 0, contentSize);
+    if (blockAdditionalId == BLOCK_ADDITIONAL_ID_VP9_ITU_T_35
+        && CODEC_ID_VP9.equals(track.codecId)) {
+      blockAdditionalData.reset(contentSize);
+      input.readFully(blockAdditionalData.data, 0, contentSize);
     } else {
       // Unhandled block additional data.
       input.skipFully(contentSize);
     }
   }
 
-  private void commitSampleToOutput(Track track, long timeUs) {
+  private void commitSampleToOutput(
+      Track track, long timeUs, @C.BufferFlags int flags, int size, int offset) {
     if (track.trueHdSampleRechunker != null) {
-      track.trueHdSampleRechunker.sampleMetadata(track, timeUs);
+      track.trueHdSampleRechunker.sampleMetadata(track, timeUs, flags, size, offset);
     } else {
-      if (CODEC_ID_SUBRIP.equals(track.codecId)) {
-        commitSubtitleSample(
-            track,
-            SUBRIP_TIMECODE_FORMAT,
-            SUBRIP_PREFIX_END_TIMECODE_OFFSET,
-            SUBRIP_TIMECODE_LAST_VALUE_SCALING_FACTOR,
-            SUBRIP_TIMECODE_EMPTY);
-      } else if (CODEC_ID_ASS.equals(track.codecId)) {
-        commitSubtitleSample(
-            track,
-            SSA_TIMECODE_FORMAT,
-            SSA_PREFIX_END_TIMECODE_OFFSET,
-            SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR,
-            SSA_TIMECODE_EMPTY);
+      if (CODEC_ID_SUBRIP.equals(track.codecId) || CODEC_ID_ASS.equals(track.codecId)) {
+        if (blockSampleCount > 1) {
+          Log.w(TAG, "Skipping subtitle sample in laced block.");
+        } else if (durationUs == C.TIME_UNSET) {
+          Log.w(TAG, "Skipping subtitle sample with no duration.");
+        } else {
+          setSubtitleEndTime(track.codecId, durationUs, subtitleSample.data);
+          // Note: If we ever want to support DRM protected subtitles then we'll need to output the
+          // appropriate encryption data here.
+          track.output.sampleData(subtitleSample, subtitleSample.limit());
+          size += subtitleSample.limit();
+        }
       }
-      if ((blockFlags & C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA) != 0) {
-        // Append supplemental data.
-        int size = blockAddData.limit();
-        track.output.sampleData(blockAddData, size);
-        sampleBytesWritten += size;
+
+      if ((flags & C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA) != 0) {
+        if (blockSampleCount > 1) {
+          // There were multiple samples in the block. Appending the additional data to the last
+          // sample doesn't make sense. Skip instead.
+          flags &= ~C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA;
+        } else {
+          // Append supplemental data.
+          int blockAdditionalSize = blockAdditionalData.limit();
+          track.output.sampleData(blockAdditionalData, blockAdditionalSize);
+          size += blockAdditionalSize;
+        }
       }
-      track.output.sampleMetadata(timeUs, blockFlags, sampleBytesWritten, 0, track.cryptoData);
+      track.output.sampleMetadata(timeUs, flags, size, offset, track.cryptoData);
     }
-    sampleRead = true;
-    resetSample();
-  }
-
-  private void resetSample() {
-    sampleBytesRead = 0;
-    sampleBytesWritten = 0;
-    sampleCurrentNalBytesRemaining = 0;
-    sampleEncodingHandled = false;
-    sampleSignalByteRead = false;
-    samplePartitionCountRead = false;
-    samplePartitionCount = 0;
-    sampleSignalByte = (byte) 0;
-    sampleInitializationVectorRead = false;
-    sampleStrippedBytes.reset();
+    haveOutputSample = true;
   }
 
   /**
@@ -1281,14 +1293,24 @@ public class MatroskaExtractor implements Extractor {
     scratch.setLimit(requiredLength);
   }
 
-  private void writeSampleData(ExtractorInput input, Track track, int size)
+  /**
+   * Writes data for a single sample to the track output.
+   *
+   * @param input The input from which to read sample data.
+   * @param track The track to output the sample to.
+   * @param size The size of the sample data on the input side.
+   * @return The final size of the written sample.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private int writeSampleData(ExtractorInput input, Track track, int size)
       throws IOException, InterruptedException {
     if (CODEC_ID_SUBRIP.equals(track.codecId)) {
       writeSubtitleSampleData(input, SUBRIP_PREFIX, size);
-      return;
+      return finishWriteSampleData();
     } else if (CODEC_ID_ASS.equals(track.codecId)) {
       writeSubtitleSampleData(input, SSA_PREFIX, size);
-      return;
+      return finishWriteSampleData();
     }
 
     TrackOutput output = track.output;
@@ -1380,7 +1402,7 @@ public class MatroskaExtractor implements Extractor {
 
       if (track.maxBlockAdditionId > 0) {
         blockFlags |= C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA;
-        blockAddData.reset();
+        blockAdditionalData.reset();
         // If there is supplemental data, the structure of the sample data is:
         // sample size (4 bytes) || sample data || supplemental data
         scratch.reset(/* limit= */ 4);
@@ -1413,8 +1435,9 @@ public class MatroskaExtractor implements Extractor {
       while (sampleBytesRead < size) {
         if (sampleCurrentNalBytesRemaining == 0) {
           // Read the NAL length so that we know where we find the next one.
-          readToTarget(input, nalLengthData, nalUnitLengthFieldLengthDiff,
-              nalUnitLengthFieldLength);
+          writeToTarget(
+              input, nalLengthData, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+          sampleBytesRead += nalUnitLengthFieldLength;
           nalLength.setPosition(0);
           sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
           // Write a start code for the current NAL unit.
@@ -1423,17 +1446,21 @@ public class MatroskaExtractor implements Extractor {
           sampleBytesWritten += 4;
         } else {
           // Write the payload of the NAL unit.
-          sampleCurrentNalBytesRemaining -=
-              readToOutput(input, output, sampleCurrentNalBytesRemaining);
+          int bytesWritten = writeToOutput(input, output, sampleCurrentNalBytesRemaining);
+          sampleBytesRead += bytesWritten;
+          sampleBytesWritten += bytesWritten;
+          sampleCurrentNalBytesRemaining -= bytesWritten;
         }
       }
     } else {
       if (track.trueHdSampleRechunker != null) {
         Assertions.checkState(sampleStrippedBytes.limit() == 0);
-        track.trueHdSampleRechunker.startSample(input, blockFlags, size);
+        track.trueHdSampleRechunker.startSample(input);
       }
       while (sampleBytesRead < size) {
-        readToOutput(input, output, size - sampleBytesRead);
+        int bytesWritten = writeToOutput(input, output, size - sampleBytesRead);
+        sampleBytesRead += bytesWritten;
+        sampleBytesWritten += bytesWritten;
       }
     }
 
@@ -1448,6 +1475,32 @@ public class MatroskaExtractor implements Extractor {
       output.sampleData(vorbisNumPageSamples, 4);
       sampleBytesWritten += 4;
     }
+
+    return finishWriteSampleData();
+  }
+
+  /**
+   * Called by {@link #writeSampleData(ExtractorInput, Track, int)} when the sample has been
+   * written. Returns the final sample size and resets state for the next sample.
+   */
+  private int finishWriteSampleData() {
+    int sampleSize = sampleBytesWritten;
+    resetWriteSampleData();
+    return sampleSize;
+  }
+
+  /** Resets state used by {@link #writeSampleData(ExtractorInput, Track, int)}. */
+  private void resetWriteSampleData() {
+    sampleBytesRead = 0;
+    sampleBytesWritten = 0;
+    sampleCurrentNalBytesRemaining = 0;
+    sampleEncodingHandled = false;
+    sampleSignalByteRead = false;
+    samplePartitionCountRead = false;
+    samplePartitionCount = 0;
+    sampleSignalByte = (byte) 0;
+    sampleInitializationVectorRead = false;
+    sampleStrippedBytes.reset();
   }
 
   private void writeSubtitleSampleData(ExtractorInput input, byte[] samplePrefix, int size)
@@ -1466,67 +1519,89 @@ public class MatroskaExtractor implements Extractor {
     // the correct end timecode, which we might not have yet.
   }
 
-  private void commitSubtitleSample(Track track, String timecodeFormat, int endTimecodeOffset,
-      long lastTimecodeValueScalingFactor, byte[] emptyTimecode) {
-    setSampleDuration(subtitleSample.data, blockDurationUs, timecodeFormat, endTimecodeOffset,
-        lastTimecodeValueScalingFactor, emptyTimecode);
-    // Note: If we ever want to support DRM protected subtitles then we'll need to output the
-    // appropriate encryption data here.
-    track.output.sampleData(subtitleSample, subtitleSample.limit());
-    sampleBytesWritten += subtitleSample.limit();
+  /**
+   * Overwrites the end timecode in {@code subtitleData} with the correctly formatted time derived
+   * from {@code durationUs}.
+   *
+   * <p>See documentation on {@link #SSA_DIALOGUE_FORMAT} and {@link #SUBRIP_PREFIX} for why we use
+   * the duration as the end timecode.
+   *
+   * @param codecId The subtitle codec; must be {@link #CODEC_ID_SUBRIP} or {@link #CODEC_ID_ASS}.
+   * @param durationUs The duration of the sample, in microseconds.
+   * @param subtitleData The subtitle sample in which to overwrite the end timecode (output
+   *     parameter).
+   */
+  private static void setSubtitleEndTime(String codecId, long durationUs, byte[] subtitleData) {
+    byte[] endTimecode;
+    int endTimecodeOffset;
+    switch (codecId) {
+      case CODEC_ID_SUBRIP:
+        endTimecode =
+            formatSubtitleTimecode(
+                durationUs, SUBRIP_TIMECODE_FORMAT, SUBRIP_TIMECODE_LAST_VALUE_SCALING_FACTOR);
+        endTimecodeOffset = SUBRIP_PREFIX_END_TIMECODE_OFFSET;
+        break;
+      case CODEC_ID_ASS:
+        endTimecode =
+            formatSubtitleTimecode(
+                durationUs, SSA_TIMECODE_FORMAT, SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR);
+        endTimecodeOffset = SSA_PREFIX_END_TIMECODE_OFFSET;
+        break;
+      default:
+        throw new IllegalArgumentException();
+    }
+    System.arraycopy(endTimecode, 0, subtitleData, endTimecodeOffset, endTimecode.length);
   }
 
-  private static void setSampleDuration(byte[] subripSampleData, long durationUs,
-      String timecodeFormat, int endTimecodeOffset, long lastTimecodeValueScalingFactor,
-      byte[] emptyTimecode) {
+  /**
+   * Formats {@code timeUs} using {@code timecodeFormat}, and sets it as the end timecode in {@code
+   * subtitleSampleData}.
+   */
+  private static byte[] formatSubtitleTimecode(
+      long timeUs, String timecodeFormat, long lastTimecodeValueScalingFactor) {
+    Assertions.checkArgument(timeUs != C.TIME_UNSET);
     byte[] timeCodeData;
-    if (durationUs == C.TIME_UNSET) {
-      timeCodeData = emptyTimecode;
-    } else {
-      int hours = (int) (durationUs / (3600 * C.MICROS_PER_SECOND));
-      durationUs -= (hours * 3600 * C.MICROS_PER_SECOND);
-      int minutes = (int) (durationUs / (60 * C.MICROS_PER_SECOND));
-      durationUs -= (minutes * 60 * C.MICROS_PER_SECOND);
-      int seconds = (int) (durationUs / C.MICROS_PER_SECOND);
-      durationUs -= (seconds * C.MICROS_PER_SECOND);
-      int lastValue = (int) (durationUs / lastTimecodeValueScalingFactor);
-      timeCodeData = Util.getUtf8Bytes(String.format(Locale.US, timecodeFormat, hours, minutes,
-          seconds, lastValue));
-    }
-    System.arraycopy(timeCodeData, 0, subripSampleData, endTimecodeOffset, emptyTimecode.length);
+    int hours = (int) (timeUs / (3600 * C.MICROS_PER_SECOND));
+    timeUs -= (hours * 3600 * C.MICROS_PER_SECOND);
+    int minutes = (int) (timeUs / (60 * C.MICROS_PER_SECOND));
+    timeUs -= (minutes * 60 * C.MICROS_PER_SECOND);
+    int seconds = (int) (timeUs / C.MICROS_PER_SECOND);
+    timeUs -= (seconds * C.MICROS_PER_SECOND);
+    int lastValue = (int) (timeUs / lastTimecodeValueScalingFactor);
+    timeCodeData =
+        Util.getUtf8Bytes(
+            String.format(Locale.US, timecodeFormat, hours, minutes, seconds, lastValue));
+    return timeCodeData;
   }
 
   /**
    * Writes {@code length} bytes of sample data into {@code target} at {@code offset}, consisting of
    * pending {@link #sampleStrippedBytes} and any remaining data read from {@code input}.
    */
-  private void readToTarget(ExtractorInput input, byte[] target, int offset, int length)
+  private void writeToTarget(ExtractorInput input, byte[] target, int offset, int length)
       throws IOException, InterruptedException {
     int pendingStrippedBytes = Math.min(length, sampleStrippedBytes.bytesLeft());
     input.readFully(target, offset + pendingStrippedBytes, length - pendingStrippedBytes);
     if (pendingStrippedBytes > 0) {
       sampleStrippedBytes.readBytes(target, offset, pendingStrippedBytes);
     }
-    sampleBytesRead += length;
   }
 
   /**
    * Outputs up to {@code length} bytes of sample data to {@code output}, consisting of either
    * {@link #sampleStrippedBytes} or data read from {@code input}.
    */
-  private int readToOutput(ExtractorInput input, TrackOutput output, int length)
+  private int writeToOutput(ExtractorInput input, TrackOutput output, int length)
       throws IOException, InterruptedException {
-    int bytesRead;
+    int bytesWritten;
     int strippedBytesLeft = sampleStrippedBytes.bytesLeft();
     if (strippedBytesLeft > 0) {
-      bytesRead = Math.min(length, strippedBytesLeft);
-      output.sampleData(sampleStrippedBytes, bytesRead);
+      bytesWritten = Math.min(length, strippedBytesLeft);
+      output.sampleData(sampleStrippedBytes, bytesWritten);
     } else {
-      bytesRead = output.sampleData(input, length, false);
+      bytesWritten = output.sampleData(input, length, false);
     }
-    sampleBytesRead += bytesRead;
-    sampleBytesWritten += bytesRead;
-    return bytesRead;
+    return bytesWritten;
   }
 
   /**
@@ -1560,6 +1635,16 @@ public class MatroskaExtractor implements Extractor {
     sizes[cuePointsSize - 1] =
         (int) (segmentContentPosition + segmentContentSize - offsets[cuePointsSize - 1]);
     durationsUs[cuePointsSize - 1] = durationUs - timesUs[cuePointsSize - 1];
+
+    long lastDurationUs = durationsUs[cuePointsSize - 1];
+    if (lastDurationUs <= 0) {
+      Log.w(TAG, "Discarding last cue point with unexpected duration: " + lastDurationUs);
+      sizes = Arrays.copyOf(sizes, sizes.length - 1);
+      offsets = Arrays.copyOf(offsets, offsets.length - 1);
+      durationsUs = Arrays.copyOf(durationsUs, durationsUs.length - 1);
+      timesUs = Arrays.copyOf(timesUs, timesUs.length - 1);
+    }
+
     cueTimesUs = null;
     cueClusterPositions = null;
     return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
@@ -1701,10 +1786,11 @@ public class MatroskaExtractor implements Extractor {
     private final byte[] syncframePrefix;
 
     private boolean foundSyncframe;
-    private int sampleCount;
+    private int chunkSampleCount;
+    private long chunkTimeUs;
+    private @C.BufferFlags int chunkFlags;
     private int chunkSize;
-    private long timeUs;
-    private @C.BufferFlags int blockFlags;
+    private int chunkOffset;
 
     public TrueHdSampleRechunker() {
       syncframePrefix = new byte[Ac3Util.TRUEHD_SYNCFRAME_PREFIX_LENGTH];
@@ -1712,47 +1798,46 @@ public class MatroskaExtractor implements Extractor {
 
     public void reset() {
       foundSyncframe = false;
+      chunkSampleCount = 0;
     }
 
-    public void startSample(ExtractorInput input, @C.BufferFlags int blockFlags, int size)
-        throws IOException, InterruptedException {
-      if (!foundSyncframe) {
-        input.peekFully(syncframePrefix, 0, Ac3Util.TRUEHD_SYNCFRAME_PREFIX_LENGTH);
-        input.resetPeekPosition();
-        if (Ac3Util.parseTrueHdSyncframeAudioSampleCount(syncframePrefix) == 0) {
-          return;
-        }
-        foundSyncframe = true;
-        sampleCount = 0;
+    public void startSample(ExtractorInput input) throws IOException, InterruptedException {
+      if (foundSyncframe) {
+        return;
       }
-      if (sampleCount == 0) {
-        // This is the first sample in the chunk, so reset the block flags and chunk size.
-        this.blockFlags = blockFlags;
-        chunkSize = 0;
+      input.peekFully(syncframePrefix, 0, Ac3Util.TRUEHD_SYNCFRAME_PREFIX_LENGTH);
+      input.resetPeekPosition();
+      if (Ac3Util.parseTrueHdSyncframeAudioSampleCount(syncframePrefix) == 0) {
+        return;
       }
-      chunkSize += size;
+      foundSyncframe = true;
     }
 
-    public void sampleMetadata(Track track, long timeUs) {
+    public void sampleMetadata(
+        Track track, long timeUs, @C.BufferFlags int flags, int size, int offset) {
       if (!foundSyncframe) {
         return;
       }
-      if (sampleCount++ == 0) {
-        // This is the first sample in the chunk, so update the timestamp.
-        this.timeUs = timeUs;
+      if (chunkSampleCount++ == 0) {
+        // This is the first sample in the chunk.
+        chunkTimeUs = timeUs;
+        chunkFlags = flags;
+        chunkSize = 0;
       }
-      if (sampleCount < Ac3Util.TRUEHD_RECHUNK_SAMPLE_COUNT) {
+      chunkSize += size;
+      chunkOffset = offset; // The offset is to the end of the sample.
+      if (chunkSampleCount >= Ac3Util.TRUEHD_RECHUNK_SAMPLE_COUNT) {
         // We haven't read enough samples to output a chunk.
         return;
       }
-      track.output.sampleMetadata(this.timeUs, blockFlags, chunkSize, 0, track.cryptoData);
-      sampleCount = 0;
+      outputPendingSampleMetadata(track);
     }
 
     public void outputPendingSampleMetadata(Track track) {
-      if (foundSyncframe && sampleCount > 0) {
-        track.output.sampleMetadata(this.timeUs, blockFlags, chunkSize, 0, track.cryptoData);
-        sampleCount = 0;
+      if (chunkSampleCount > 0) {
+        track.output.sampleMetadata(
+            chunkTimeUs, chunkFlags, chunkSize, chunkOffset, track.cryptoData);
+        chunkSampleCount = 0;
       }
     }
   }
@@ -1893,9 +1978,9 @@ public class MatroskaExtractor implements Extractor {
           initializationData = new ArrayList<>(3);
           initializationData.add(codecPrivate);
           initializationData.add(
-              ByteBuffer.allocate(8).order(ByteOrder.nativeOrder()).putLong(codecDelayNs).array());
+              ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(codecDelayNs).array());
           initializationData.add(
-              ByteBuffer.allocate(8).order(ByteOrder.nativeOrder()).putLong(seekPreRollNs).array());
+              ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(seekPreRollNs).array());
           break;
         case CODEC_ID_AAC:
           mimeType = MimeTypes.AUDIO_AAC;
@@ -2097,6 +2182,7 @@ public class MatroskaExtractor implements Extractor {
     }
 
     /** Returns the HDR Static Info as defined in CTA-861.3. */
+    @Nullable
     private byte[] getHdrStaticInfo() {
       // Are all fields present.
       if (primaryRChromaticityX == Format.NO_VALUE || primaryRChromaticityY == Format.NO_VALUE
@@ -2109,7 +2195,7 @@ public class MatroskaExtractor implements Extractor {
       }
 
       byte[] hdrStaticInfoData = new byte[25];
-      ByteBuffer hdrStaticInfo = ByteBuffer.wrap(hdrStaticInfoData);
+      ByteBuffer hdrStaticInfo = ByteBuffer.wrap(hdrStaticInfoData).order(ByteOrder.LITTLE_ENDIAN);
       hdrStaticInfo.put((byte) 0);  // Type.
       hdrStaticInfo.putShort((short) ((primaryRChromaticityX * MAX_CHROMATICITY) + 0.5f));
       hdrStaticInfo.putShort((short) ((primaryRChromaticityY * MAX_CHROMATICITY) + 0.5f));
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
index f400720..4a5feb5 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
@@ -22,8 +22,7 @@ import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 /**
  * MP3 seeker that doesn't rely on metadata and seeks assuming the source has a constant bitrate.
  */
-/* package */ final class ConstantBitrateSeeker extends ConstantBitrateSeekMap
-    implements Mp3Extractor.Seeker {
+/* package */ final class ConstantBitrateSeeker extends ConstantBitrateSeekMap implements Seeker {
 
   /**
    * @param inputLength The length of the stream in bytes, or {@link C#LENGTH_UNSET} if unknown.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
index 868c1d9..1b62748 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
@@ -22,7 +22,7 @@ import com.google.android.exoplayer2.metadata.id3.MlltFrame;
 import com.google.android.exoplayer2.util.Util;
 
 /** MP3 seeker that uses metadata from an {@link MlltFrame}. */
-/* package */ final class MlltSeeker implements Mp3Extractor.Seeker {
+/* package */ final class MlltSeeker implements Seeker {
 
   /**
    * Returns an {@link MlltSeeker} for seeking in the stream.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index ecff963..7a25677 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -28,8 +28,8 @@ import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
 import com.google.android.exoplayer2.extractor.Id3Peeker;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.PositionHolder;
-import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.mp3.Seeker.UnseekableSeeker;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder.FramePredicate;
@@ -113,7 +113,8 @@ public final class Mp3Extractor implements Extractor {
   private int synchronizedHeaderData;
 
   private Metadata metadata;
-  private Seeker seeker;
+  @Nullable private Seeker seeker;
+  private boolean disableSeeking;
   private long basisTimeUs;
   private long samplesRead;
   private long firstSamplePosition;
@@ -187,14 +188,19 @@ public final class Mp3Extractor implements Extractor {
       // takes priority as it can provide greater precision.
       Seeker seekFrameSeeker = maybeReadSeekFrame(input);
       Seeker metadataSeeker = maybeHandleSeekMetadata(metadata, input.getPosition());
-      if (metadataSeeker != null) {
-        seeker = metadataSeeker;
-      } else if (seekFrameSeeker != null) {
-        seeker = seekFrameSeeker;
-      }
-      if (seeker == null
-          || (!seeker.isSeekable() && (flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) != 0)) {
-        seeker = getConstantBitrateSeeker(input);
+
+      if (disableSeeking) {
+        seeker = new UnseekableSeeker();
+      } else {
+        if (metadataSeeker != null) {
+          seeker = metadataSeeker;
+        } else if (seekFrameSeeker != null) {
+          seeker = seekFrameSeeker;
+        }
+        if (seeker == null
+            || (!seeker.isSeekable() && (flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) != 0)) {
+          seeker = getConstantBitrateSeeker(input);
+        }
       }
       extractorOutput.seekMap(seeker);
       trackOutput.format(
@@ -225,6 +231,15 @@ public final class Mp3Extractor implements Extractor {
     return readSample(input);
   }
 
+  /**
+   * Disables the extractor from being able to seek through the media.
+   *
+   * <p>Please note that this needs to be called before {@link #read}.
+   */
+  public void disableSeeking() {
+    disableSeeking = true;
+  }
+
   // Internal methods.
 
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
@@ -463,26 +478,5 @@ public final class Mp3Extractor implements Extractor {
     return null;
   }
 
-  /**
-   * {@link SeekMap} that provides the end position of audio data and also allows mapping from
-   * position (byte offset) back to time, which can be used to work out the new sample basis
-   * timestamp after seeking and resynchronization.
-   */
-  /* package */ interface Seeker extends SeekMap {
-
-    /**
-     * Maps a position (byte offset) to a corresponding sample timestamp.
-     *
-     * @param position A seek position (byte offset) relative to the start of the stream.
-     * @return The corresponding timestamp of the next sample to be read, in microseconds.
-     */
-    long getTimeUs(long position);
-
-    /**
-     * Returns the position (byte offset) in the stream that is immediately after audio data, or
-     * {@link C#POSITION_UNSET} if not known.
-     */
-    long getDataEndPosition();
-  }
 
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Seeker.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Seeker.java
new file mode 100644
index 0000000..c5b7550
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Seeker.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp3;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.SeekMap;
+
+/**
+ * {@link SeekMap} that provides the end position of audio data and also allows mapping from
+ * position (byte offset) back to time, which can be used to work out the new sample basis timestamp
+ * after seeking and resynchronization.
+ */
+/* package */ interface Seeker extends SeekMap {
+
+  /**
+   * Maps a position (byte offset) to a corresponding sample timestamp.
+   *
+   * @param position A seek position (byte offset) relative to the start of the stream.
+   * @return The corresponding timestamp of the next sample to be read, in microseconds.
+   */
+  long getTimeUs(long position);
+
+  /**
+   * Returns the position (byte offset) in the stream that is immediately after audio data, or
+   * {@link C#POSITION_UNSET} if not known.
+   */
+  long getDataEndPosition();
+
+  /** A {@link Seeker} that does not support seeking through audio data. */
+  /* package */ class UnseekableSeeker extends SeekMap.Unseekable implements Seeker {
+
+    public UnseekableSeeker() {
+      super(/* durationUs= */ C.TIME_UNSET);
+    }
+
+    @Override
+    public long getTimeUs(long position) {
+      return 0;
+    }
+
+    @Override
+    public long getDataEndPosition() {
+      // Position unset as we do not know the data end position. Note that returning 0 doesn't work.
+      return C.POSITION_UNSET;
+    }
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
index ba8b26b..8655131 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
@@ -23,10 +23,8 @@ import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
-/**
- * MP3 seeker that uses metadata from a VBRI header.
- */
-/* package */ final class VbriSeeker implements Mp3Extractor.Seeker {
+/** MP3 seeker that uses metadata from a VBRI header. */
+/* package */ final class VbriSeeker implements Seeker {
 
   private static final String TAG = "VbriSeeker";
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
index c0c2080..db1a019 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
@@ -24,10 +24,8 @@ import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
-/**
- * MP3 seeker that uses metadata from a Xing header.
- */
-/* package */ final class XingSeeker implements Mp3Extractor.Seeker {
+/** MP3 seeker that uses metadata from a Xing header. */
+/* package */ final class XingSeeker implements Seeker {
 
   private static final String TAG = "XingSeeker";
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index f7b4040..bf05424 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -363,9 +363,7 @@ import java.util.List;
     }
     long durationUs = Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, track.timescale);
 
-    if (track.editListDurations == null || gaplessInfoHolder.hasGaplessInfo()) {
-      // There is no edit list, or we are ignoring it as we already have gapless metadata to apply.
-      // This implementation does not support applying both gapless metadata and an edit list.
+    if (track.editListDurations == null) {
       Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
       return new TrackSampleTable(
           track, offsets, sizes, maximumSize, timestamps, flags, durationUs);
@@ -1130,8 +1128,8 @@ import java.util.List;
           mimeType = mimeTypeAndInitializationData.first;
           initializationData = mimeTypeAndInitializationData.second;
           if (MimeTypes.AUDIO_AAC.equals(mimeType)) {
-            // TODO: Do we really need to do this? See [Internal: b/10903778]
-            // Update sampleRate and channelCount from the AudioSpecificConfig initialization data.
+            // Update sampleRate and channelCount from the AudioSpecificConfig initialization data,
+            // which is more reliable. See [Internal: b/10903778].
             Pair<Integer, Integer> audioSpecificConfig =
                 CodecSpecificDataUtil.parseAacAudioSpecificConfig(initializationData);
             sampleRate = audioSpecificConfig.first;
@@ -1176,6 +1174,12 @@ import java.util.List;
         initializationData = new byte[childAtomBodySize];
         parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
         parent.readBytes(initializationData, /* offset= */ 0, childAtomBodySize);
+        // Update sampleRate and channelCount from the AudioSpecificConfig initialization data,
+        // which is more reliable. See https://github.com/google/ExoPlayer/pull/6629.
+        Pair<Integer, Integer> audioSpecificConfig =
+            CodecSpecificDataUtil.parseAlacAudioSpecificConfig(initializationData);
+        sampleRate = audioSpecificConfig.first;
+        channelCount = audioSpecificConfig.second;
       }
       childPosition += childAtomSize;
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index 16f5b1f..ad58e83 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -304,13 +304,13 @@ public final class Mp4Extractor implements Extractor, SeekMap {
 
     if (shouldParseContainerAtom(atomType)) {
       long endPosition = input.getPosition() + atomSize - atomHeaderBytesRead;
+      if (atomSize != atomHeaderBytesRead && atomType == Atom.TYPE_meta) {
+        maybeSkipRemainingMetaAtomHeaderBytes(input);
+      }
       containerAtoms.push(new ContainerAtom(atomType, endPosition));
       if (atomSize == atomHeaderBytesRead) {
         processAtomEnded(endPosition);
       } else {
-        if (atomType == Atom.TYPE_meta) {
-          maybeSkipRemainingMetaAtomHeaderBytes(input);
-        }
         // Start reading the first child atom.
         enterReadingAtomHeaderState();
       }
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
index 957c3ba..b9ecaf1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtil.java
@@ -49,7 +49,8 @@ public final class PsshAtomUtil {
    * @param data The scheme specific data.
    * @return The PSSH atom.
    */
-  @SuppressWarnings("ParameterNotNullable")
+  // dereference of possibly-null reference keyId
+  @SuppressWarnings({"ParameterNotNullable", "nullness:dereference.of.nullable"})
   public static byte[] buildPsshAtom(
       UUID systemId, @Nullable UUID[] keyIds, @Nullable byte[] data) {
     int dataLength = data != null ? data.length : 0;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
index 9519378..dac74bf 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
@@ -118,10 +118,6 @@ import java.io.IOException;
         }
       }
 
-      if (inputLength != C.LENGTH_UNSET && bytesSearched + atomSize > inputLength) {
-        // The file is invalid because the atom extends past the end of the file.
-        return false;
-      }
       if (atomSize < headerSize) {
         // The file is invalid because the atom size is too small for its header.
         return false;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 7676926..0a21ddd 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -129,6 +129,8 @@ public final class Track {
         : sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
   }
 
+  // incompatible types in argument.
+  @SuppressWarnings("nullness:argument.type.incompatible")
   public Track copyWithFormat(Format format) {
     return new Track(
         id,
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
index 4efd5c5..cef274b 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
@@ -68,27 +68,28 @@ import java.util.List;
   }
 
   @Override
-  protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
-      throws IOException, InterruptedException {
+  protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData) {
     byte[] data = packet.data;
     if (streamMetadata == null) {
       streamMetadata = new FlacStreamMetadata(data, 17);
+      int maxInputSize =
+          streamMetadata.maxFrameSize == 0 ? Format.NO_VALUE : streamMetadata.maxFrameSize;
       byte[] metadata = Arrays.copyOfRange(data, 9, packet.limit());
       metadata[4] = (byte) 0x80; // Set the last metadata block flag, ignore the other blocks
       List<byte[]> initializationData = Collections.singletonList(metadata);
       setupData.format =
           Format.createAudioSampleFormat(
-              null,
+              /* id= */ null,
               MimeTypes.AUDIO_FLAC,
-              null,
-              Format.NO_VALUE,
+              /* codecs= */ null,
               streamMetadata.bitRate(),
+              maxInputSize,
               streamMetadata.channels,
               streamMetadata.sampleRate,
               initializationData,
-              null,
-              0,
-              null);
+              /* drmInitData= */ null,
+              /* selectionFlags= */ 0,
+              /* language= */ null);
     } else if ((data[0] & 0x7F) == SEEKTABLE_PACKET_TYPE) {
       flacOggSeeker = new FlacOggSeeker();
       flacOggSeeker.parseSeekTable(packet);
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 74c3187..b1d15b7 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -27,8 +27,8 @@ import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.io.IOException;
 
 /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 802e706..cd07a40 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -22,9 +22,9 @@ import com.google.android.exoplayer2.audio.Ac3Util;
 import com.google.android.exoplayer2.audio.Ac3Util.SyncFrameInfo;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java
index 1bdcf96..205d71e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Extractor.java
@@ -29,9 +29,8 @@ import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
-
 import java.io.IOException;
 
 /** Extracts data from AC-4 bitstreams. */
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java
index f2103af..48bd07f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac4Reader.java
@@ -22,11 +22,10 @@ import com.google.android.exoplayer2.audio.Ac4Util;
 import com.google.android.exoplayer2.audio.Ac4Util.SyncFrameInfo;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
-
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 48ff18c..86dacd8 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -30,10 +30,11 @@ import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
+import java.io.EOFException;
 import java.io.IOException;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -218,7 +219,7 @@ public final class AdtsExtractor implements Extractor {
       }
       scratch.skipBytes(3);
       int length = scratch.readSynchSafeInt();
-      firstFramePosition += 10 + length;
+      firstFramePosition += ID3_HEADER_LENGTH + length;
       input.advancePeekPosition(length);
     }
     input.resetPeekPosition();
@@ -266,36 +267,43 @@ public final class AdtsExtractor implements Extractor {
 
     int numValidFrames = 0;
     long totalValidFramesSize = 0;
-    while (input.peekFully(
-        scratch.data, /* offset= */ 0, /* length= */ 2, /* allowEndOfInput= */ true)) {
-      scratch.setPosition(0);
-      int syncBytes = scratch.readUnsignedShort();
-      if (!AdtsReader.isAdtsSyncWord(syncBytes)) {
-        // Invalid sync byte pattern.
-        // Constant bit-rate seeking will probably fail for this stream.
-        numValidFrames = 0;
-        break;
-      } else {
-        // Read the frame size.
-        if (!input.peekFully(
-            scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true)) {
-          break;
-        }
-        scratchBits.setPosition(14);
-        int currentFrameSize = scratchBits.readBits(13);
-        // Either the stream is malformed OR we're not parsing an ADTS stream.
-        if (currentFrameSize <= 6) {
-          hasCalculatedAverageFrameSize = true;
-          throw new ParserException("Malformed ADTS stream");
-        }
-        totalValidFramesSize += currentFrameSize;
-        if (++numValidFrames == NUM_FRAMES_FOR_AVERAGE_FRAME_SIZE) {
-          break;
-        }
-        if (!input.advancePeekPosition(currentFrameSize - 6, /* allowEndOfInput= */ true)) {
+    try {
+      while (input.peekFully(
+          scratch.data, /* offset= */ 0, /* length= */ 2, /* allowEndOfInput= */ true)) {
+        scratch.setPosition(0);
+        int syncBytes = scratch.readUnsignedShort();
+        if (!AdtsReader.isAdtsSyncWord(syncBytes)) {
+          // Invalid sync byte pattern.
+          // Constant bit-rate seeking will probably fail for this stream.
+          numValidFrames = 0;
           break;
+        } else {
+          // Read the frame size.
+          if (!input.peekFully(
+              scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true)) {
+            break;
+          }
+          scratchBits.setPosition(14);
+          int currentFrameSize = scratchBits.readBits(13);
+          // Either the stream is malformed OR we're not parsing an ADTS stream.
+          if (currentFrameSize <= 6) {
+            hasCalculatedAverageFrameSize = true;
+            throw new ParserException("Malformed ADTS stream");
+          }
+          totalValidFramesSize += currentFrameSize;
+          if (++numValidFrames == NUM_FRAMES_FOR_AVERAGE_FRAME_SIZE) {
+            break;
+          }
+          if (!input.advancePeekPosition(currentFrameSize - 6, /* allowEndOfInput= */ true)) {
+            break;
+          }
         }
       }
+    } catch (EOFException e) {
+      // We reached the end of the input during a peekFully() or advancePeekPosition() operation.
+      // This is OK, it just means the input has an incomplete ADTS frame at the end. Ideally
+      // ExtractorInput would allow these operations to encounter end-of-input without throwing an
+      // exception [internal: b/145586657].
     }
     input.resetPeekPosition();
     if (numValidFrames > 0) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index c063a6a..589b543 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -22,12 +22,12 @@ import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.Arrays;
 import java.util.Collections;
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index 23eb8d3..1f9b0e7 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -20,8 +20,8 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.DtsUtil;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Parses a continuous DTS byte stream and extracts individual samples.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
index 3758eab..3f0a772 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
@@ -22,9 +22,9 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.DvbSubtitleInfo;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.Collections;
 import java.util.List;
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
index e160894..e022fc2 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
@@ -19,7 +19,6 @@ import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Extracts individual samples from an elementary media stream, preserving original order.
@@ -35,10 +34,10 @@ public interface ElementaryStreamReader {
    * Initializes the reader by providing outputs and ids for the tracks.
    *
    * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
-   * @param idGenerator A {@link TrackIdGenerator} that generates unique track ids for the
+   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
    *     {@link TrackOutput}s.
    */
-  void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator);
+  void createTracks(ExtractorOutput extractorOutput, PesReader.TrackIdGenerator idGenerator);
 
   /**
    * Called when a packet starts.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
index 6803ff4..e7f2c19 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
@@ -20,10 +20,10 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.Arrays;
 import java.util.Collections;
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index dff8668..d249c1b 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -22,13 +22,13 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.NalUnitUtil.SpsData;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.ParsableNalUnitBitArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
index d33fd62..88bde53 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
@@ -19,12 +19,12 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.ParsableNalUnitBitArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.Collections;
 
 /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
index 8fbb976..77ec48d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
@@ -22,10 +22,10 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Parses ID3 data and extracts individual text information frames.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
index 055f646..4ad9adf 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
@@ -22,11 +22,11 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.Collections;
 
 /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
index 493b63a..393e297 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
@@ -20,8 +20,8 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Parses a continuous MPEG Audio byte stream and extracts individual frames.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
index 4feb50c..ff755f4 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -22,7 +22,6 @@ import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Parses PES packet data and extracts samples.
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index 097e3be..f453a9c 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -24,10 +24,10 @@ import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.io.IOException;
 
 /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
index 4d086f3..d6e6ead 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
@@ -17,9 +17,9 @@ package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Reads section data.
@@ -31,7 +31,7 @@ public interface SectionPayloadReader {
    *
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
    * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
-   * @param idGenerator A {@link TrackIdGenerator} that generates unique track ids for the
+   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
    *     {@link TrackOutput}s.
    */
   void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
index 9030847..bc590c9 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
@@ -19,7 +19,6 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -115,7 +114,7 @@ public final class SectionReader implements TsPayloadReader {
         if (bytesRead == totalSectionLength) {
           if (sectionSyntaxIndicator) {
             // This section has common syntax as defined in ISO/IEC 13818-1, section 2.4.4.11.
-            if (Util.crc(sectionData.data, 0, totalSectionLength, 0xFFFFFFFF) != 0) {
+            if (Util.crc32(sectionData.data, 0, totalSectionLength, 0xFFFFFFFF) != 0) {
               // The CRC is invalid so discard the section.
               waitingForPayloadStart = true;
               return;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
index e2457f7..d032ef5 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
@@ -19,7 +19,7 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
index c525a4a..27838d4 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
@@ -22,7 +22,6 @@ import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 
 /**
  * Parses splice info sections as defined by SCTE35.
@@ -35,7 +34,7 @@ public final class SpliceInfoSectionReader implements SectionPayloadReader {
 
   @Override
   public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-      TrackIdGenerator idGenerator) {
+      TsPayloadReader.TrackIdGenerator idGenerator) {
     this.timestampAdjuster = timestampAdjuster;
     idGenerator.generateNewId();
     output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index af3eefd..04dd7df 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -33,11 +33,11 @@ import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory.Flags;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.DvbSubtitleInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Documented;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index 8ca4fd3..af27235 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -21,9 +21,7 @@ import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
-
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -115,17 +113,83 @@ public interface TsPayloadReader {
   }
 
   /**
+   * Generates track ids for initializing {@link TsPayloadReader}s' {@link TrackOutput}s.
+   */
+  final class TrackIdGenerator {
+
+    private static final int ID_UNSET = Integer.MIN_VALUE;
+
+    private final String formatIdPrefix;
+    private final int firstTrackId;
+    private final int trackIdIncrement;
+    private int trackId;
+    private String formatId;
+
+    public TrackIdGenerator(int firstTrackId, int trackIdIncrement) {
+      this(ID_UNSET, firstTrackId, trackIdIncrement);
+    }
+
+    public TrackIdGenerator(int programNumber, int firstTrackId, int trackIdIncrement) {
+      this.formatIdPrefix = programNumber != ID_UNSET ? programNumber + "/" : "";
+      this.firstTrackId = firstTrackId;
+      this.trackIdIncrement = trackIdIncrement;
+      trackId = ID_UNSET;
+    }
+
+    /**
+     * Generates a new set of track and track format ids. Must be called before {@code get*}
+     * methods.
+     */
+    public void generateNewId() {
+      trackId = trackId == ID_UNSET ? firstTrackId : trackId + trackIdIncrement;
+      formatId = formatIdPrefix + trackId;
+    }
+
+    /**
+     * Returns the last generated track id. Must be called after the first {@link #generateNewId()}
+     * call.
+     *
+     * @return The last generated track id.
+     */
+    public int getTrackId() {
+      maybeThrowUninitializedError();
+      return trackId;
+    }
+
+    /**
+     * Returns the last generated format id, with the format {@code "programNumber/trackId"}. If no
+     * {@code programNumber} was provided, the {@code trackId} alone is used as format id. Must be
+     * called after the first {@link #generateNewId()} call.
+     *
+     * @return The last generated format id, with the format {@code "programNumber/trackId"}. If no
+     *     {@code programNumber} was provided, the {@code trackId} alone is used as
+     *     format id.
+     */
+    public String getFormatId() {
+      maybeThrowUninitializedError();
+      return formatId;
+    }
+
+    private void maybeThrowUninitializedError() {
+      if (trackId == ID_UNSET) {
+        throw new IllegalStateException("generateNewId() must be called before retrieving ids.");
+      }
+    }
+
+  }
+
+  /**
    * Contextual flags indicating the presence of indicators in the TS packet or PES packet headers.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
-          flag = true,
-          value = {
-                  FLAG_PAYLOAD_UNIT_START_INDICATOR,
-                  FLAG_RANDOM_ACCESS_INDICATOR,
-                  FLAG_DATA_ALIGNMENT_INDICATOR
-          })
+      flag = true,
+      value = {
+        FLAG_PAYLOAD_UNIT_START_INDICATOR,
+        FLAG_RANDOM_ACCESS_INDICATOR,
+        FLAG_DATA_ALIGNMENT_INDICATOR
+      })
   @interface Flags {}
 
   /** Indicates the presence of the payload_unit_start_indicator in the TS packet header. */
@@ -142,7 +206,7 @@ public interface TsPayloadReader {
    *
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
    * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
-   * @param idGenerator A {@link TrackIdGenerator} that generates unique track ids for the
+   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
    *     {@link TrackOutput}s.
    */
   void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java
index f54ee23..724eba1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/ts/UserDataReader.java
@@ -23,7 +23,6 @@ import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TrackIdGenerator;
 import java.util.List;
 
 /** Consumes user data, outputting contained CEA-608/708 messages to a {@link TrackOutput}. */
@@ -40,7 +39,7 @@ import java.util.List;
   }
 
   public void createTracks(
-      ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+      ExtractorOutput extractorOutput, TsPayloadReader.TrackIdGenerator idGenerator) {
     for (int i = 0; i < outputs.length; i++) {
       idGenerator.generateNewId();
       TrackOutput output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_TEXT);
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
index 6e3c598..2281513 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
@@ -23,7 +23,7 @@ import com.google.android.exoplayer2.util.Util;
 /** Header for a WAV file. */
 /* package */ final class WavHeader implements SeekMap {
 
-  /** Number of audio chanels. */
+  /** Number of audio channels. */
   private final int numChannels;
   /** Sample rate in Hertz. */
   private final int sampleRateHz;
diff --git a/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java b/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
index bbcb75a..97ce0c6 100644
--- a/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.wav;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.audio.WavUtil;
@@ -39,6 +40,7 @@ import java.io.IOException;
    * @return A new {@code WavHeader} peeked from {@code input}, or null if the input is not a
    *     supported WAV format.
    */
+  @Nullable
   public static WavHeader peek(ExtractorInput input) throws IOException, InterruptedException {
     Assertions.checkNotNull(input);
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 1726648..64517fe 100644
--- a/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -384,13 +384,13 @@ public final class MediaCodecInfo {
 
   /**
    * Whether the decoder supports video with a given width, height and frame rate.
-   * <p>
-   * Must not be called if the device SDK version is less than 21.
+   *
+   * <p>Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @param frameRate Optional frame rate in frames per second. Ignored if set to
-   *     {@link Format#NO_VALUE} or any value less than or equal to 0.
+   * @param frameRate Optional frame rate in frames per second. Ignored if set to {@link
+   *     Format#NO_VALUE} or any value less than or equal to 0.
    * @return Whether the decoder supports video with the given width, height and frame rate.
    */
   @TargetApi(21)
@@ -405,10 +405,8 @@ public final class MediaCodecInfo {
       return false;
     }
     if (!areSizeAndRateSupportedV21(videoCapabilities, width, height, frameRate)) {
-      // Capabilities are known to be inaccurately reported for vertical resolutions on some devices
-      // (b/31387661). If the video is vertical and the capabilities indicate support if the width
-      // and height are swapped, we assume that the vertical resolution is also supported.
       if (width >= height
+          || !enableRotatedVerticalResolutionWorkaround(name)
           || !areSizeAndRateSupportedV21(videoCapabilities, height, width, frameRate)) {
         logNoSupport("sizeAndRate.support, " + width + "x" + height + "x" + frameRate);
         return false;
@@ -433,18 +431,13 @@ public final class MediaCodecInfo {
   @TargetApi(21)
   public Point alignVideoSizeV21(int width, int height) {
     if (capabilities == null) {
-      logNoSupport("align.caps");
       return null;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
     if (videoCapabilities == null) {
-      logNoSupport("align.vCaps");
       return null;
     }
-    int widthAlignment = videoCapabilities.getWidthAlignment();
-    int heightAlignment = videoCapabilities.getHeightAlignment();
-    return new Point(Util.ceilDivide(width, widthAlignment) * widthAlignment,
-        Util.ceilDivide(height, heightAlignment) * heightAlignment);
+    return alignVideoSizeV21(videoCapabilities, width, height);
   }
 
   /**
@@ -575,6 +568,11 @@ public final class MediaCodecInfo {
   @TargetApi(21)
   private static boolean areSizeAndRateSupportedV21(VideoCapabilities capabilities, int width,
       int height, double frameRate) {
+    // Don't ever fail due to alignment. See: https://github.com/google/ExoPlayer/issues/6551.
+    Point alignedSize = alignVideoSizeV21(capabilities, width, height);
+    width = alignedSize.x;
+    height = alignedSize.y;
+
     if (frameRate == Format.NO_VALUE || frameRate <= 0) {
       return capabilities.isSizeSupported(width, height);
     } else {
@@ -586,8 +584,34 @@ public final class MediaCodecInfo {
     }
   }
 
+  @TargetApi(21)
+  private static Point alignVideoSizeV21(VideoCapabilities capabilities, int width, int height) {
+    int widthAlignment = capabilities.getWidthAlignment();
+    int heightAlignment = capabilities.getHeightAlignment();
+    return new Point(
+        Util.ceilDivide(width, widthAlignment) * widthAlignment,
+        Util.ceilDivide(height, heightAlignment) * heightAlignment);
+  }
+
   @TargetApi(23)
   private static int getMaxSupportedInstancesV23(CodecCapabilities capabilities) {
     return capabilities.getMaxSupportedInstances();
   }
+
+  /**
+   * Capabilities are known to be inaccurately reported for vertical resolutions on some devices.
+   * [Internal ref: b/31387661]. When this workaround is enabled, we also check whether the
+   * capabilities indicate support if the width and height are swapped. If they do, we assume that
+   * the vertical resolution is also supported.
+   *
+   * @param name The name of the codec.
+   * @return Whether to enable the workaround.
+   */
+  private static final boolean enableRotatedVerticalResolutionWorkaround(String name) {
+    if ("OMX.MTK.VIDEO.DECODER.HEVC".equals(name) && "mcv5a".equals(Util.DEVICE)) {
+      // See https://github.com/google/ExoPlayer/issues/6612.
+      return false;
+    }
+    return true;
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 821787e..6c405f7 100644
--- a/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -59,9 +59,7 @@ import java.util.List;
  */
 public abstract class MediaCodecRenderer extends BaseRenderer {
 
-  /**
-   * Thrown when a failure occurs instantiating a decoder.
-   */
+  /** Thrown when a failure occurs instantiating a decoder. */
   public static class DecoderInitializationException extends Exception {
 
     private static final int CUSTOM_ERROR_CODE_BASE = -50000;
@@ -303,13 +301,17 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   private static final int ADAPTATION_WORKAROUND_MODE_ALWAYS = 2;
 
   /**
-   * H.264/AVC buffer to queue when using the adaptation workaround (see
-   * {@link #codecAdaptationWorkaroundMode(String)}. Consists of three NAL units with start codes:
-   * Baseline sequence/picture parameter sets and a 32 * 32 pixel IDR slice. This stream can be
-   * queued to force a resolution change when adapting to a new format.
+   * H.264/AVC buffer to queue when using the adaptation workaround (see {@link
+   * #codecAdaptationWorkaroundMode(String)}. Consists of three NAL units with start codes: Baseline
+   * sequence/picture parameter sets and a 32 * 32 pixel IDR slice. This stream can be queued to
+   * force a resolution change when adapting to a new format.
    */
-  private static final byte[] ADAPTATION_WORKAROUND_BUFFER = Util.getBytesFromHexString(
-      "0000016742C00BDA259000000168CE0F13200000016588840DCE7118A0002FBF1C31C3275D78");
+  private static final byte[] ADAPTATION_WORKAROUND_BUFFER =
+      new byte[] {
+        0, 0, 1, 103, 66, -64, 11, -38, 37, -112, 0, 0, 1, 104, -50, 15, 19, 32, 0, 0, 1, 101, -120,
+        -124, 13, -50, 113, 24, -96, 0, 47, -65, 28, 49, -61, 39, 93, 120
+      };
+
   private static final int ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT = 32;
 
   private final MediaCodecSelector mediaCodecSelector;
@@ -361,13 +363,15 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   @DrainAction private int codecDrainAction;
   private boolean codecReceivedBuffers;
   private boolean codecReceivedEos;
-  private long lastBufferInStreamPresentationTimeUs;
   private long largestQueuedPresentationTimeUs;
+  private long lastBufferInStreamPresentationTimeUs;
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
   private boolean waitingForFirstSyncSample;
   private boolean waitingForFirstSampleInFormat;
+  private boolean skipMediaCodecStopOnRelease;
+  private boolean pendingOutputEndOfStream;
 
   protected DecoderCounters decoderCounters;
 
@@ -429,30 +433,48 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     this.renderTimeLimitMs = renderTimeLimitMs;
   }
 
+  /**
+   * Skip calling {@link MediaCodec#stop()} when the underlying MediaCodec is going to be released.
+   *
+   * <p>By default, when the MediaCodecRenderer is releasing the underlying {@link MediaCodec}, it
+   * first calls {@link MediaCodec#stop()} and then calls {@link MediaCodec#release()}. If this
+   * feature is enabled, the MediaCodecRenderer will skip the call to {@link MediaCodec#stop()}.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release. It should
+   * only be called before the renderer is used.
+   *
+   * @param enabled enable or disable the feature.
+   */
+  public void experimental_setSkipMediaCodecStopOnRelease(boolean enabled) {
+    skipMediaCodecStopOnRelease = enabled;
+  }
+
   @Override
+  @AdaptiveSupport
   public final int supportsMixedMimeTypeAdaptation() {
     return ADAPTIVE_NOT_SEAMLESS;
   }
 
   @Override
+  @Capabilities
   public final int supportsFormat(Format format) throws ExoPlaybackException {
     try {
       return supportsFormat(mediaCodecSelector, drmSessionManager, format);
     } catch (DecoderQueryException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, format);
     }
   }
 
   /**
-   * Returns the extent to which the renderer is capable of supporting a given format.
+   * Returns the {@link Capabilities} for the given {@link Format}.
    *
    * @param mediaCodecSelector The decoder selector.
    * @param drmSessionManager The renderer's {@link DrmSessionManager}.
-   * @param format The format.
-   * @return The extent to which the renderer is capable of supporting the given format. See {@link
-   *     #supportsFormat(Format)} for more detail.
+   * @param format The {@link Format}.
+   * @return The {@link Capabilities} for this {@link Format}.
    * @throws DecoderQueryException If there was an error querying decoders.
    */
+  @Capabilities
   protected abstract int supportsFormat(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
@@ -463,7 +485,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
    * Returns a list of decoders that can decode media in the specified format, in priority order.
    *
    * @param mediaCodecSelector The decoder selector.
-   * @param format The format for which a decoder is required.
+   * @param format The {@link Format} for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
    * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
@@ -477,7 +499,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param codec The {@link MediaCodec} to configure.
-   * @param format The format for which the codec is being configured.
+   * @param format The {@link Format} for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
@@ -514,7 +536,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
           try {
             mediaCrypto = new MediaCrypto(sessionMediaCrypto.uuid, sessionMediaCrypto.sessionId);
           } catch (MediaCryptoException e) {
-            throw ExoPlaybackException.createForRenderer(e, getIndex());
+            throw createRendererException(e, inputFormat);
           }
           mediaCryptoRequiresSecureDecoder =
               !sessionMediaCrypto.forceAllowInsecureDecoderComponents
@@ -524,7 +546,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
       if (FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC) {
         @DrmSession.State int drmSessionState = codecDrmSession.getState();
         if (drmSessionState == DrmSession.STATE_ERROR) {
-          throw ExoPlaybackException.createForRenderer(codecDrmSession.getError(), getIndex());
+          throw createRendererException(codecDrmSession.getError(), inputFormat);
         } else if (drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS) {
           // Wait for keys.
           return;
@@ -535,7 +557,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     try {
       maybeInitCodecWithFallback(mediaCrypto, mediaCryptoRequiresSecureDecoder);
     } catch (DecoderInitializationException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, inputFormat);
     }
   }
 
@@ -582,6 +604,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     inputStreamEnded = false;
     outputStreamEnded = false;
+    pendingOutputEndOfStream = false;
     flushOrReinitializeCodec();
     formatQueue.clear();
   }
@@ -632,7 +655,9 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
       if (codec != null) {
         decoderCounters.decoderReleaseCount++;
         try {
-          codec.stop();
+          if (!skipMediaCodecStopOnRelease) {
+            codec.stop();
+          }
         } finally {
           codec.release();
         }
@@ -663,6 +688,10 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
 
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+    if (pendingOutputEndOfStream) {
+      pendingOutputEndOfStream = false;
+      processEndOfStream();
+    }
     try {
       if (outputStreamEnded) {
         renderToEndOfStream();
@@ -672,7 +701,6 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
         // We still don't have a format and can't make progress without one.
         return;
       }
-
       // We have a format.
       maybeInitCodec();
       if (codec != null) {
@@ -685,16 +713,14 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
         decoderCounters.skippedInputBufferCount += skipSource(positionUs);
         // We need to read any format changes despite not having a codec so that drmSession can be
         // updated, and so that we have the most recent format should the codec be initialized. We
-        // may
-        // also reach the end of the stream. Note that readSource will not read a sample into a
+        // may also reach the end of the stream. Note that readSource will not read a sample into a
         // flags-only buffer.
         readToFlagsOnlyBuffer(/* requireFormat= */ false);
       }
       decoderCounters.ensureUpdated();
     } catch (IllegalStateException e) {
       if (isMediaCodecException(e)) {
-        throw ExoPlaybackException.createForRenderer(
-            createDecoderException(e, getCodecInfo()), getIndex());
+        throw createRendererException(e, inputFormat);
       }
       throw e;
     }
@@ -766,7 +792,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     return new DecoderException(cause, codecInfo);
   }
 
-  /** Reads into {@link #flagsOnlyBuffer} and returns whether a format was read. */
+  /** Reads into {@link #flagsOnlyBuffer} and returns whether a {@link Format} was read. */
   private boolean readToFlagsOnlyBuffer(boolean requireFormat) throws ExoPlaybackException {
     FormatHolder formatHolder = getFormatHolder();
     flagsOnlyBuffer.clear();
@@ -926,6 +952,8 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     codecReceivedEos = false;
     codecReceivedBuffers = false;
+    largestQueuedPresentationTimeUs = C.TIME_UNSET;
+    lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;
     codecDrainState = DRAIN_STATE_NONE;
     codecDrainAction = DRAIN_ACTION_NONE;
     codecNeedsAdaptationWorkaroundBuffer = false;
@@ -989,12 +1017,12 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   }
 
   private void setSourceDrmSession(@Nullable DrmSession<FrameworkMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(sourceDrmSession, session);
+    DrmSession.replaceSession(sourceDrmSession, session);
     sourceDrmSession = session;
   }
 
   private void setCodecDrmSession(@Nullable DrmSession<FrameworkMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(codecDrmSession, session);
+    DrmSession.replaceSession(codecDrmSession, session);
     codecDrmSession = session;
   }
 
@@ -1101,7 +1129,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
           resetInputBuffer();
         }
       } catch (CryptoException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
+        throw createRendererException(e, inputFormat);
       }
       return false;
     }
@@ -1157,18 +1185,20 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       decoderCounters.inputBufferCount++;
     } catch (CryptoException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, inputFormat);
     }
     return true;
   }
 
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (codecDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+    if (codecDrmSession == null
+        || (!bufferEncrypted
+            && (playClearSamplesWithoutKeys || codecDrmSession.playClearSamplesWithoutKeys()))) {
       return false;
     }
     @DrmSession.State int drmSessionState = codecDrmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(codecDrmSession.getError(), getIndex());
+      throw createRendererException(codecDrmSession.getError(), inputFormat);
     }
     return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
   }
@@ -1189,7 +1219,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   }
 
   /**
-   * Called when a new format is read from the upstream {@link MediaPeriod}.
+   * Called when a new {@link Format} is read from the upstream {@link MediaPeriod}.
    *
    * @param formatHolder A {@link FormatHolder} that holds the new {@link Format}.
    * @throws ExoPlaybackException If an error occurs re-initializing the {@link MediaCodec}.
@@ -1269,15 +1299,15 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   }
 
   /**
-   * Called when the output format of the {@link MediaCodec} changes.
-   * <p>
-   * The default implementation is a no-op.
+   * Called when the output {@link MediaFormat} of the {@link MediaCodec} changes.
+   *
+   * <p>The default implementation is a no-op.
    *
    * @param codec The {@link MediaCodec} instance.
-   * @param outputFormat The new output format.
-   * @throws ExoPlaybackException Thrown if an error occurs handling the new output format.
+   * @param outputMediaFormat The new output {@link MediaFormat}.
+   * @throws ExoPlaybackException Thrown if an error occurs handling the new output media format.
    */
-  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
+  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputMediaFormat)
       throws ExoPlaybackException {
     // Do nothing.
   }
@@ -1318,15 +1348,15 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   }
 
   /**
-   * Determines whether the existing {@link MediaCodec} can be kept for a new format, and if it can
-   * whether it requires reconfiguration.
+   * Determines whether the existing {@link MediaCodec} can be kept for a new {@link Format}, and if
+   * it can whether it requires reconfiguration.
    *
    * <p>The default implementation returns {@link #KEEP_CODEC_RESULT_NO}.
    *
    * @param codec The existing {@link MediaCodec} instance.
    * @param codecInfo A {@link MediaCodecInfo} describing the decoder.
-   * @param oldFormat The format for which the existing instance is configured.
-   * @param newFormat The new format.
+   * @param oldFormat The {@link Format} for which the existing instance is configured.
+   * @param newFormat The new {@link Format}.
    * @return Whether the instance can be kept, and if it can whether it requires reconfiguration.
    */
   protected @KeepCodecResult int canKeepCodec(
@@ -1360,12 +1390,12 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
 
   /**
    * Returns the {@link MediaFormat#KEY_OPERATING_RATE} value for a given renderer operating rate,
-   * current format and set of possible stream formats.
+   * current {@link Format} and set of possible stream formats.
    *
    * <p>The default implementation returns {@link #CODEC_OPERATING_RATE_UNSET}.
    *
    * @param operatingRate The renderer operating rate.
-   * @param format The format for which the codec is being configured.
+   * @param format The {@link Format} for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if no codec operating
    *     rate should be set.
@@ -1567,22 +1597,21 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     return false;
   }
 
-  /**
-   * Processes a new output format.
-   */
+  /** Processes a new output {@link MediaFormat}. */
   private void processOutputFormat() throws ExoPlaybackException {
-    MediaFormat format = codec.getOutputFormat();
+    MediaFormat mediaFormat = codec.getOutputFormat();
     if (codecAdaptationWorkaroundMode != ADAPTATION_WORKAROUND_MODE_NEVER
-        && format.getInteger(MediaFormat.KEY_WIDTH) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
-        && format.getInteger(MediaFormat.KEY_HEIGHT) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT) {
+        && mediaFormat.getInteger(MediaFormat.KEY_WIDTH) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
+        && mediaFormat.getInteger(MediaFormat.KEY_HEIGHT)
+            == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT) {
       // We assume this format changed event was caused by the adaptation workaround.
       shouldSkipAdaptationWorkaroundOutputBuffer = true;
       return;
     }
     if (codecNeedsMonoChannelCountWorkaround) {
-      format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);
+      mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);
     }
-    onOutputFormatChanged(codec, format);
+    onOutputFormatChanged(codec, mediaFormat);
   }
 
   /**
@@ -1620,7 +1649,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
    * @param isDecodeOnlyBuffer Whether the buffer was marked with {@link C#BUFFER_FLAG_DECODE_ONLY}
    *     by the source.
    * @param isLastBuffer Whether the buffer is the last sample of the current stream.
-   * @param format The format associated with the buffer.
+   * @param format The {@link Format} associated with the buffer.
    * @return Whether the output buffer was fully processed (e.g. rendered or skipped).
    * @throws ExoPlaybackException If an error occurs processing the output buffer.
    */
@@ -1672,6 +1701,14 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     }
   }
 
+  /**
+   * Notifies the renderer that output end of stream is pending and should be handled on the next
+   * render.
+   */
+  protected final void setPendingOutputEndOfStream() {
+    pendingOutputEndOfStream = true;
+  }
+
   private void reinitializeCodec() throws ExoPlaybackException {
     releaseCodec();
     maybeInitCodec();
@@ -1706,7 +1743,7 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
     try {
       mediaCrypto.setMediaDrmSession(sessionMediaCrypto.sessionId);
     } catch (MediaCryptoException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, inputFormat);
     }
     setCodecDrmSession(sourceDrmSession);
     codecDrainState = DRAIN_STATE_NONE;
@@ -1820,11 +1857,12 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   /**
    * Returns whether the decoder is an H.264/AVC decoder known to fail if NAL units are queued
    * before the codec specific data.
-   * <p>
-   * If true is returned, the renderer will work around the issue by discarding data up to the SPS.
+   *
+   * <p>If true is returned, the renderer will work around the issue by discarding data up to the
+   * SPS.
    *
    * @param name The name of the decoder.
-   * @param format The format used to configure the decoder.
+   * @param format The {@link Format} used to configure the decoder.
    * @return True if the decoder is known to fail if NAL units are queued before CSD.
    */
   private static boolean codecNeedsDiscardToSpsWorkaround(String name, Format format) {
@@ -1888,17 +1926,18 @@ public abstract class MediaCodecRenderer extends BaseRenderer {
   }
 
   /**
-   * Returns whether the decoder is known to set the number of audio channels in the output format
-   * to 2 for the given input format, whilst only actually outputting a single channel.
-   * <p>
-   * If true is returned then we explicitly override the number of channels in the output format,
-   * setting it to 1.
+   * Returns whether the decoder is known to set the number of audio channels in the output {@link
+   * Format} to 2 for the given input {@link Format}, whilst only actually outputting a single
+   * channel.
+   *
+   * <p>If true is returned then we explicitly override the number of channels in the output {@link
+   * Format}, setting it to 1.
    *
    * @param name The decoder name.
-   * @param format The input format.
-   * @return True if the decoder is known to set the number of audio channels in the output format
-   *     to 2 for the given input format, whilst only actually outputting a single channel. False
-   *     otherwise.
+   * @param format The input {@link Format}.
+   * @return True if the decoder is known to set the number of audio channels in the output {@link
+   *     Format} to 2 for the given input {@link Format}, whilst only actually outputting a single
+   *     channel. False otherwise.
    */
   private static boolean codecNeedsMonoChannelCountWorkaround(String name, Format format) {
     return Util.SDK_INT <= 18 && format.channelCount == 1
diff --git a/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 2d76309..9adb6bc 100644
--- a/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -38,6 +38,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
 
 /**
  * A utility class for querying the available codecs.
@@ -122,6 +123,7 @@ public final class MediaCodecUtil {
    */
   @Nullable
   public static MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
+    @Nullable
     MediaCodecInfo decoderInfo =
         getDecoderInfo(MimeTypes.AUDIO_RAW, /* secure= */ false, /* tunneling= */ false);
     return decoderInfo == null ? null : MediaCodecInfo.newPassthroughInstance(decoderInfo.name);
@@ -161,7 +163,7 @@ public final class MediaCodecUtil {
   public static synchronized List<MediaCodecInfo> getDecoderInfos(
       String mimeType, boolean secure, boolean tunneling) throws DecoderQueryException {
     CodecKey key = new CodecKey(mimeType, secure, tunneling);
-    List<MediaCodecInfo> cachedDecoderInfos = decoderInfosCache.get(key);
+    @Nullable List<MediaCodecInfo> cachedDecoderInfos = decoderInfosCache.get(key);
     if (cachedDecoderInfos != null) {
       return cachedDecoderInfos;
     }
@@ -214,6 +216,7 @@ public final class MediaCodecUtil {
   public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     if (maxH264DecodableFrameSize == -1) {
       int result = 0;
+      @Nullable
       MediaCodecInfo decoderInfo =
           getDecoderInfo(MimeTypes.VIDEO_H264, /* secure= */ false, /* tunneling= */ false);
       if (decoderInfo != null) {
@@ -287,6 +290,7 @@ public final class MediaCodecUtil {
       for (int i = 0; i < numberOfCodecs; i++) {
         android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
         String name = codecInfo.getName();
+        @Nullable
         String codecMimeType = getCodecMimeType(codecInfo, name, secureDecodersExplicit, mimeType);
         if (codecMimeType == null) {
           continue;
@@ -652,6 +656,7 @@ public final class MediaCodecUtil {
         && ("OMX.Exynos.AVC.Decoder".equals(name) || "OMX.Exynos.AVC.Decoder.secure".equals(name));
   }
 
+  @Nullable
   private static Pair<Integer, Integer> getDolbyVisionProfileAndLevel(
       String codec, String[] parts) {
     if (parts.length < 3) {
@@ -665,14 +670,14 @@ public final class MediaCodecUtil {
       Log.w(TAG, "Ignoring malformed Dolby Vision codec string: " + codec);
       return null;
     }
-    String profileString = matcher.group(1);
-    Integer profile = DOLBY_VISION_STRING_TO_PROFILE.get(profileString);
+    @Nullable String profileString = matcher.group(1);
+    @Nullable Integer profile = DOLBY_VISION_STRING_TO_PROFILE.get(profileString);
     if (profile == null) {
       Log.w(TAG, "Unknown Dolby Vision profile string: " + profileString);
       return null;
     }
     String levelString = parts[2];
-    Integer level = DOLBY_VISION_STRING_TO_LEVEL.get(levelString);
+    @Nullable Integer level = DOLBY_VISION_STRING_TO_LEVEL.get(levelString);
     if (level == null) {
       Log.w(TAG, "Unknown Dolby Vision level string: " + levelString);
       return null;
@@ -680,6 +685,7 @@ public final class MediaCodecUtil {
     return new Pair<>(profile, level);
   }
 
+  @Nullable
   private static Pair<Integer, Integer> getHevcProfileAndLevel(String codec, String[] parts) {
     if (parts.length < 4) {
       // The codec has fewer parts than required by the HEVC codec string format.
@@ -692,7 +698,7 @@ public final class MediaCodecUtil {
       Log.w(TAG, "Ignoring malformed HEVC codec string: " + codec);
       return null;
     }
-    String profileString = matcher.group(1);
+    @Nullable String profileString = matcher.group(1);
     int profile;
     if ("1".equals(profileString)) {
       profile = CodecProfileLevel.HEVCProfileMain;
@@ -702,8 +708,8 @@ public final class MediaCodecUtil {
       Log.w(TAG, "Unknown HEVC profile string: " + profileString);
       return null;
     }
-    String levelString = parts[3];
-    Integer level = HEVC_CODEC_STRING_TO_PROFILE_LEVEL.get(levelString);
+    @Nullable String levelString = parts[3];
+    @Nullable Integer level = HEVC_CODEC_STRING_TO_PROFILE_LEVEL.get(levelString);
     if (level == null) {
       Log.w(TAG, "Unknown HEVC level string: " + levelString);
       return null;
@@ -711,6 +717,7 @@ public final class MediaCodecUtil {
     return new Pair<>(profile, level);
   }
 
+  @Nullable
   private static Pair<Integer, Integer> getAvcProfileAndLevel(String codec, String[] parts) {
     if (parts.length < 2) {
       // The codec has fewer parts than required by the AVC codec string format.
@@ -751,6 +758,7 @@ public final class MediaCodecUtil {
     return new Pair<>(profile, level);
   }
 
+  @Nullable
   private static Pair<Integer, Integer> getVp9ProfileAndLevel(String codec, String[] parts) {
     if (parts.length < 3) {
       Log.w(TAG, "Ignoring malformed VP9 codec string: " + codec);
@@ -779,6 +787,7 @@ public final class MediaCodecUtil {
     return new Pair<>(profile, level);
   }
 
+  @Nullable
   private static Pair<Integer, Integer> getAv1ProfileAndLevel(
       String codec, String[] parts, @Nullable ColorInfo colorInfo) {
     if (parts.length < 4) {
@@ -874,7 +883,7 @@ public final class MediaCodecUtil {
     try {
       // Get the object type indication, which is a hexadecimal value (see RFC 6381/ISO 14496-1).
       int objectTypeIndication = Integer.parseInt(parts[1], 16);
-      String mimeType = MimeTypes.getMimeTypeFromMp4ObjectType(objectTypeIndication);
+      @Nullable String mimeType = MimeTypes.getMimeTypeFromMp4ObjectType(objectTypeIndication);
       if (MimeTypes.AUDIO_AAC.equals(mimeType)) {
         // For MPEG-4 audio this is followed by an audio object type indication as a decimal number.
         int audioObjectTypeIndication = Integer.parseInt(parts[2]);
@@ -932,8 +941,10 @@ public final class MediaCodecUtil {
 
     private final int codecKind;
 
-    private android.media.MediaCodecInfo[] mediaCodecInfos;
+    @Nullable private android.media.MediaCodecInfo[] mediaCodecInfos;
 
+    // the constructor does not initialize fields: mediaCodecInfos
+    @SuppressWarnings("nullness:initialization.fields.uninitialized")
     public MediaCodecListCompatV21(boolean includeSecure, boolean includeTunneling) {
       codecKind =
           includeSecure || includeTunneling
@@ -947,6 +958,8 @@ public final class MediaCodecUtil {
       return mediaCodecInfos.length;
     }
 
+    // incompatible types in return.
+    @SuppressWarnings("nullness:return.type.incompatible")
     @Override
     public android.media.MediaCodecInfo getCodecInfoAt(int index) {
       ensureMediaCodecInfosInitialized();
@@ -970,6 +983,7 @@ public final class MediaCodecUtil {
       return capabilities.isFeatureRequired(feature);
     }
 
+    @EnsuresNonNull({"mediaCodecInfos"})
     private void ensureMediaCodecInfosInitialized() {
       if (mediaCodecInfos == null) {
         mediaCodecInfos = new MediaCodecList(codecKind).getCodecInfos();
@@ -1028,7 +1042,7 @@ public final class MediaCodecUtil {
     public int hashCode() {
       final int prime = 31;
       int result = 1;
-      result = prime * result + ((mimeType == null) ? 0 : mimeType.hashCode());
+      result = prime * result + mimeType.hashCode();
       result = prime * result + (secure ? 1231 : 1237);
       result = prime * result + (tunneling ? 1231 : 1237);
       return result;
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java b/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
index 35702da..046c1fe 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
@@ -22,7 +22,6 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A collection of metadata entries.
@@ -57,19 +56,15 @@ public final class Metadata implements Parcelable {
    * @param entries The metadata entries.
    */
   public Metadata(Entry... entries) {
-    this.entries = entries == null ? new Entry[0] : entries;
+    this.entries = entries;
   }
 
   /**
    * @param entries The metadata entries.
    */
   public Metadata(List<? extends Entry> entries) {
-    if (entries != null) {
-      this.entries = new Entry[entries.size()];
-      entries.toArray(this.entries);
-    } else {
-      this.entries = new Entry[0];
-    }
+    this.entries = new Entry[entries.size()];
+    entries.toArray(this.entries);
   }
 
   /* package */ Metadata(Parcel in) {
@@ -118,9 +113,10 @@ public final class Metadata implements Parcelable {
    * @return The metadata instance with the appended entries.
    */
   public Metadata copyWithAppendedEntries(Entry... entriesToAppend) {
-    @NullableType Entry[] merged = Arrays.copyOf(entries, entries.length + entriesToAppend.length);
-    System.arraycopy(entriesToAppend, 0, merged, entries.length, entriesToAppend.length);
-    return new Metadata(Util.castNonNullTypeArray(merged));
+    if (entriesToAppend.length == 0) {
+      return this;
+    }
+    return new Metadata(Util.nullSafeArrayConcatenation(entries, entriesToAppend));
   }
 
   @Override
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java b/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
index ae4b7db..0b65383 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.metadata;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
 import com.google.android.exoplayer2.metadata.icy.IcyDecoder;
@@ -62,7 +63,7 @@ public interface MetadataDecoderFactory {
 
         @Override
         public boolean supportsFormat(Format format) {
-          String mimeType = format.sampleMimeType;
+          @Nullable String mimeType = format.sampleMimeType;
           return MimeTypes.APPLICATION_ID3.equals(mimeType)
               || MimeTypes.APPLICATION_EMSG.equals(mimeType)
               || MimeTypes.APPLICATION_SCTE35.equals(mimeType)
@@ -71,19 +72,23 @@ public interface MetadataDecoderFactory {
 
         @Override
         public MetadataDecoder createDecoder(Format format) {
-          switch (format.sampleMimeType) {
-            case MimeTypes.APPLICATION_ID3:
-              return new Id3Decoder();
-            case MimeTypes.APPLICATION_EMSG:
-              return new EventMessageDecoder();
-            case MimeTypes.APPLICATION_SCTE35:
-              return new SpliceInfoDecoder();
-            case MimeTypes.APPLICATION_ICY:
-              return new IcyDecoder();
-            default:
-              throw new IllegalArgumentException(
-                  "Attempted to create decoder for unsupported format");
+          @Nullable String mimeType = format.sampleMimeType;
+          if (mimeType != null) {
+            switch (mimeType) {
+              case MimeTypes.APPLICATION_ID3:
+                return new Id3Decoder();
+              case MimeTypes.APPLICATION_EMSG:
+                return new EventMessageDecoder();
+              case MimeTypes.APPLICATION_SCTE35:
+                return new SpliceInfoDecoder();
+              case MimeTypes.APPLICATION_ICY:
+                return new IcyDecoder();
+              default:
+                break;
+            }
           }
+          throw new IllegalArgumentException(
+              "Attempted to create decoder for unsupported MIME type: " + mimeType);
         }
       };
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index d738a86..7a5235a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.metadata;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Handler;
 import android.os.Handler.Callback;
 import android.os.Looper;
@@ -22,14 +24,15 @@ import android.os.Message;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /**
  * A renderer for metadata.
@@ -46,12 +49,12 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
   private final MetadataOutput output;
   @Nullable private final Handler outputHandler;
   private final MetadataInputBuffer buffer;
-  private final Metadata[] pendingMetadata;
+  private final @NullableType Metadata[] pendingMetadata;
   private final long[] pendingMetadataTimestamps;
 
   private int pendingMetadataIndex;
   private int pendingMetadataCount;
-  private MetadataDecoder decoder;
+  @Nullable private MetadataDecoder decoder;
   private boolean inputStreamEnded;
   private long subsampleOffsetUs;
 
@@ -89,16 +92,18 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
   }
 
   @Override
+  @Capabilities
   public int supportsFormat(Format format) {
     if (decoderFactory.supportsFormat(format)) {
-      return supportsFormatDrm(null, format.drmInitData) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_DRM;
+      return RendererCapabilities.create(
+          supportsFormatDrm(null, format.drmInitData) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_DRM);
     } else {
-      return FORMAT_UNSUPPORTED_TYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
     }
   }
 
   @Override
-  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
+  protected void onStreamChanged(Format[] formats, long offsetUs) {
     decoder = decoderFactory.createDecoder(formats[0]);
   }
 
@@ -109,7 +114,7 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
   }
 
   @Override
-  public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+  public void render(long positionUs, long elapsedRealtimeUs) {
     if (!inputStreamEnded && pendingMetadataCount < MAX_PENDING_METADATA_COUNT) {
       buffer.clear();
       FormatHolder formatHolder = getFormatHolder();
@@ -124,7 +129,7 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
         } else {
           buffer.subsampleOffsetUs = subsampleOffsetUs;
           buffer.flip();
-          Metadata metadata = decoder.decode(buffer);
+          @Nullable Metadata metadata = castNonNull(decoder).decode(buffer);
           if (metadata != null) {
             List<Metadata.Entry> entries = new ArrayList<>(metadata.length());
             decodeWrappedMetadata(metadata, entries);
@@ -139,12 +144,13 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
           }
         }
       } else if (result == C.RESULT_FORMAT_READ) {
-        subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
+        subsampleOffsetUs = Assertions.checkNotNull(formatHolder.format).subsampleOffsetUs;
       }
     }
 
     if (pendingMetadataCount > 0 && pendingMetadataTimestamps[pendingMetadataIndex] <= positionUs) {
-      invokeRenderer(pendingMetadata[pendingMetadataIndex]);
+      Metadata metadata = castNonNull(pendingMetadata[pendingMetadataIndex]);
+      invokeRenderer(metadata);
       pendingMetadata[pendingMetadataIndex] = null;
       pendingMetadataIndex = (pendingMetadataIndex + 1) % MAX_PENDING_METADATA_COUNT;
       pendingMetadataCount--;
@@ -158,7 +164,7 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
    */
   private void decodeWrappedMetadata(Metadata metadata, List<Metadata.Entry> decodedEntries) {
     for (int i = 0; i < metadata.length(); i++) {
-      Format wrappedMetadataFormat = metadata.get(i).getWrappedMetadataFormat();
+      @Nullable Format wrappedMetadataFormat = metadata.get(i).getWrappedMetadataFormat();
       if (wrappedMetadataFormat != null && decoderFactory.supportsFormat(wrappedMetadataFormat)) {
         MetadataDecoder wrappedMetadataDecoder =
             decoderFactory.createDecoder(wrappedMetadataFormat);
@@ -167,7 +173,7 @@ public final class MetadataRenderer extends BaseRenderer implements Callback {
             Assertions.checkNotNull(metadata.get(i).getWrappedMetadataBytes());
         buffer.clear();
         buffer.ensureSpaceForWrite(wrappedMetadataBytes.length);
-        buffer.data.put(wrappedMetadataBytes);
+        castNonNull(buffer.data).put(wrappedMetadataBytes);
         buffer.flip();
         @Nullable Metadata innerMetadata = wrappedMetadataDecoder.decode(buffer);
         if (innerMetadata != null) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index bbf7476..d87376f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
-import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
@@ -29,31 +28,20 @@ public final class EventMessageDecoder implements MetadataDecoder {
 
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
-  @Nullable
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
     byte[] data = buffer.array();
     int size = buffer.limit();
-    EventMessage decodedEventMessage = decode(new ParsableByteArray(data, size));
-    if (decodedEventMessage == null) {
-      return null;
-    } else {
-      return new Metadata(decodedEventMessage);
-    }
+    return new Metadata(decode(new ParsableByteArray(data, size)));
   }
 
-  @Nullable
   public EventMessage decode(ParsableByteArray emsgData) {
-    try {
-      String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-      String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-      long durationMs = emsgData.readUnsignedInt();
-      long id = emsgData.readUnsignedInt();
-      byte[] messageData =
-          Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
-      return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
-    } catch (RuntimeException e) {
-      return null;
-    }
+    String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+    String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+    long durationMs = emsgData.readUnsignedInt();
+    long id = emsgData.readUnsignedInt();
+    byte[] messageData =
+        Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
+    return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/package-info.java b/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/package-info.java
new file mode 100644
index 0000000..2b03ce8
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.metadata.emsg;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/flac/package-info.java b/core/src/main/java/com/google/android/exoplayer2/metadata/flac/package-info.java
new file mode 100644
index 0000000..343ab23
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/flac/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.metadata.flac;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java b/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
index 12f65f1..3834dce 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
@@ -21,7 +21,6 @@ import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 import java.util.regex.Matcher;
@@ -30,14 +29,11 @@ import java.util.regex.Pattern;
 /** Decodes ICY stream information. */
 public final class IcyDecoder implements MetadataDecoder {
 
-  private static final String TAG = "IcyDecoder";
-
   private static final Pattern METADATA_ELEMENT = Pattern.compile("(.+?)='(.*?)';", Pattern.DOTALL);
   private static final String STREAM_KEY_NAME = "streamtitle";
   private static final String STREAM_KEY_URL = "streamurl";
 
   @Override
-  @Nullable
   @SuppressWarnings("ByteBufferBackingArray")
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
@@ -46,11 +42,10 @@ public final class IcyDecoder implements MetadataDecoder {
     return decode(Util.fromUtf8Bytes(data, 0, length));
   }
 
-  @Nullable
   @VisibleForTesting
   /* package */ Metadata decode(String metadata) {
-    String name = null;
-    String url = null;
+    @Nullable String name = null;
+    @Nullable String url = null;
     int index = 0;
     Matcher matcher = METADATA_ELEMENT.matcher(metadata);
     while (matcher.find(index)) {
@@ -63,12 +58,9 @@ public final class IcyDecoder implements MetadataDecoder {
         case STREAM_KEY_URL:
           url = value;
           break;
-        default:
-          Log.w(TAG, "Unrecognized ICY tag: " + name);
-          break;
       }
       index = matcher.end();
     }
-    return (name != null || url != null) ? new Metadata(new IcyInfo(name, url)) : null;
+    return new Metadata(new IcyInfo(metadata, name, url));
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java b/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
index e6b915a..1198d1a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
@@ -19,26 +19,35 @@ import android.os.Parcel;
 import android.os.Parcelable;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
 /** ICY in-stream information. */
 public final class IcyInfo implements Metadata.Entry {
 
+  /** The complete metadata string used to construct this IcyInfo. */
+  public final String rawMetadata;
   /** The stream title if present, or {@code null}. */
   @Nullable public final String title;
-  /** The stream title if present, or {@code null}. */
+  /** The stream URL if present, or {@code null}. */
   @Nullable public final String url;
 
   /**
+   * Construct a new IcyInfo from the source metadata string, and optionally a StreamTitle and
+   * StreamUrl that have been extracted.
+   *
+   * @param rawMetadata See {@link #rawMetadata}.
    * @param title See {@link #title}.
    * @param url See {@link #url}.
    */
-  public IcyInfo(@Nullable String title, @Nullable String url) {
+  public IcyInfo(String rawMetadata, @Nullable String title, @Nullable String url) {
+    this.rawMetadata = rawMetadata;
     this.title = title;
     this.url = url;
   }
 
   /* package */ IcyInfo(Parcel in) {
+    rawMetadata = Assertions.checkNotNull(in.readString());
     title = in.readString();
     url = in.readString();
   }
@@ -52,26 +61,27 @@ public final class IcyInfo implements Metadata.Entry {
       return false;
     }
     IcyInfo other = (IcyInfo) obj;
-    return Util.areEqual(title, other.title) && Util.areEqual(url, other.url);
+    // title & url are derived from rawMetadata, so no need to include them in the comparison.
+    return Util.areEqual(rawMetadata, other.rawMetadata);
   }
 
   @Override
   public int hashCode() {
-    int result = 17;
-    result = 31 * result + (title != null ? title.hashCode() : 0);
-    result = 31 * result + (url != null ? url.hashCode() : 0);
-    return result;
+    // title & url are derived from rawMetadata, so no need to include them in the hash.
+    return rawMetadata.hashCode();
   }
 
   @Override
   public String toString() {
-    return "ICY: title=\"" + title + "\", url=\"" + url + "\"";
+    return String.format(
+        "ICY: title=\"%s\", url=\"%s\", rawMetadata=\"%s\"", title, url, rawMetadata);
   }
 
   // Parcelable implementation.
 
   @Override
   public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(rawMetadata);
     dest.writeString(title);
     dest.writeString(url);
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/icy/package-info.java b/core/src/main/java/com/google/android/exoplayer2/metadata/icy/package-info.java
new file mode 100644
index 0000000..2a2d0c7
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/icy/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.metadata.icy;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java b/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
index d4bedc6..3f4a400 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
@@ -47,7 +47,7 @@ public final class ApicFrame extends Id3Frame {
   /* package */ ApicFrame(Parcel in) {
     super(ID);
     mimeType = castNonNull(in.readString());
-    description = castNonNull(in.readString());
+    description = in.readString();
     pictureType = in.readInt();
     pictureData = castNonNull(in.createByteArray());
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index c8755f9..faab7f0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -155,7 +155,8 @@ public final class Id3Decoder implements MetadataDecoder {
    * @param data A {@link ParsableByteArray} from which the header should be read.
    * @return The parsed header, or null if the ID3 tag is unsupported.
    */
-  private static @Nullable Id3Header decodeHeader(ParsableByteArray data) {
+  @Nullable
+  private static Id3Header decodeHeader(ParsableByteArray data) {
     if (data.bytesLeft() < ID3_HEADER_LENGTH) {
       Log.w(TAG, "Data too short to be an ID3 tag");
       return null;
@@ -163,7 +164,7 @@ public final class Id3Decoder implements MetadataDecoder {
 
     int id = data.readUnsignedInt24();
     if (id != ID3_TAG) {
-      Log.w(TAG, "Unexpected first three bytes of ID3 tag header: " + id);
+      Log.w(TAG, "Unexpected first three bytes of ID3 tag header: 0x" + String.format("%06X", id));
       return null;
     }
 
@@ -269,7 +270,8 @@ public final class Id3Decoder implements MetadataDecoder {
     }
   }
 
-  private static @Nullable Id3Frame decodeFrame(
+  @Nullable
+  private static Id3Frame decodeFrame(
       int majorVersion,
       ParsableByteArray id3Data,
       boolean unsignedIntFrameSizeHack,
@@ -404,8 +406,9 @@ public final class Id3Decoder implements MetadataDecoder {
     }
   }
 
-  private static @Nullable TextInformationFrame decodeTxxxFrame(
-      ParsableByteArray id3Data, int frameSize) throws UnsupportedEncodingException {
+  @Nullable
+  private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
     if (frameSize < 1) {
       // Frame is malformed.
       return null;
@@ -427,7 +430,8 @@ public final class Id3Decoder implements MetadataDecoder {
     return new TextInformationFrame("TXXX", description, value);
   }
 
-  private static @Nullable TextInformationFrame decodeTextInformationFrame(
+  @Nullable
+  private static TextInformationFrame decodeTextInformationFrame(
       ParsableByteArray id3Data, int frameSize, String id) throws UnsupportedEncodingException {
     if (frameSize < 1) {
       // Frame is malformed.
@@ -446,7 +450,8 @@ public final class Id3Decoder implements MetadataDecoder {
     return new TextInformationFrame(id, null, value);
   }
 
-  private static @Nullable UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
+  @Nullable
+  private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     if (frameSize < 1) {
       // Frame is malformed.
@@ -557,7 +562,8 @@ public final class Id3Decoder implements MetadataDecoder {
     return new ApicFrame(mimeType, description, pictureType, pictureData);
   }
 
-  private static @Nullable CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int frameSize)
+  @Nullable
+  private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     if (frameSize < 4) {
       // Frame is malformed.
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/id3/package-info.java b/core/src/main/java/com/google/android/exoplayer2/metadata/id3/package-info.java
new file mode 100644
index 0000000..8422071
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/id3/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.metadata.id3;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/package-info.java b/core/src/main/java/com/google/android/exoplayer2/metadata/package-info.java
new file mode 100644
index 0000000..a55cc1b
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java b/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
index 1153f91..0e161d9 100644
--- a/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
@@ -15,13 +15,16 @@
  */
 package com.google.android.exoplayer2.metadata.scte35;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.nio.ByteBuffer;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
  * Decodes splice info sections and produces splice commands.
@@ -37,7 +40,7 @@ public final class SpliceInfoDecoder implements MetadataDecoder {
   private final ParsableByteArray sectionData;
   private final ParsableBitArray sectionHeader;
 
-  private TimestampAdjuster timestampAdjuster;
+  @MonotonicNonNull private TimestampAdjuster timestampAdjuster;
 
   public SpliceInfoDecoder() {
     sectionData = new ParsableByteArray();
@@ -47,6 +50,8 @@ public final class SpliceInfoDecoder implements MetadataDecoder {
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
   public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
+
     // Internal timestamps adjustment.
     if (timestampAdjuster == null
         || inputBuffer.subsampleOffsetUs != timestampAdjuster.getTimestampOffsetUs()) {
@@ -54,7 +59,6 @@ public final class SpliceInfoDecoder implements MetadataDecoder {
       timestampAdjuster.adjustSampleTimestamp(inputBuffer.timeUs - inputBuffer.subsampleOffsetUs);
     }
 
-    ByteBuffer buffer = inputBuffer.data;
     byte[] data = buffer.array();
     int size = buffer.limit();
     sectionData.reset(data, size);
@@ -68,7 +72,7 @@ public final class SpliceInfoDecoder implements MetadataDecoder {
     sectionHeader.skipBits(20);
     int spliceCommandLength = sectionHeader.readBits(12);
     int spliceCommandType = sectionHeader.readBits(8);
-    SpliceCommand command = null;
+    @Nullable SpliceCommand command = null;
     // Go to the start of the command by skipping all fields up to command_type.
     sectionData.skipBytes(14);
     switch (spliceCommandType) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/package-info.java b/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/package-info.java
new file mode 100644
index 0000000..0c4448f
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/metadata/scte35/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.metadata.scte35;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java b/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java
index 9ecce6e..999059e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/ActionFileUpgradeUtil.java
@@ -18,6 +18,7 @@ package com.google.android.exoplayer2.offline;
 import static com.google.android.exoplayer2.offline.Download.STATE_QUEUED;
 
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import com.google.android.exoplayer2.C;
 import java.io.File;
 import java.io.IOException;
@@ -47,6 +48,8 @@ public final class ActionFileUpgradeUtil {
    * <p>This method must not be called while the {@link DefaultDownloadIndex} is being used by a
    * {@link DownloadManager}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param actionFilePath The action file path.
    * @param downloadIdProvider A download ID provider, or {@code null}. If {@code null} then ID of
    *     each download will be its custom cache key if one is specified, or else its URL.
@@ -55,6 +58,7 @@ public final class ActionFileUpgradeUtil {
    * @param addNewDownloadsAsCompleted Whether to add new downloads as completed.
    * @throws IOException If an error occurs loading or merging the requests.
    */
+  @WorkerThread
   @SuppressWarnings("deprecation")
   public static void upgradeAndDelete(
       File actionFilePath,
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java b/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
index ef4bd00..f1c8978 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/DefaultDownloadIndex.java
@@ -26,6 +26,8 @@ import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.database.DatabaseIOException;
 import com.google.android.exoplayer2.database.DatabaseProvider;
 import com.google.android.exoplayer2.database.VersionTable;
+import com.google.android.exoplayer2.offline.Download.FailureReason;
+import com.google.android.exoplayer2.offline.Download.State;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
@@ -239,6 +241,9 @@ public final class DefaultDownloadIndex implements WritableDownloadIndex {
     try {
       ContentValues values = new ContentValues();
       values.put(COLUMN_STATE, Download.STATE_REMOVING);
+      // Only downloads in STATE_FAILED are allowed a failure reason, so we need to clear it here in
+      // case we're moving downloads from STATE_FAILED to STATE_REMOVING.
+      values.put(COLUMN_FAILURE_REASON, Download.FAILURE_REASON_NONE);
       SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
       writableDatabase.update(tableName, values, /* whereClause= */ null, /* whereArgs= */ null);
     } catch (SQLException e) {
@@ -285,7 +290,7 @@ public final class DefaultDownloadIndex implements WritableDownloadIndex {
       int version = VersionTable.getVersion(readableDatabase, VersionTable.FEATURE_OFFLINE, name);
       if (version != TABLE_VERSION) {
         SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-        writableDatabase.beginTransaction();
+        writableDatabase.beginTransactionNonExclusive();
         try {
           VersionTable.setVersion(
               writableDatabase, VersionTable.FEATURE_OFFLINE, name, TABLE_VERSION);
@@ -302,6 +307,8 @@ public final class DefaultDownloadIndex implements WritableDownloadIndex {
     }
   }
 
+  // incompatible types in argument.
+  @SuppressWarnings("nullness:argument.type.incompatible")
   private Cursor getCursor(String selection, @Nullable String[] selectionArgs)
       throws DatabaseIOException {
     try {
@@ -349,14 +356,22 @@ public final class DefaultDownloadIndex implements WritableDownloadIndex {
     DownloadProgress downloadProgress = new DownloadProgress();
     downloadProgress.bytesDownloaded = cursor.getLong(COLUMN_INDEX_BYTES_DOWNLOADED);
     downloadProgress.percentDownloaded = cursor.getFloat(COLUMN_INDEX_PERCENT_DOWNLOADED);
+    @State int state = cursor.getInt(COLUMN_INDEX_STATE);
+    // It's possible the database contains failure reasons for non-failed downloads, which is
+    // invalid. Clear them here. See https://github.com/google/ExoPlayer/issues/6785.
+    @FailureReason
+    int failureReason =
+        state == Download.STATE_FAILED
+            ? cursor.getInt(COLUMN_INDEX_FAILURE_REASON)
+            : Download.FAILURE_REASON_NONE;
     return new Download(
         request,
-        /* state= */ cursor.getInt(COLUMN_INDEX_STATE),
+        state,
         /* startTimeMs= */ cursor.getLong(COLUMN_INDEX_START_TIME_MS),
         /* updateTimeMs= */ cursor.getLong(COLUMN_INDEX_UPDATE_TIME_MS),
         /* contentLength= */ cursor.getLong(COLUMN_INDEX_CONTENT_LENGTH),
         /* stopReason= */ cursor.getInt(COLUMN_INDEX_STOP_REASON),
-        /* failureReason= */ cursor.getInt(COLUMN_INDEX_FAILURE_REASON),
+        failureReason,
         downloadProgress);
   }
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/Download.java b/core/src/main/java/com/google/android/exoplayer2/offline/Download.java
index 97dff83..da46120 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/Download.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/Download.java
@@ -130,9 +130,9 @@ public final class Download {
       @FailureReason int failureReason,
       DownloadProgress progress) {
     Assertions.checkNotNull(progress);
-    Assertions.checkState((failureReason == FAILURE_REASON_NONE) == (state != STATE_FAILED));
+    Assertions.checkArgument((failureReason == FAILURE_REASON_NONE) == (state != STATE_FAILED));
     if (stopReason != 0) {
-      Assertions.checkState(state != STATE_DOWNLOADING && state != STATE_QUEUED);
+      Assertions.checkArgument(state != STATE_DOWNLOADING && state != STATE_QUEUED);
     }
     this.request = request;
     this.state = state;
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java b/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
index 6ca5967..c585c79 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/DownloadHelper.java
@@ -37,6 +37,8 @@ import com.google.android.exoplayer2.source.MediaSourceFactory;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
 import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.Parameters;
@@ -137,6 +139,9 @@ public final class DownloadHelper {
     void onPrepareError(DownloadHelper helper, IOException e);
   }
 
+  /** Thrown at an attempt to download live content. */
+  public static class LiveContentUnsupportedException extends IOException {}
+
   @Nullable
   private static final Constructor<? extends MediaSourceFactory> DASH_FACTORY_CONSTRUCTOR =
       getConstructor("com.google.android.exoplayer2.source.dash.DashMediaSource$Factory");
@@ -950,7 +955,7 @@ public final class DownloadHelper {
     public boolean handleMessage(Message msg) {
       switch (msg.what) {
         case MESSAGE_PREPARE_SOURCE:
-          mediaSource.prepareSource(/* caller= */ this, /* mediaTransferListener= */ null, null);
+          mediaSource.prepareSource(/* caller= */ this, /* mediaTransferListener= */ null);
           mediaSourceHandler.sendEmptyMessage(MESSAGE_CHECK_FOR_FAILURE);
           return true;
         case MESSAGE_CHECK_FOR_FAILURE:
@@ -999,6 +1004,14 @@ public final class DownloadHelper {
         // Ignore dynamic updates.
         return;
       }
+      if (timeline.getWindow(/* windowIndex= */ 0, new Timeline.Window()).isLive) {
+        downloadHelperHandler
+            .obtainMessage(
+                DOWNLOAD_HELPER_CALLBACK_MESSAGE_FAILED,
+                /* obj= */ new LiveContentUnsupportedException())
+            .sendToTarget();
+        return;
+      }
       this.timeline = timeline;
       mediaPeriods = new MediaPeriod[timeline.getPeriodCount()];
       for (int i = 0; i < mediaPeriods.length; i++) {
@@ -1089,6 +1102,16 @@ public final class DownloadHelper {
     public Object getSelectionData() {
       return null;
     }
+
+    @Override
+    public void updateSelectedTrack(
+        long playbackPositionUs,
+        long bufferedDurationUs,
+        long availableDurationUs,
+        List<? extends MediaChunk> queue,
+        MediaChunkIterator[] mediaChunkIterators) {
+      // Do nothing.
+    }
   }
 
   private static final class DummyBandwidthMeter implements BandwidthMeter {
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java b/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java
index 3de1b7b..e0ccd23 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/DownloadIndex.java
@@ -16,14 +16,18 @@
 package com.google.android.exoplayer2.offline;
 
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import java.io.IOException;
 
 /** An index of {@link Download Downloads}. */
+@WorkerThread
 public interface DownloadIndex {
 
   /**
    * Returns the {@link Download} with the given {@code id}, or null.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param id ID of a {@link Download}.
    * @return The {@link Download} with the given {@code id}, or null if a download state with this
    *     id doesn't exist.
@@ -35,6 +39,8 @@ public interface DownloadIndex {
   /**
    * Returns a {@link DownloadCursor} to {@link Download}s with the given {@code states}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param states Returns only the {@link Download}s with this states. If empty, returns all.
    * @return A cursor to {@link Download}s with the given {@code states}.
    * @throws IOException If an error occurs reading the state.
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java b/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
index 65dcd18..0d53b3c 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
@@ -20,7 +20,7 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
+import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.upstream.PriorityDataSourceFactory;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSink;
@@ -59,7 +59,8 @@ public final class DownloaderConstructorHelper {
    * @param upstreamFactory A {@link DataSource.Factory} for creating {@link DataSource}s for
    *     downloading data.
    * @param cacheReadDataSourceFactory A {@link DataSource.Factory} for creating {@link DataSource}s
-   *     for reading data from the cache. If null then a {@link FileDataSourceFactory} will be used.
+   *     for reading data from the cache. If null then a {@link FileDataSource.Factory} will be
+   *     used.
    * @param cacheWriteDataSinkFactory A {@link DataSink.Factory} for creating {@link DataSource}s
    *     for writing data to the cache. If null then a {@link CacheDataSinkFactory} will be used.
    * @param priorityTaskManager A {@link PriorityTaskManager} to use when downloading. If non-null,
@@ -86,7 +87,8 @@ public final class DownloaderConstructorHelper {
    * @param upstreamFactory A {@link DataSource.Factory} for creating {@link DataSource}s for
    *     downloading data.
    * @param cacheReadDataSourceFactory A {@link DataSource.Factory} for creating {@link DataSource}s
-   *     for reading data from the cache. If null then a {@link FileDataSourceFactory} will be used.
+   *     for reading data from the cache. If null then a {@link FileDataSource.Factory} will be
+   *     used.
    * @param cacheWriteDataSinkFactory A {@link DataSink.Factory} for creating {@link DataSource}s
    *     for writing data to the cache. If null then a {@link CacheDataSinkFactory} will be used.
    * @param priorityTaskManager A {@link PriorityTaskManager} to use when downloading. If non-null,
@@ -108,7 +110,7 @@ public final class DownloaderConstructorHelper {
     DataSource.Factory readDataSourceFactory =
         cacheReadDataSourceFactory != null
             ? cacheReadDataSourceFactory
-            : new FileDataSourceFactory();
+            : new FileDataSource.Factory();
     if (cacheWriteDataSinkFactory == null) {
       cacheWriteDataSinkFactory =
           new CacheDataSinkFactory(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE);
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java b/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
index 17f4047..a732582 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
@@ -29,6 +29,12 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * A downloader for progressive media streams.
+ *
+ * <p>The downloader attempts to download the entire media bytes referenced by a {@link Uri} into a
+ * cache as defined by {@link DownloaderConstructorHelper}. Callers can use the constructor to
+ * specify a custom cache key for the downloaded bytes.
+ *
+ * <p>The downloader will avoid downloading already-downloaded media bytes.
  */
 public final class ProgressiveDownloader implements Downloader {
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
index 808df6d..9690031 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -17,7 +17,6 @@ package com.google.android.exoplayer2.offline;
 
 import android.net.Uri;
 import android.util.Pair;
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -57,7 +56,7 @@ public abstract class SegmentDownloader<M extends FilterableManifest<M>> impleme
     }
 
     @Override
-    public int compareTo(@NonNull Segment other) {
+    public int compareTo(Segment other) {
       return Util.compareLong(startTimeUs, other.startTimeUs);
     }
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java b/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
index 977be9a..f9a4886 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/StreamKey.java
@@ -17,7 +17,6 @@ package com.google.android.exoplayer2.offline;
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 /**
@@ -92,7 +91,7 @@ public final class StreamKey implements Comparable<StreamKey>, Parcelable {
   // Comparable implementation.
 
   @Override
-  public int compareTo(@NonNull StreamKey o) {
+  public int compareTo(StreamKey o) {
     int result = periodIndex - o.periodIndex;
     if (result == 0) {
       result = groupIndex - o.groupIndex;
diff --git a/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java b/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
index dc7085c..d49b4c3 100644
--- a/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
+++ b/core/src/main/java/com/google/android/exoplayer2/offline/WritableDownloadIndex.java
@@ -15,14 +15,18 @@
  */
 package com.google.android.exoplayer2.offline;
 
+import androidx.annotation.WorkerThread;
 import java.io.IOException;
 
 /** A writable index of {@link Download Downloads}. */
+@WorkerThread
 public interface WritableDownloadIndex extends DownloadIndex {
 
   /**
    * Adds or replaces a {@link Download}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param download The {@link Download} to be added.
    * @throws IOException If an error occurs setting the state.
    */
@@ -32,6 +36,8 @@ public interface WritableDownloadIndex extends DownloadIndex {
    * Removes the download with the given ID. Does nothing if a download with the given ID does not
    * exist.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param id The ID of the download to remove.
    * @throws IOException If an error occurs removing the state.
    */
@@ -40,6 +46,8 @@ public interface WritableDownloadIndex extends DownloadIndex {
   /**
    * Sets all {@link Download#STATE_DOWNLOADING} states to {@link Download#STATE_QUEUED}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @throws IOException If an error occurs updating the state.
    */
   void setDownloadingStatesToQueued() throws IOException;
@@ -47,6 +55,8 @@ public interface WritableDownloadIndex extends DownloadIndex {
   /**
    * Sets all states to {@link Download#STATE_REMOVING}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @throws IOException If an error occurs updating the state.
    */
   void setStatesToRemoving() throws IOException;
@@ -55,6 +65,8 @@ public interface WritableDownloadIndex extends DownloadIndex {
    * Sets the stop reason of the downloads in a terminal state ({@link Download#STATE_COMPLETED},
    * {@link Download#STATE_FAILED}).
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param stopReason The stop reason.
    * @throws IOException If an error occurs updating the state.
    */
@@ -65,6 +77,8 @@ public interface WritableDownloadIndex extends DownloadIndex {
    * Download#STATE_COMPLETED}, {@link Download#STATE_FAILED}). Does nothing if a download with the
    * given ID does not exist, or if it's not in a terminal state.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param id The ID of the download to update.
    * @param stopReason The stop reason.
    * @throws IOException If an error occurs updating the state.
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java b/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
new file mode 100644
index 0000000..29ef1fa
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.util.Assertions;
+
+/** Abstract base class for the concatenation of one or more {@link Timeline}s. */
+/* package */ abstract class AbstractConcatenatedTimeline extends Timeline {
+
+  private final int childCount;
+  private final ShuffleOrder shuffleOrder;
+  private final boolean isAtomic;
+
+  /**
+   * Returns UID of child timeline from a concatenated period UID.
+   *
+   * @param concatenatedUid UID of a period in a concatenated timeline.
+   * @return UID of the child timeline this period belongs to.
+   */
+  @SuppressWarnings("nullness:return.type.incompatible")
+  public static Object getChildTimelineUidFromConcatenatedUid(Object concatenatedUid) {
+    return ((Pair<?, ?>) concatenatedUid).first;
+  }
+
+  /**
+   * Returns UID of the period in the child timeline from a concatenated period UID.
+   *
+   * @param concatenatedUid UID of a period in a concatenated timeline.
+   * @return UID of the period in the child timeline.
+   */
+  @SuppressWarnings("nullness:return.type.incompatible")
+  public static Object getChildPeriodUidFromConcatenatedUid(Object concatenatedUid) {
+    return ((Pair<?, ?>) concatenatedUid).second;
+  }
+
+  /**
+   * Returns a concatenated UID for a period or window in a child timeline.
+   *
+   * @param childTimelineUid UID of the child timeline this period or window belongs to.
+   * @param childPeriodOrWindowUid UID of the period or window in the child timeline.
+   * @return UID of the period or window in the concatenated timeline.
+   */
+  public static Object getConcatenatedUid(Object childTimelineUid, Object childPeriodOrWindowUid) {
+    return Pair.create(childTimelineUid, childPeriodOrWindowUid);
+  }
+
+  /**
+   * Sets up a concatenated timeline with a shuffle order of child timelines.
+   *
+   * @param isAtomic Whether the child timelines shall be treated as atomic, i.e., treated as a
+   *     single item for repeating and shuffling.
+   * @param shuffleOrder A shuffle order of child timelines. The number of child timelines must
+   *     match the number of elements in the shuffle order.
+   */
+  public AbstractConcatenatedTimeline(boolean isAtomic, ShuffleOrder shuffleOrder) {
+    this.isAtomic = isAtomic;
+    this.shuffleOrder = shuffleOrder;
+    this.childCount = shuffleOrder.getLength();
+  }
+
+  @Override
+  public int getNextWindowIndex(
+      int windowIndex, @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {
+    if (isAtomic) {
+      // Adapt repeat and shuffle mode to atomic concatenation.
+      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
+      shuffleModeEnabled = false;
+    }
+    // Find next window within current child.
+    int childIndex = getChildIndexByWindowIndex(windowIndex);
+    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
+    int nextWindowIndexInChild =
+        getTimelineByChildIndex(childIndex)
+            .getNextWindowIndex(
+                windowIndex - firstWindowIndexInChild,
+                repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
+                shuffleModeEnabled);
+    if (nextWindowIndexInChild != C.INDEX_UNSET) {
+      return firstWindowIndexInChild + nextWindowIndexInChild;
+    }
+    // If not found, find first window of next non-empty child.
+    int nextChildIndex = getNextChildIndex(childIndex, shuffleModeEnabled);
+    while (nextChildIndex != C.INDEX_UNSET && getTimelineByChildIndex(nextChildIndex).isEmpty()) {
+      nextChildIndex = getNextChildIndex(nextChildIndex, shuffleModeEnabled);
+    }
+    if (nextChildIndex != C.INDEX_UNSET) {
+      return getFirstWindowIndexByChildIndex(nextChildIndex)
+          + getTimelineByChildIndex(nextChildIndex).getFirstWindowIndex(shuffleModeEnabled);
+    }
+    // If not found, this is the last window.
+    if (repeatMode == Player.REPEAT_MODE_ALL) {
+      return getFirstWindowIndex(shuffleModeEnabled);
+    }
+    return C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getPreviousWindowIndex(
+      int windowIndex, @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {
+    if (isAtomic) {
+      // Adapt repeat and shuffle mode to atomic concatenation.
+      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
+      shuffleModeEnabled = false;
+    }
+    // Find previous window within current child.
+    int childIndex = getChildIndexByWindowIndex(windowIndex);
+    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
+    int previousWindowIndexInChild =
+        getTimelineByChildIndex(childIndex)
+            .getPreviousWindowIndex(
+                windowIndex - firstWindowIndexInChild,
+                repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
+                shuffleModeEnabled);
+    if (previousWindowIndexInChild != C.INDEX_UNSET) {
+      return firstWindowIndexInChild + previousWindowIndexInChild;
+    }
+    // If not found, find last window of previous non-empty child.
+    int previousChildIndex = getPreviousChildIndex(childIndex, shuffleModeEnabled);
+    while (previousChildIndex != C.INDEX_UNSET
+        && getTimelineByChildIndex(previousChildIndex).isEmpty()) {
+      previousChildIndex = getPreviousChildIndex(previousChildIndex, shuffleModeEnabled);
+    }
+    if (previousChildIndex != C.INDEX_UNSET) {
+      return getFirstWindowIndexByChildIndex(previousChildIndex)
+          + getTimelineByChildIndex(previousChildIndex).getLastWindowIndex(shuffleModeEnabled);
+    }
+    // If not found, this is the first window.
+    if (repeatMode == Player.REPEAT_MODE_ALL) {
+      return getLastWindowIndex(shuffleModeEnabled);
+    }
+    return C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getLastWindowIndex(boolean shuffleModeEnabled) {
+    if (childCount == 0) {
+      return C.INDEX_UNSET;
+    }
+    if (isAtomic) {
+      shuffleModeEnabled = false;
+    }
+    // Find last non-empty child.
+    int lastChildIndex = shuffleModeEnabled ? shuffleOrder.getLastIndex() : childCount - 1;
+    while (getTimelineByChildIndex(lastChildIndex).isEmpty()) {
+      lastChildIndex = getPreviousChildIndex(lastChildIndex, shuffleModeEnabled);
+      if (lastChildIndex == C.INDEX_UNSET) {
+        // All children are empty.
+        return C.INDEX_UNSET;
+      }
+    }
+    return getFirstWindowIndexByChildIndex(lastChildIndex)
+        + getTimelineByChildIndex(lastChildIndex).getLastWindowIndex(shuffleModeEnabled);
+  }
+
+  @Override
+  public int getFirstWindowIndex(boolean shuffleModeEnabled) {
+    if (childCount == 0) {
+      return C.INDEX_UNSET;
+    }
+    if (isAtomic) {
+      shuffleModeEnabled = false;
+    }
+    // Find first non-empty child.
+    int firstChildIndex = shuffleModeEnabled ? shuffleOrder.getFirstIndex() : 0;
+    while (getTimelineByChildIndex(firstChildIndex).isEmpty()) {
+      firstChildIndex = getNextChildIndex(firstChildIndex, shuffleModeEnabled);
+      if (firstChildIndex == C.INDEX_UNSET) {
+        // All children are empty.
+        return C.INDEX_UNSET;
+      }
+    }
+    return getFirstWindowIndexByChildIndex(firstChildIndex)
+        + getTimelineByChildIndex(firstChildIndex).getFirstWindowIndex(shuffleModeEnabled);
+  }
+
+  @Override
+  public final Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
+    int childIndex = getChildIndexByWindowIndex(windowIndex);
+    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
+    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
+    getTimelineByChildIndex(childIndex)
+        .getWindow(windowIndex - firstWindowIndexInChild, window, defaultPositionProjectionUs);
+    Object childUid = getChildUidByChildIndex(childIndex);
+    // Don't create new objects if the child is using SINGLE_WINDOW_UID.
+    window.uid =
+        Window.SINGLE_WINDOW_UID.equals(window.uid)
+            ? childUid
+            : getConcatenatedUid(childUid, window.uid);
+    window.firstPeriodIndex += firstPeriodIndexInChild;
+    window.lastPeriodIndex += firstPeriodIndexInChild;
+    return window;
+  }
+
+  @Override
+  public final Period getPeriodByUid(Object uid, Period period) {
+    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);
+    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);
+    int childIndex = getChildIndexByChildUid(childUid);
+    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
+    getTimelineByChildIndex(childIndex).getPeriodByUid(periodUid, period);
+    period.windowIndex += firstWindowIndexInChild;
+    period.uid = uid;
+    return period;
+  }
+
+  @Override
+  public final Period getPeriod(int periodIndex, Period period, boolean setIds) {
+    int childIndex = getChildIndexByPeriodIndex(periodIndex);
+    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
+    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
+    getTimelineByChildIndex(childIndex)
+        .getPeriod(periodIndex - firstPeriodIndexInChild, period, setIds);
+    period.windowIndex += firstWindowIndexInChild;
+    if (setIds) {
+      period.uid =
+          getConcatenatedUid(
+              getChildUidByChildIndex(childIndex), Assertions.checkNotNull(period.uid));
+    }
+    return period;
+  }
+
+  @Override
+  public final int getIndexOfPeriod(Object uid) {
+    if (!(uid instanceof Pair)) {
+      return C.INDEX_UNSET;
+    }
+    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);
+    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);
+    int childIndex = getChildIndexByChildUid(childUid);
+    if (childIndex == C.INDEX_UNSET) {
+      return C.INDEX_UNSET;
+    }
+    int periodIndexInChild = getTimelineByChildIndex(childIndex).getIndexOfPeriod(periodUid);
+    return periodIndexInChild == C.INDEX_UNSET
+        ? C.INDEX_UNSET
+        : getFirstPeriodIndexByChildIndex(childIndex) + periodIndexInChild;
+  }
+
+  @Override
+  public final Object getUidOfPeriod(int periodIndex) {
+    int childIndex = getChildIndexByPeriodIndex(periodIndex);
+    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
+    Object periodUidInChild =
+        getTimelineByChildIndex(childIndex).getUidOfPeriod(periodIndex - firstPeriodIndexInChild);
+    return getConcatenatedUid(getChildUidByChildIndex(childIndex), periodUidInChild);
+  }
+
+  /**
+   * Returns the index of the child timeline containing the given period index.
+   *
+   * @param periodIndex A valid period index within the bounds of the timeline.
+   */
+  protected abstract int getChildIndexByPeriodIndex(int periodIndex);
+
+  /**
+   * Returns the index of the child timeline containing the given window index.
+   *
+   * @param windowIndex A valid window index within the bounds of the timeline.
+   */
+  protected abstract int getChildIndexByWindowIndex(int windowIndex);
+
+  /**
+   * Returns the index of the child timeline with the given UID or {@link C#INDEX_UNSET} if not
+   * found.
+   *
+   * @param childUid A child UID.
+   * @return Index of child timeline or {@link C#INDEX_UNSET} if UID was not found.
+   */
+  protected abstract int getChildIndexByChildUid(Object childUid);
+
+  /**
+   * Returns the child timeline for the child with the given index.
+   *
+   * @param childIndex A valid child index within the bounds of the timeline.
+   */
+  protected abstract Timeline getTimelineByChildIndex(int childIndex);
+
+  /**
+   * Returns the first period index belonging to the child timeline with the given index.
+   *
+   * @param childIndex A valid child index within the bounds of the timeline.
+   */
+  protected abstract int getFirstPeriodIndexByChildIndex(int childIndex);
+
+  /**
+   * Returns the first window index belonging to the child timeline with the given index.
+   *
+   * @param childIndex A valid child index within the bounds of the timeline.
+   */
+  protected abstract int getFirstWindowIndexByChildIndex(int childIndex);
+
+  /**
+   * Returns the UID of the child timeline with the given index.
+   *
+   * @param childIndex A valid child index within the bounds of the timeline.
+   */
+  protected abstract Object getChildUidByChildIndex(int childIndex);
+
+  private int getNextChildIndex(int childIndex, boolean shuffleModeEnabled) {
+    return shuffleModeEnabled
+        ? shuffleOrder.getNextIndex(childIndex)
+        : childIndex < childCount - 1 ? childIndex + 1 : C.INDEX_UNSET;
+  }
+
+  private int getPreviousChildIndex(int childIndex, boolean shuffleModeEnabled) {
+    return shuffleModeEnabled
+        ? shuffleOrder.getPreviousIndex(childIndex)
+        : childIndex > 0 ? childIndex - 1 : C.INDEX_UNSET;
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
index 74d3f4b..86e00e0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
@@ -18,8 +18,6 @@ package com.google.android.exoplayer2.source;
 import android.os.Handler;
 import android.os.Looper;
 import androidx.annotation.Nullable;
-
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -41,7 +39,6 @@ public abstract class BaseMediaSource implements MediaSource {
 
   @Nullable private Looper looper;
   @Nullable private Timeline timeline;
-  @Nullable private ExoPlayer player;
 
   public BaseMediaSource() {
     mediaSourceCallers = new ArrayList<>(/* initialCapacity= */ 1);
@@ -49,16 +46,9 @@ public abstract class BaseMediaSource implements MediaSource {
     eventDispatcher = new MediaSourceEventListener.EventDispatcher();
   }
 
-  @Override
-  public boolean isTcp() { return true; }
-
-  @Override
-  public boolean isLive() {
-    return false;
-  }
-
   /**
-   * Starts source preparation and enables the source, see {@link MediaSource#prepareSource(MediaSourceCaller, TransferListener, ExoPlayer)}. This method is called at most once until the next call to {@link
+   * Starts source preparation and enables the source, see {@link #prepareSource(MediaSourceCaller,
+   * TransferListener)}. This method is called at most once until the next call to {@link
    * #releaseSourceInternal()}.
    *
    * @param mediaTransferListener The transfer listener which should be informed of any media data
@@ -150,19 +140,13 @@ public abstract class BaseMediaSource implements MediaSource {
     eventDispatcher.removeEventListener(eventListener);
   }
 
-  @Nullable
-  public ExoPlayer getPlayer() {
-    return player;
-  }
-
   @Override
   public final void prepareSource(
-          MediaSourceCaller caller, @Nullable TransferListener mediaTransferListener, ExoPlayer player) {
+      MediaSourceCaller caller, @Nullable TransferListener mediaTransferListener) {
     Looper looper = Looper.myLooper();
     Assertions.checkArgument(this.looper == null || this.looper == looper);
     Timeline timeline = this.timeline;
     mediaSourceCallers.add(caller);
-    this.player = player;
     if (this.looper == null) {
       this.looper = looper;
       enabledMediaSourceCallers.add(caller);
@@ -173,7 +157,6 @@ public abstract class BaseMediaSource implements MediaSource {
     }
   }
 
-
   @Override
   public final void enable(MediaSourceCaller caller) {
     Assertions.checkNotNull(looper);
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
index c96af39..8aafb9a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -172,16 +172,6 @@ public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callb
   }
 
   @Override
-  public void pause() {
-    mediaPeriod.pause();
-  }
-
-  @Override
-  public void resume() {
-    mediaPeriod.resume();
-  }
-
-  @Override
   public long seekToUs(long positionUs) {
     pendingInitialDiscontinuityPositionUs = C.TIME_UNSET;
     for (ClippingSampleStream sampleStream : sampleStreams) {
@@ -221,6 +211,11 @@ public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callb
     return mediaPeriod.continueLoading(positionUs);
   }
 
+  @Override
+  public boolean isLoading() {
+    return mediaPeriod.isLoading();
+  }
+
   // MediaPeriod.Callback implementation.
 
   @Override
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
index 20d7adc..7077416 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
@@ -112,7 +112,7 @@ public abstract class CompositeMediaSource<T> extends BaseMediaSource {
     MediaSourceEventListener eventListener = new ForwardingEventListener(id);
     childSources.put(id, new MediaSourceAndListener(mediaSource, caller, eventListener));
     mediaSource.addEventListener(Assertions.checkNotNull(eventHandler), eventListener);
-    mediaSource.prepareSource(caller, mediaTransferListener, getPlayer());
+    mediaSource.prepareSource(caller, mediaTransferListener);
     if (!isEnabled()) {
       mediaSource.disable(caller);
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java b/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
index c41933b..b583705 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
@@ -83,4 +83,13 @@ public class CompositeSequenceableLoader implements SequenceableLoader {
     return madeProgress;
   }
 
+  @Override
+  public boolean isLoading() {
+    for (SequenceableLoader loader : loaders) {
+      if (loader.isLoading()) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index cfd0ad9..8dfea1e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -19,7 +19,6 @@ import android.os.Handler;
 import android.os.Message;
 import androidx.annotation.GuardedBy;
 import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.AbstractConcatenatedTimeline;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource.MediaSourceHolder;
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java b/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java
deleted file mode 100644
index b6f730c..0000000
--- a/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source;
-
-import android.os.Looper;
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.FormatHolder;
-import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.drm.DrmInitData;
-import com.google.android.exoplayer2.drm.DrmSession;
-import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
-import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
-
-/**
- * Reads from a {@link SampleQueue} and attaches {@link DrmSession} references to the {@link Format
- * Formats} of encrypted regions.
- */
-public final class DecryptableSampleQueueReader {
-
-  private final SampleQueue upstream;
-  private final DrmSessionManager<?> sessionManager;
-  private final FormatHolder formatHolder;
-  private final boolean playClearSamplesWithoutKeys;
-  private @MonotonicNonNull Format currentFormat;
-  @Nullable private DrmSession<?> currentSession;
-
-  /**
-   * Creates a sample queue reader.
-   *
-   * @param upstream The {@link SampleQueue} from which the created reader will read samples.
-   * @param sessionManager The {@link DrmSessionManager} that will provide {@link DrmSession
-   *     DrmSessions} for the encrypted regions.
-   */
-  public DecryptableSampleQueueReader(SampleQueue upstream, DrmSessionManager<?> sessionManager) {
-    this.upstream = upstream;
-    this.sessionManager = sessionManager;
-    formatHolder = new FormatHolder();
-    playClearSamplesWithoutKeys =
-        (sessionManager.getFlags() & DrmSessionManager.FLAG_PLAY_CLEAR_SAMPLES_WITHOUT_KEYS) != 0;
-  }
-
-  /** Releases any resources acquired by this reader. */
-  public void release() {
-    if (currentSession != null) {
-      currentSession.releaseReference();
-      currentSession = null;
-    }
-  }
-
-  /**
-   * Throws an error that's preventing data from being read. Does nothing if no such error exists.
-   *
-   * @throws IOException The underlying error.
-   */
-  public void maybeThrowError() throws IOException {
-    // TODO: Avoid throwing if the DRM error is not preventing a read operation.
-    if (currentSession != null && currentSession.getState() == DrmSession.STATE_ERROR) {
-      throw Assertions.checkNotNull(currentSession.getError());
-    }
-  }
-
-  /**
-   * Reads from the upstream {@link SampleQueue}, populating {@link FormatHolder#drmSession} if the
-   * current {@link Format#drmInitData} is not null.
-   *
-   * <p>This reader guarantees that any read results are usable by clients. An encrypted sample will
-   * only be returned along with a {@link FormatHolder#drmSession} that has available keys.
-   *
-   * @param outputFormatHolder A {@link FormatHolder} to populate in the case of reading a format.
-   *     {@link FormatHolder#drmSession} will be populated if the read format's {@link
-   *     Format#drmInitData} is not null.
-   * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If the end of the stream has been reached, the {@link
-   *     C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. If a {@link
-   *     DecoderInputBuffer#isFlagsOnly() flags-only} buffer is passed, only the buffer flags may be
-   *     populated by this method and the read position of the queue will not change.
-   * @param formatRequired Whether the caller requires that the format of the stream be read even if
-   *     it's not changing. A sample will never be read if set to true, however it is still possible
-   *     for the end of stream or nothing to be read.
-   * @param loadingFinished True if an empty queue should be considered the end of the stream.
-   * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
-   *     be set if the buffer's timestamp is less than this value.
-   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
-   *     {@link C#RESULT_BUFFER_READ}.
-   */
-  @SuppressWarnings("ReferenceEquality")
-  public int read(
-      FormatHolder outputFormatHolder,
-      DecoderInputBuffer buffer,
-      boolean formatRequired,
-      boolean loadingFinished,
-      long decodeOnlyUntilUs) {
-
-    boolean readFlagFormatRequired = false;
-    boolean readFlagAllowOnlyClearBuffers = false;
-    boolean onlyPropagateFormatChanges = false;
-
-    if (currentFormat == null || formatRequired) {
-      readFlagFormatRequired = true;
-    } else if (sessionManager != DrmSessionManager.DUMMY
-        && currentFormat.drmInitData != null
-        && Assertions.checkNotNull(currentSession).getState()
-            != DrmSession.STATE_OPENED_WITH_KEYS) {
-      if (playClearSamplesWithoutKeys) {
-        // Content is encrypted and keys are not available, but clear samples are ok for reading.
-        readFlagAllowOnlyClearBuffers = true;
-      } else {
-        // We must not read any samples, but we may still read a format or the end of stream.
-        // However, because the formatRequired argument is false, we should not propagate a read
-        // format unless it is different than the current format.
-        onlyPropagateFormatChanges = true;
-        readFlagFormatRequired = true;
-      }
-    }
-
-    int result =
-        upstream.read(
-            formatHolder,
-            buffer,
-            readFlagFormatRequired,
-            readFlagAllowOnlyClearBuffers,
-            loadingFinished,
-            decodeOnlyUntilUs);
-    if (result == C.RESULT_FORMAT_READ) {
-      if (onlyPropagateFormatChanges && currentFormat == formatHolder.format) {
-        return C.RESULT_NOTHING_READ;
-      }
-      onFormat(Assertions.checkNotNull(formatHolder.format), outputFormatHolder);
-    }
-    return result;
-  }
-
-  /**
-   * Updates the current format and manages any necessary DRM resources.
-   *
-   * @param format The format read from upstream.
-   * @param outputFormatHolder The output {@link FormatHolder}.
-   */
-  private void onFormat(Format format, FormatHolder outputFormatHolder) {
-    outputFormatHolder.format = format;
-    boolean isFirstFormat = currentFormat == null;
-    DrmInitData oldDrmInitData = currentFormat != null ? currentFormat.drmInitData : null;
-    currentFormat = format;
-    if (sessionManager == DrmSessionManager.DUMMY) {
-      // Avoid attempting to acquire a session using the dummy DRM session manager. It's likely that
-      // the media source creation has not yet been migrated and the renderer can acquire the
-      // session for the read DRM init data.
-      // TODO: Remove once renderers are migrated [Internal ref: b/122519809].
-      return;
-    }
-    outputFormatHolder.includesDrmSession = true;
-    outputFormatHolder.drmSession = currentSession;
-    if (!isFirstFormat && Util.areEqual(oldDrmInitData, format.drmInitData)) {
-      // Nothing to do.
-      return;
-    }
-    // Ensure we acquire the new session before releasing the previous one in case the same session
-    // can be used for both DrmInitData.
-    DrmSession<?> previousSession = currentSession;
-    DrmInitData drmInitData = currentFormat.drmInitData;
-    Looper playbackLooper = Assertions.checkNotNull(Looper.myLooper());
-    currentSession =
-        drmInitData != null
-            ? sessionManager.acquireSession(playbackLooper, drmInitData)
-            : sessionManager.acquirePlaceholderSession(playbackLooper);
-    outputFormatHolder.drmSession = currentSession;
-
-    if (previousSession != null) {
-      previousSession.releaseReference();
-    }
-  }
-
-  /** Returns whether there is data available for reading. */
-  public boolean isReady(boolean loadingFinished) {
-    @SampleQueue.PeekResult int nextInQueue = upstream.peekNext();
-    if (nextInQueue == SampleQueue.PEEK_RESULT_NOTHING) {
-      return loadingFinished;
-    } else if (nextInQueue == SampleQueue.PEEK_RESULT_FORMAT) {
-      return true;
-    } else if (nextInQueue == SampleQueue.PEEK_RESULT_BUFFER_CLEAR) {
-      return currentSession == null || playClearSamplesWithoutKeys;
-    } else if (nextInQueue == SampleQueue.PEEK_RESULT_BUFFER_ENCRYPTED) {
-      return sessionManager == DrmSessionManager.DUMMY
-          || Assertions.checkNotNull(currentSession).getState()
-              == DrmSession.STATE_OPENED_WITH_KEYS;
-    } else {
-      throw new IllegalStateException();
-    }
-  }
-}
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java b/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java
index 14bafda..fbb3a86 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/DefaultMediaSourceEventListener.java
@@ -15,78 +15,9 @@
  */
 package com.google.android.exoplayer2.source;
 
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import java.io.IOException;
-
 /**
- * A {@link MediaSourceEventListener} allowing selective overrides. All methods are implemented as
- * no-ops.
+ * @deprecated Use {@link MediaSourceEventListener} interface directly for selective overrides as
+ *     all methods are implemented as no-op default methods.
  */
-public abstract class DefaultMediaSourceEventListener implements MediaSourceEventListener {
-
-  @Override
-  public void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onMediaPeriodReleased(int windowIndex, MediaPeriodId mediaPeriodId) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onLoadStarted(
-      int windowIndex,
-      @Nullable MediaPeriodId mediaPeriodId,
-      LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onLoadCompleted(
-      int windowIndex,
-      @Nullable MediaPeriodId mediaPeriodId,
-      LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onLoadCanceled(
-      int windowIndex,
-      @Nullable MediaPeriodId mediaPeriodId,
-      LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onLoadError(
-      int windowIndex,
-      @Nullable MediaPeriodId mediaPeriodId,
-      LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData,
-      IOException error,
-      boolean wasCanceled) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onReadingStarted(int windowIndex, MediaPeriodId mediaPeriodId) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onUpstreamDiscarded(
-      int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onDownstreamFormatChanged(
-      int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {
-    // Do nothing.
-  }
-}
+@Deprecated
+public abstract class DefaultMediaSourceEventListener implements MediaSourceEventListener {}
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index ee731cb..060027f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -365,7 +365,7 @@ public final class ExtractorMediaSource extends CompositeMediaSource<Void> {
   }
 
   @Deprecated
-  private static final class EventListenerWrapper extends DefaultMediaSourceEventListener {
+  private static final class EventListenerWrapper implements MediaSourceEventListener {
 
     private final EventListener eventListener;
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java b/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java
index 3d31e2a..d097073 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/IcyDataSource.java
@@ -110,7 +110,7 @@ import java.util.Map;
   /**
    * Reads an ICY stream metadata block, passing it to {@link #listener} unless the block is empty.
    *
-   * @return True if the block was extracted, including if it's length byte indicated a length of
+   * @return True if the block was extracted, including if its length byte indicated a length of
    *     zero. False if the end of the stream was reached.
    * @throws IOException If an error occurs reading from the wrapped {@link DataSource}.
    */
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 68bed25..ac23e2a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.source;
 
 import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.AbstractConcatenatedTimeline;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java b/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java
index 65751f2..17ac6c0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java
@@ -187,16 +187,6 @@ public final class MaskingMediaPeriod implements MediaPeriod, MediaPeriod.Callba
   }
 
   @Override
-  public void pause() {
-    mediaPeriod.pause();
-  }
-
-  @Override
-  public void resume() {
-    mediaPeriod.resume();
-  }
-
-  @Override
   public long seekToUs(long positionUs) {
     return castNonNull(mediaPeriod).seekToUs(positionUs);
   }
@@ -222,6 +212,11 @@ public final class MaskingMediaPeriod implements MediaPeriod, MediaPeriod.Callba
   }
 
   @Override
+  public boolean isLoading() {
+    return mediaPeriod != null && mediaPeriod.isLoading();
+  }
+
+  @Override
   public void onContinueLoadingRequested(MediaPeriod source) {
     castNonNull(callback).onContinueLoadingRequested(this);
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
index 33bbf79..891cb35 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
@@ -17,7 +17,6 @@ package com.google.android.exoplayer2.source;
 
 import android.util.Pair;
 import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Window;
@@ -62,7 +61,7 @@ public final class MaskingMediaSource extends CompositeMediaSource<Void> {
   }
 
   /** Returns the {@link Timeline}. */
-  public synchronized Timeline getTimeline() {
+  public Timeline getTimeline() {
     return timeline;
   }
 
@@ -130,7 +129,7 @@ public final class MaskingMediaSource extends CompositeMediaSource<Void> {
   }
 
   @Override
-  protected synchronized void onChildSourceInfoRefreshed(
+  protected void onChildSourceInfoRefreshed(
       Void id, MediaSource mediaSource, Timeline newTimeline) {
     if (isPrepared) {
       timeline = timeline.cloneWithUpdatedTimeline(newTimeline);
@@ -294,8 +293,7 @@ public final class MaskingMediaSource extends CompositeMediaSource<Void> {
   }
 
   /** Dummy placeholder timeline with one dynamic window with a period of indeterminate duration. */
-  @VisibleForTesting
-  public static final class DummyTimeline extends Timeline {
+  private static final class DummyTimeline extends Timeline {
 
     @Nullable private final Object tag;
 
@@ -319,6 +317,7 @@ public final class MaskingMediaSource extends CompositeMediaSource<Void> {
           /* isSeekable= */ false,
           // Dynamic window to indicate pending timeline updates.
           /* isDynamic= */ true,
+          /* isLive= */ false,
           /* defaultPositionUs= */ 0,
           /* durationUs= */ C.TIME_UNSET,
           /* firstPeriodIndex= */ 0,
@@ -334,8 +333,8 @@ public final class MaskingMediaSource extends CompositeMediaSource<Void> {
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       return period.set(
-          /* id= */ setIds ? 0 : null,
-          /* uid= */ setIds ? MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID : null,
+          /* id= */ 0,
+          /* uid= */ MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID,
           /* windowIndex= */ 0,
           /* durationUs = */ C.TIME_UNSET,
           /* positionInWindowUs= */ 0);
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index ba717d5..2e2cf9c 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -165,24 +165,6 @@ public interface MediaPeriod extends SequenceableLoader {
   long readDiscontinuity();
 
   /**
-   * Attempts to pause to the specified position in microseconds.
-   *
-   * <p>This method should only be called after the period has been prepared.
-   *
-   * @return nothing.
-   */
-  void pause();
-
-  /**
-   * Attempts to resume to the specified position in microseconds.
-   *
-   * <p>This method should only be called after the period has been prepared.
-   *
-   * @return nothing.
-   */
-  void resume();
-
-  /**
    * Attempts to seek to the specified position in microseconds.
    *
    * <p>After this method has been called, all {@link SampleStream}s provided by the period are
@@ -249,6 +231,9 @@ public interface MediaPeriod extends SequenceableLoader {
   @Override
   boolean continueLoading(long positionUs);
 
+  /** Returns whether the media period is currently loading. */
+  boolean isLoading();
+
   /**
    * Re-evaluates the buffer given the playback position.
    *
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 61c8226..5ee980d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -18,7 +18,6 @@ package com.google.android.exoplayer2.source;
 import android.os.Handler;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -32,7 +31,8 @@ import java.io.IOException;
  *   <li>To provide the player with a {@link Timeline} defining the structure of its media, and to
  *       provide a new timeline whenever the structure of the media changes. The MediaSource
  *       provides these timelines by calling {@link MediaSourceCaller#onSourceInfoRefreshed} on the
- *       {@link MediaSourceCaller}s passed to {@link #prepareSource(MediaSourceCaller, TransferListener, ExoPlayer)}.
+ *       {@link MediaSourceCaller}s passed to {@link #prepareSource(MediaSourceCaller,
+ *       TransferListener)}.
  *   <li>To provide {@link MediaPeriod} instances for the periods in its timeline. MediaPeriods are
  *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator, long)}, and provide a
  *       way for the player to load and read the media.
@@ -212,16 +212,6 @@ public interface MediaSource {
   }
 
   /**
-   * Returns whether the media source is on TCP.
-   */
-  boolean isTcp();
-
-  /**
-   * Returns whether the media source is a live.
-   */
-  boolean isLive();
-
-  /**
    * Adds a {@link MediaSourceEventListener} to the list of listeners which are notified of media
    * source events.
    *
@@ -255,20 +245,21 @@ public interface MediaSource {
    *
    * <p>For each call to this method, a call to {@link #releaseSource(MediaSourceCaller)} is needed
    * to remove the caller and to release the source if no longer required.
-   *  @param caller The {@link MediaSourceCaller} to be registered.
+   *
+   * @param caller The {@link MediaSourceCaller} to be registered.
    * @param mediaTransferListener The transfer listener which should be informed of any media data
    *     transfers. May be null if no listener is available. Note that this listener should be only
    *     informed of transfers related to the media loads and not of auxiliary loads for manifests
-   * @param player
+   *     and other data.
    */
-  void prepareSource(MediaSourceCaller caller, @Nullable TransferListener mediaTransferListener, ExoPlayer player);
+  void prepareSource(MediaSourceCaller caller, @Nullable TransferListener mediaTransferListener);
 
   /**
    * Throws any pending error encountered while loading or refreshing source information.
    *
    * <p>Should not be called directly from application code.
    *
-   * <p>Must only be called after {@link #prepareSource(MediaSourceCaller, TransferListener, ExoPlayer)}.
+   * <p>Must only be called after {@link #prepareSource(MediaSourceCaller, TransferListener)}.
    */
   void maybeThrowSourceInfoRefreshError() throws IOException;
 
@@ -277,7 +268,7 @@ public interface MediaSource {
    *
    * <p>Should not be called directly from application code.
    *
-   * <p>Must only be called after {@link #prepareSource(MediaSourceCaller, TransferListener, ExoPlayer)}.
+   * <p>Must only be called after {@link #prepareSource(MediaSourceCaller, TransferListener)}.
    *
    * @param caller The {@link MediaSourceCaller} enabling the source.
    */
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java b/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
index ab8d86c..9e6f4f9 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
@@ -164,7 +164,7 @@ public interface MediaSourceEventListener {
    * @param windowIndex The window index in the timeline this media period belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} of the created media period.
    */
-  void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId);
+  default void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId) {}
 
   /**
    * Called when a media period is released by the media source.
@@ -172,7 +172,7 @@ public interface MediaSourceEventListener {
    * @param windowIndex The window index in the timeline this media period belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} of the released media period.
    */
-  void onMediaPeriodReleased(int windowIndex, MediaPeriodId mediaPeriodId);
+  default void onMediaPeriodReleased(int windowIndex, MediaPeriodId mediaPeriodId) {}
 
   /**
    * Called when a load begins.
@@ -185,11 +185,11 @@ public interface MediaSourceEventListener {
    *     LoadEventInfo#responseHeaders} will be empty.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
-  void onLoadStarted(
+  default void onLoadStarted(
       int windowIndex,
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData);
+      MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a load ends.
@@ -203,11 +203,11 @@ public interface MediaSourceEventListener {
    *     event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
-  void onLoadCompleted(
+  default void onLoadCompleted(
       int windowIndex,
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData);
+      MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a load is canceled.
@@ -221,11 +221,11 @@ public interface MediaSourceEventListener {
    *     event.
    * @param mediaLoadData The {@link MediaLoadData} defining the data being loaded.
    */
-  void onLoadCanceled(
+  default void onLoadCanceled(
       int windowIndex,
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
-      MediaLoadData mediaLoadData);
+      MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a load error occurs.
@@ -252,13 +252,13 @@ public interface MediaSourceEventListener {
    * @param error The load error.
    * @param wasCanceled Whether the load was canceled as a result of the error.
    */
-  void onLoadError(
+  default void onLoadError(
       int windowIndex,
       @Nullable MediaPeriodId mediaPeriodId,
       LoadEventInfo loadEventInfo,
       MediaLoadData mediaLoadData,
       IOException error,
-      boolean wasCanceled);
+      boolean wasCanceled) {}
 
   /**
    * Called when a media period is first being read from.
@@ -266,7 +266,7 @@ public interface MediaSourceEventListener {
    * @param windowIndex The window index in the timeline this media period belongs to.
    * @param mediaPeriodId The {@link MediaPeriodId} of the media period being read from.
    */
-  void onReadingStarted(int windowIndex, MediaPeriodId mediaPeriodId);
+  default void onReadingStarted(int windowIndex, MediaPeriodId mediaPeriodId) {}
 
   /**
    * Called when data is removed from the back of a media buffer, typically so that it can be
@@ -276,8 +276,8 @@ public interface MediaSourceEventListener {
    * @param mediaPeriodId The {@link MediaPeriodId} the media belongs to.
    * @param mediaLoadData The {@link MediaLoadData} defining the media being discarded.
    */
-  void onUpstreamDiscarded(
-      int windowIndex, MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData);
+  default void onUpstreamDiscarded(
+      int windowIndex, MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {}
 
   /**
    * Called when a downstream format change occurs (i.e. when the format of the media being read
@@ -287,8 +287,8 @@ public interface MediaSourceEventListener {
    * @param mediaPeriodId The {@link MediaPeriodId} the media belongs to.
    * @param mediaLoadData The {@link MediaLoadData} defining the newly selected downstream data.
    */
-  void onDownstreamFormatChanged(
-      int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData);
+  default void onDownstreamFormatChanged(
+      int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {}
 
   /** Dispatches events to {@link MediaSourceEventListener}s. */
   final class EventDispatcher {
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java b/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
index 770d3b1..afa25d6 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
@@ -170,6 +170,11 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   }
 
   @Override
+  public boolean isLoading() {
+    return compositeSequenceableLoader.isLoading();
+  }
+
+  @Override
   public long getNextLoadPositionUs() {
     return compositeSequenceableLoader.getNextLoadPositionUs();
   }
@@ -201,20 +206,6 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   }
 
   @Override
-  public void pause() {
-    for (MediaPeriod enabledPeriod : enabledPeriods) {
-      enabledPeriod.pause();
-    }
-  }
-
-  @Override
-  public void resume() {
-    for (MediaPeriod enabledPeriod : enabledPeriods) {
-      enabledPeriod.resume();
-    }
-  }
-
-  @Override
   public long seekToUs(long positionUs) {
     positionUs = enabledPeriods[0].seekToUs(positionUs);
     // Additional periods must seek to the same position.
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java b/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
index ecb1bfc..a10c3bc 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
@@ -34,6 +34,7 @@ import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.SeekMap.SeekPoints;
 import com.google.android.exoplayer2.extractor.SeekMap.Unseekable;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -55,6 +56,9 @@ import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** A {@link MediaPeriod} that extracts data using an {@link Extractor}. */
@@ -71,13 +75,14 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   interface Listener {
 
     /**
-     * Called when the duration or ability to seek within the period changes.
+     * Called when the duration, the ability to seek within the period, or the categorization as
+     * live stream changes.
      *
      * @param durationUs The duration of the period, or {@link C#TIME_UNSET}.
      * @param isSeekable Whether the period is seekable.
+     * @param isLive Whether the period is live.
      */
-    void onSourceInfoRefreshed(long durationUs, boolean isSeekable);
-
+    void onSourceInfoRefreshed(long durationUs, boolean isSeekable, boolean isLive);
   }
 
   /**
@@ -86,6 +91,8 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
    */
   private static final long DEFAULT_LAST_SAMPLE_DURATION_US = 10000;
 
+  private static final Map<String, String> ICY_METADATA_HEADERS = createIcyMetadataHeaders();
+
   private static final Format ICY_FORMAT =
       Format.createSampleFormat("icy", MimeTypes.APPLICATION_ICY, Format.OFFSET_SAMPLE_RELATIVE);
 
@@ -109,7 +116,6 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   @Nullable private SeekMap seekMap;
   @Nullable private IcyHeaders icyHeaders;
   private SampleQueue[] sampleQueues;
-  private DecryptableSampleQueueReader[] sampleQueueReaders;
   private TrackId[] sampleQueueTrackIds;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
@@ -124,6 +130,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   private int enabledTrackCount;
   private long durationUs;
   private long length;
+  private boolean isLive;
 
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
@@ -185,7 +192,6 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
     handler = new Handler();
     sampleQueueTrackIds = new TrackId[0];
     sampleQueues = new SampleQueue[0];
-    sampleQueueReaders = new DecryptableSampleQueueReader[0];
     pendingResetPositionUs = C.TIME_UNSET;
     length = C.LENGTH_UNSET;
     durationUs = C.TIME_UNSET;
@@ -198,10 +204,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       // Discard as much as we can synchronously. We only do this if we're prepared, since otherwise
       // sampleQueues may still be being modified by the loading thread.
       for (SampleQueue sampleQueue : sampleQueues) {
-        sampleQueue.discardToEnd();
-      }
-      for (DecryptableSampleQueueReader reader : sampleQueueReaders) {
-        reader.release();
+        sampleQueue.preRelease();
       }
     }
     loader.release(/* callback= */ this);
@@ -214,10 +217,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   @Override
   public void onLoaderReleased() {
     for (SampleQueue sampleQueue : sampleQueues) {
-      sampleQueue.reset();
-    }
-    for (DecryptableSampleQueueReader reader : sampleQueueReaders) {
-      reader.release();
+      sampleQueue.release();
     }
     extractorHolder.release();
   }
@@ -352,6 +352,11 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   }
 
   @Override
+  public boolean isLoading() {
+    return loader.isLoading() && loadCondition.isOpen();
+  }
+
+  @Override
   public long getNextLoadPositionUs() {
     return enabledTrackCount == 0 ? C.TIME_END_OF_SOURCE : getBufferedPositionUs();
   }
@@ -397,16 +402,6 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   }
 
   @Override
-  public void pause() {
-    // Do nothing.
-  }
-
-  @Override
-  public void resume() {
-    // Do nothing.
-  }
-
-  @Override
   public long seekToUs(long positionUs) {
     PreparedState preparedState = getPreparedState();
     SeekMap seekMap = preparedState.seekMap;
@@ -458,11 +453,11 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   // SampleStream methods.
 
   /* package */ boolean isReady(int track) {
-    return !suppressRead() && sampleQueueReaders[track].isReady(loadingFinished);
+    return !suppressRead() && sampleQueues[track].isReady(loadingFinished);
   }
 
   /* package */ void maybeThrowError(int sampleQueueIndex) throws IOException {
-    sampleQueueReaders[sampleQueueIndex].maybeThrowError();
+    sampleQueues[sampleQueueIndex].maybeThrowError();
     maybeThrowError();
   }
 
@@ -480,7 +475,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
     }
     maybeNotifyDownstreamFormat(sampleQueueIndex);
     int result =
-        sampleQueueReaders[sampleQueueIndex].read(
+        sampleQueues[sampleQueueIndex].read(
             formatHolder, buffer, formatRequired, loadingFinished, lastSeekPositionUs);
     if (result == C.RESULT_NOTHING_READ) {
       maybeStartDeferredRetry(sampleQueueIndex);
@@ -528,7 +523,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
     boolean[] trackIsAudioVideoFlags = getPreparedState().trackIsAudioVideoFlags;
     if (!pendingDeferredRetry
         || !trackIsAudioVideoFlags[track]
-        || sampleQueues[track].hasNextSample()) {
+        || sampleQueues[track].isReady(/* loadingFinished= */ false)) {
       return;
     }
     pendingResetPositionUs = 0;
@@ -556,7 +551,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       long largestQueuedTimestampUs = getLargestQueuedTimestampUs();
       durationUs = largestQueuedTimestampUs == Long.MIN_VALUE ? 0
           : largestQueuedTimestampUs + DEFAULT_LAST_SAMPLE_DURATION_US;
-      listener.onSourceInfoRefreshed(durationUs, isSeekable);
+      listener.onSourceInfoRefreshed(durationUs, isSeekable, isLive);
     }
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
@@ -687,7 +682,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
         return sampleQueues[i];
       }
     }
-    SampleQueue trackOutput = new SampleQueue(allocator);
+    SampleQueue trackOutput = new SampleQueue(allocator, drmSessionManager);
     trackOutput.setUpstreamFormatChangeListener(this);
     @NullableType
     TrackId[] sampleQueueTrackIds = Arrays.copyOf(this.sampleQueueTrackIds, trackCount + 1);
@@ -696,12 +691,6 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
     @NullableType SampleQueue[] sampleQueues = Arrays.copyOf(this.sampleQueues, trackCount + 1);
     sampleQueues[trackCount] = trackOutput;
     this.sampleQueues = Util.castNonNullTypeArray(sampleQueues);
-    @NullableType
-    DecryptableSampleQueueReader[] sampleQueueReaders =
-        Arrays.copyOf(this.sampleQueueReaders, trackCount + 1);
-    sampleQueueReaders[trackCount] =
-        new DecryptableSampleQueueReader(this.sampleQueues[trackCount], drmSessionManager);
-    this.sampleQueueReaders = Util.castNonNullTypeArray(sampleQueueReaders);
     return trackOutput;
   }
 
@@ -745,14 +734,12 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       }
       trackArray[i] = new TrackGroup(trackFormat);
     }
-    dataType =
-        length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET
-            ? C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE
-            : C.DATA_TYPE_MEDIA;
+    isLive = length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET;
+    dataType = isLive ? C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE : C.DATA_TYPE_MEDIA;
     preparedState =
         new PreparedState(seekMap, new TrackGroupArray(trackArray), trackIsAudioVideoFlags);
     prepared = true;
-    listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
+    listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable(), isLive);
     Assertions.checkNotNull(callback).onPrepared(this);
   }
 
@@ -985,6 +972,12 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
           }
           input = new DefaultExtractorInput(extractorDataSource, position, length);
           Extractor extractor = extractorHolder.selectExtractor(input, extractorOutput, uri);
+
+          // MP3 live streams commonly have seekable metadata, despite being unseekable.
+          if (icyHeaders != null && extractor instanceof Mp3Extractor) {
+            ((Mp3Extractor) extractor).disableSeeking();
+          }
+
           if (pendingExtractorSeek) {
             extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
@@ -1035,9 +1028,8 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
           position,
           C.LENGTH_UNSET,
           customCacheKey,
-          DataSpec.FLAG_ALLOW_ICY_METADATA
-              | DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN
-              | DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION);
+          DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN | DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION,
+          ICY_METADATA_HEADERS);
     }
 
     private void setLoadPosition(long position, long timeUs) {
@@ -1164,4 +1156,12 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       return 31 * id + (isIcyTrack ? 1 : 0);
     }
   }
+
+  private static Map<String, String> createIcyMetadataHeaders() {
+    Map<String, String> headers = new HashMap<>();
+    headers.put(
+        IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
+        IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
+    return Collections.unmodifiableMap(headers);
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
index 80bcdcd..c88972d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
@@ -220,6 +220,7 @@ public final class ProgressiveMediaSource extends BaseMediaSource
 
   private long timelineDurationUs;
   private boolean timelineIsSeekable;
+  private boolean timelineIsLive;
   @Nullable private TransferListener transferListener;
 
   // TODO: Make private when ExtractorMediaSource is deleted.
@@ -253,7 +254,7 @@ public final class ProgressiveMediaSource extends BaseMediaSource
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     transferListener = mediaTransferListener;
     drmSessionManager.prepare();
-    notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable);
+    notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable, timelineIsLive);
   }
 
   @Override
@@ -293,27 +294,32 @@ public final class ProgressiveMediaSource extends BaseMediaSource
   // ProgressiveMediaPeriod.Listener implementation.
 
   @Override
-  public void onSourceInfoRefreshed(long durationUs, boolean isSeekable) {
+  public void onSourceInfoRefreshed(long durationUs, boolean isSeekable, boolean isLive) {
     // If we already have the duration from a previous source info refresh, use it.
     durationUs = durationUs == C.TIME_UNSET ? timelineDurationUs : durationUs;
-    if (timelineDurationUs == durationUs && timelineIsSeekable == isSeekable) {
+    if (timelineDurationUs == durationUs
+        && timelineIsSeekable == isSeekable
+        && timelineIsLive == isLive) {
       // Suppress no-op source info changes.
       return;
     }
-    notifySourceInfoRefreshed(durationUs, isSeekable);
+    notifySourceInfoRefreshed(durationUs, isSeekable, isLive);
   }
 
   // Internal methods.
 
-  private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
+  private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable, boolean isLive) {
     timelineDurationUs = durationUs;
     timelineIsSeekable = isSeekable;
-    // TODO: Make timeline dynamic until its duration is known. This is non-trivial. See b/69703223.
+    timelineIsLive = isLive;
+    // TODO: Split up isDynamic into multiple fields to indicate which values may change. Then
+    // indicate that the duration may change until it's known. See [internal: b/69703223].
     refreshSourceInfo(
         new SinglePeriodTimeline(
             timelineDurationUs,
             timelineIsSeekable,
             /* isDynamic= */ false,
+            /* isLive= */ timelineIsLive,
             /* manifest= */ null,
             tag));
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java b/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
index 09bc438..bb578dd 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
@@ -15,14 +15,20 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.os.Looper;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.drm.DrmSession;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.extractor.TrackOutput.CryptoData;
-import com.google.android.exoplayer2.source.SampleQueue.PeekResult;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
 
 /**
  * A queue of metadata describing the contents of a media buffer.
@@ -42,6 +48,11 @@ import com.google.android.exoplayer2.util.Util;
 
   private static final int SAMPLE_CAPACITY_INCREMENT = 1000;
 
+  private final DrmSessionManager<?> drmSessionManager;
+
+  @Nullable private Format downstreamFormat;
+  @Nullable private DrmSession<?> currentDrmSession;
+
   private int capacity;
   private int[] sourceIds;
   private long[] offsets;
@@ -65,7 +76,8 @@ import com.google.android.exoplayer2.util.Util;
   private Format upstreamCommittedFormat;
   private int upstreamSourceId;
 
-  public SampleMetadataQueue() {
+  public SampleMetadataQueue(DrmSessionManager<?> drmSessionManager) {
+    this.drmSessionManager = drmSessionManager;
     capacity = SAMPLE_CAPACITY_INCREMENT;
     sourceIds = new int[capacity];
     offsets = new long[capacity];
@@ -80,6 +92,8 @@ import com.google.android.exoplayer2.util.Util;
     upstreamKeyframeRequired = true;
   }
 
+  // Called by the consuming thread, but only when there is no loading thread.
+
   /**
    * Clears all sample metadata from the queue.
    *
@@ -139,8 +153,29 @@ import com.google.android.exoplayer2.util.Util;
   // Called by the consuming thread.
 
   /**
-   * Returns the current absolute start index.
+   * Throws an error that's preventing data from being read. Does nothing if no such error exists.
+   *
+   * @throws IOException The underlying error.
    */
+  public void maybeThrowError() throws IOException {
+    // TODO: Avoid throwing if the DRM error is not preventing a read operation.
+    if (currentDrmSession != null && currentDrmSession.getState() == DrmSession.STATE_ERROR) {
+      throw Assertions.checkNotNull(currentDrmSession.getError());
+    }
+  }
+
+  /** Releases any owned {@link DrmSession} references. */
+  public void releaseDrmSessionReferences() {
+    if (currentDrmSession != null) {
+      currentDrmSession.release();
+      currentDrmSession = null;
+      // Clear downstream format to avoid violating the assumption that downstreamFormat.drmInitData
+      // != null implies currentSession != null
+      downstreamFormat = null;
+    }
+  }
+
+  /** Returns the current absolute start index. */
   public int getFirstIndex() {
     return absoluteFirstIndex;
   }
@@ -158,19 +193,12 @@ import com.google.android.exoplayer2.util.Util;
    *
    * @return The source id.
    */
-  public int peekSourceId() {
+  public synchronized int peekSourceId() {
     int relativeReadIndex = getRelativeIndex(readPosition);
     return hasNextSample() ? sourceIds[relativeReadIndex] : upstreamSourceId;
   }
 
   /**
-   * Returns whether a sample is available to be read.
-   */
-  public synchronized boolean hasNextSample() {
-    return readPosition != length;
-  }
-
-  /**
    * Returns the upstream {@link Format} in which samples are being queued.
    */
   public synchronized Format getUpstreamFormat() {
@@ -218,24 +246,28 @@ import com.google.android.exoplayer2.util.Util;
   }
 
   /**
-   * Returns a {@link PeekResult} depending on what a following call to {@link #read
-   * read(formatHolder, decoderInputBuffer, formatRequired= false, allowOnlyClearBuffers= false,
-   * loadingFinished= false, decodeOnlyUntilUs= 0)} would result in.
+   * Returns whether there is data available for reading.
+   *
+   * <p>Note: If the stream has ended then a buffer with the end of stream flag can always be read
+   * from {@link #read}. Hence an ended stream is always ready.
+   *
+   * @param loadingFinished Whether no more samples will be written to the sample queue. When true,
+   *     this method returns true if the sample queue is empty, because an empty sample queue means
+   *     the end of stream has been reached. When false, this method returns false if the sample
+   *     queue is empty.
    */
-  @SuppressWarnings("ReferenceEquality")
-  @PeekResult
-  public synchronized int peekNext(Format downstreamFormat) {
-    if (readPosition == length) {
-      return SampleQueue.PEEK_RESULT_NOTHING;
+  public boolean isReady(boolean loadingFinished) {
+    if (!hasNextSample()) {
+      return loadingFinished
+          || isLastSampleQueued
+          || (upstreamFormat != null && upstreamFormat != downstreamFormat);
     }
     int relativeReadIndex = getRelativeIndex(readPosition);
     if (formats[relativeReadIndex] != downstreamFormat) {
-      return SampleQueue.PEEK_RESULT_FORMAT;
-    } else {
-      return (flags[relativeReadIndex] & C.BUFFER_FLAG_ENCRYPTED) != 0
-          ? SampleQueue.PEEK_RESULT_BUFFER_ENCRYPTED
-          : SampleQueue.PEEK_RESULT_BUFFER_CLEAR;
+      // A format can be read.
+      return true;
     }
+    return mayReadSample(relativeReadIndex);
   }
 
   /**
@@ -254,11 +286,7 @@ import com.google.android.exoplayer2.util.Util;
    * @param formatRequired Whether the caller requires that the format of the stream be read even if
    *     it's not changing. A sample will never be read if set to true, however it is still possible
    *     for the end of stream or nothing to be read.
-   * @param allowOnlyClearBuffers If set to true, this method will not return encrypted buffers,
-   *     returning {@link C#RESULT_NOTHING_READ} (without advancing the read position) instead.
    * @param loadingFinished True if an empty queue should be considered the end of the stream.
-   * @param downstreamFormat The current downstream {@link Format}. If the format of the next sample
-   *     is different to the current downstream format then a format will be read.
    * @param extrasHolder The holder into which extra sample information should be written.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
@@ -268,16 +296,14 @@ import com.google.android.exoplayer2.util.Util;
       FormatHolder formatHolder,
       DecoderInputBuffer buffer,
       boolean formatRequired,
-      boolean allowOnlyClearBuffers,
       boolean loadingFinished,
-      Format downstreamFormat,
       SampleExtrasHolder extrasHolder) {
     if (!hasNextSample()) {
       if (loadingFinished || isLastSampleQueued) {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
       } else if (upstreamFormat != null && (formatRequired || upstreamFormat != downstreamFormat)) {
-        formatHolder.format = upstreamFormat;
+        onFormatResult(Assertions.checkNotNull(upstreamFormat), formatHolder);
         return C.RESULT_FORMAT_READ;
       } else {
         return C.RESULT_NOTHING_READ;
@@ -286,11 +312,11 @@ import com.google.android.exoplayer2.util.Util;
 
     int relativeReadIndex = getRelativeIndex(readPosition);
     if (formatRequired || formats[relativeReadIndex] != downstreamFormat) {
-      formatHolder.format = formats[relativeReadIndex];
+      onFormatResult(formats[relativeReadIndex], formatHolder);
       return C.RESULT_FORMAT_READ;
     }
 
-    if (allowOnlyClearBuffers && (flags[relativeReadIndex] & C.BUFFER_FLAG_ENCRYPTED) != 0) {
+    if (!mayReadSample(relativeReadIndex)) {
       return C.RESULT_NOTHING_READ;
     }
 
@@ -533,9 +559,74 @@ import com.google.android.exoplayer2.util.Util;
 
   // Internal methods.
 
+  private boolean hasNextSample() {
+    return readPosition != length;
+  }
+
+  /**
+   * Sets the downstream format, performs DRM resource management, and populates the {@code
+   * outputFormatHolder}.
+   *
+   * @param newFormat The new downstream format.
+   * @param outputFormatHolder The output {@link FormatHolder}.
+   */
+  private void onFormatResult(Format newFormat, FormatHolder outputFormatHolder) {
+    outputFormatHolder.format = newFormat;
+    boolean isFirstFormat = downstreamFormat == null;
+    DrmInitData oldDrmInitData = isFirstFormat ? null : downstreamFormat.drmInitData;
+    downstreamFormat = newFormat;
+    if (drmSessionManager == DrmSessionManager.DUMMY) {
+      // Avoid attempting to acquire a session using the dummy DRM session manager. It's likely that
+      // the media source creation has not yet been migrated and the renderer can acquire the
+      // session for the read DRM init data.
+      // TODO: Remove once renderers are migrated [Internal ref: b/122519809].
+      return;
+    }
+    DrmInitData newDrmInitData = newFormat.drmInitData;
+    outputFormatHolder.includesDrmSession = true;
+    outputFormatHolder.drmSession = currentDrmSession;
+    if (!isFirstFormat && Util.areEqual(oldDrmInitData, newDrmInitData)) {
+      // Nothing to do.
+      return;
+    }
+    // Ensure we acquire the new session before releasing the previous one in case the same session
+    // is being used for both DrmInitData.
+    DrmSession<?> previousSession = currentDrmSession;
+    Looper playbackLooper = Assertions.checkNotNull(Looper.myLooper());
+    currentDrmSession =
+        newDrmInitData != null
+            ? drmSessionManager.acquireSession(playbackLooper, newDrmInitData)
+            : drmSessionManager.acquirePlaceholderSession(
+                playbackLooper, MimeTypes.getTrackType(newFormat.sampleMimeType));
+    outputFormatHolder.drmSession = currentDrmSession;
+
+    if (previousSession != null) {
+      previousSession.release();
+    }
+  }
+
+  /**
+   * Returns whether it's possible to read the next sample.
+   *
+   * @param relativeReadIndex The relative read index of the next sample.
+   * @return Whether it's possible to read the next sample.
+   */
+  private boolean mayReadSample(int relativeReadIndex) {
+    if (drmSessionManager == DrmSessionManager.DUMMY) {
+      // TODO: Remove once renderers are migrated [Internal ref: b/122519809].
+      // For protected content it's likely that the DrmSessionManager is still being injected into
+      // the renderers. We assume that the renderers will be able to acquire a DrmSession if needed.
+      return true;
+    }
+    return currentDrmSession == null
+        || currentDrmSession.getState() == DrmSession.STATE_OPENED_WITH_KEYS
+        || ((flags[relativeReadIndex] & C.BUFFER_FLAG_ENCRYPTED) == 0
+            && currentDrmSession.playClearSamplesWithoutKeys());
+  }
+
   /**
-   * Finds the sample in the specified range that's before or at the specified time. If
-   * {@code keyframe} is {@code true} then the sample is additionally required to be a keyframe.
+   * Finds the sample in the specified range that's before or at the specified time. If {@code
+   * keyframe} is {@code true} then the sample is additionally required to be a keyframe.
    *
    * @param relativeStartIndex The relative index from which to start searching.
    * @param length The length of the range being searched.
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index fa4a26a..1230b45 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.source;
 
-import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.drm.DrmSession;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.source.SampleMetadataQueue.SampleExtrasHolder;
@@ -29,9 +30,6 @@ import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.EOFException;
 import java.io.IOException;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
 
 /** A queue of media samples. */
@@ -51,27 +49,6 @@ public class SampleQueue implements TrackOutput {
 
   }
 
-  /** Values returned by {@link #peekNext()}. */
-  @Documented
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef(
-      value = {
-        PEEK_RESULT_NOTHING,
-        PEEK_RESULT_FORMAT,
-        PEEK_RESULT_BUFFER_CLEAR,
-        PEEK_RESULT_BUFFER_ENCRYPTED
-      })
-  @interface PeekResult {}
-
-  /** Nothing is available for reading. */
-  public static final int PEEK_RESULT_NOTHING = 0;
-  /** A format change is available for reading */
-  public static final int PEEK_RESULT_FORMAT = 1;
-  /** A clear buffer is available for reading. */
-  public static final int PEEK_RESULT_BUFFER_CLEAR = 2;
-  /** An encrypted buffer is available for reading. */
-  public static final int PEEK_RESULT_BUFFER_ENCRYPTED = 3;
-
   public static final int ADVANCE_FAILED = -1;
 
   private static final int INITIAL_SCRATCH_SIZE = 32;
@@ -87,9 +64,6 @@ public class SampleQueue implements TrackOutput {
   private AllocationNode readAllocationNode;
   private AllocationNode writeAllocationNode;
 
-  // Accessed only by the consuming thread.
-  private Format downstreamFormat;
-
   // Accessed only by the loading thread (or the consuming thread when there is no loading thread).
   private boolean pendingFormatAdjustment;
   private Format lastUnadjustedFormat;
@@ -99,12 +73,16 @@ public class SampleQueue implements TrackOutput {
   private UpstreamFormatChangedListener upstreamFormatChangeListener;
 
   /**
+   * Creates a sample queue.
+   *
    * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
+   * @param drmSessionManager The {@link DrmSessionManager} to obtain {@link DrmSession DrmSessions}
+   *     from. The created instance does not take ownership of this {@link DrmSessionManager}.
    */
-  public SampleQueue(Allocator allocator) {
+  public SampleQueue(Allocator allocator, DrmSessionManager<?> drmSessionManager) {
     this.allocator = allocator;
     allocationLength = allocator.getIndividualAllocationLength();
-    metadataQueue = new SampleMetadataQueue();
+    metadataQueue = new SampleMetadataQueue(drmSessionManager);
     extrasHolder = new SampleExtrasHolder();
     scratch = new ParsableByteArray(INITIAL_SCRATCH_SIZE);
     firstAllocationNode = new AllocationNode(0, allocationLength);
@@ -198,10 +176,12 @@ public class SampleQueue implements TrackOutput {
   // Called by the consuming thread.
 
   /**
-   * Returns whether a sample is available to be read.
+   * Throws an error that's preventing data from being read. Does nothing if no such error exists.
+   *
+   * @throws IOException The underlying error.
    */
-  public boolean hasNextSample() {
-    return metadataQueue.hasNextSample();
+  public void maybeThrowError() throws IOException {
+    metadataQueue.maybeThrowError();
   }
 
   /**
@@ -292,6 +272,18 @@ public class SampleQueue implements TrackOutput {
     discardDownstreamTo(metadataQueue.discardToRead());
   }
 
+  /** Calls {@link #discardToEnd()} and releases any owned {@link DrmSession} references. */
+  public void preRelease() {
+    discardToEnd();
+    metadataQueue.releaseDrmSessionReferences();
+  }
+
+  /** Calls {@link #reset()} and releases any owned {@link DrmSession} references. */
+  public void release() {
+    reset();
+    metadataQueue.releaseDrmSessionReferences();
+  }
+
   /**
    * Discards to the end of the queue. The read position is also advanced.
    */
@@ -338,18 +330,17 @@ public class SampleQueue implements TrackOutput {
   }
 
   /**
-   * Returns a {@link PeekResult} depending on what a following call to {@link #read
-   * read(formatHolder, decoderInputBuffer, formatRequired= false, allowOnlyClearBuffers= false,
-   * loadingFinished= false, decodeOnlyUntilUs= 0)} would result in.
-   */
-  @PeekResult
-  public int peekNext() {
-    return metadataQueue.peekNext(downstreamFormat);
-  }
-
-  /**
    * Attempts to read from the queue.
    *
+   * <p>{@link Format Formats} read from this method may be associated to a {@link DrmSession}
+   * through {@link FormatHolder#drmSession}, which is populated in two scenarios:
+   *
+   * <ul>
+   *   <li>The {@link Format} has a non-null {@link Format#drmInitData}.
+   *   <li>The {@link DrmSessionManager} provides placeholder sessions for this queue's track type.
+   *       See {@link DrmSessionManager#acquirePlaceholderSession(Looper, int)}.
+   * </ul>
+   *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the {@link
@@ -359,49 +350,45 @@ public class SampleQueue implements TrackOutput {
    * @param formatRequired Whether the caller requires that the format of the stream be read even if
    *     it's not changing. A sample will never be read if set to true, however it is still possible
    *     for the end of stream or nothing to be read.
-   * @param allowOnlyClearBuffers If set to true, this method will not return encrypted buffers,
-   *     returning {@link C#RESULT_NOTHING_READ} (without advancing the read position) instead.
    * @param loadingFinished True if an empty queue should be considered the end of the stream.
    * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
    *     be set if the buffer's timestamp is less than this value.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
+  @SuppressWarnings("ReferenceEquality")
   public int read(
       FormatHolder formatHolder,
       DecoderInputBuffer buffer,
       boolean formatRequired,
-      boolean allowOnlyClearBuffers,
       boolean loadingFinished,
       long decodeOnlyUntilUs) {
     int result =
-        metadataQueue.read(
-            formatHolder,
-            buffer,
-            formatRequired,
-            allowOnlyClearBuffers,
-            loadingFinished,
-            downstreamFormat,
-            extrasHolder);
-    switch (result) {
-      case C.RESULT_FORMAT_READ:
-        downstreamFormat = formatHolder.format;
-        return C.RESULT_FORMAT_READ;
-      case C.RESULT_BUFFER_READ:
-        if (!buffer.isEndOfStream()) {
-          if (buffer.timeUs < decodeOnlyUntilUs) {
-            buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
-          }
-          if (!buffer.isFlagsOnly()) {
-            readToBuffer(buffer, extrasHolder);
-          }
-        }
-        return C.RESULT_BUFFER_READ;
-      case C.RESULT_NOTHING_READ:
-        return C.RESULT_NOTHING_READ;
-      default:
-        throw new IllegalStateException();
+        metadataQueue.read(formatHolder, buffer, formatRequired, loadingFinished, extrasHolder);
+    if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
+      if (buffer.timeUs < decodeOnlyUntilUs) {
+        buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
+      }
+      if (!buffer.isFlagsOnly()) {
+        readToBuffer(buffer, extrasHolder);
+      }
     }
+    return result;
+  }
+
+  /**
+   * Returns whether there is data available for reading.
+   *
+   * <p>Note: If the stream has ended then a buffer with the end of stream flag can always be read
+   * from {@link #read}. Hence an ended stream is always ready.
+   *
+   * @param loadingFinished Whether no more samples will be written to the sample queue. When true,
+   *     this method returns true if the sample queue is empty, because an empty sample queue means
+   *     the end of stream has been reached. When false, this method returns false if the sample
+   *     queue is empty.
+   */
+  public boolean isReady(boolean loadingFinished) {
+    return metadataQueue.isReady(loadingFinished);
   }
 
   /**
@@ -748,9 +735,7 @@ public class SampleQueue implements TrackOutput {
     return format;
   }
 
-  /**
-   * A node in a linked list of {@link Allocation}s held by the output.
-   */
+  /** A node in a linked list of {@link Allocation}s held by the output. */
   private static final class AllocationNode {
 
     /**
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 182f0f1..189c13e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -60,6 +60,9 @@ public interface SequenceableLoader {
    */
   boolean continueLoading(long positionUs);
 
+  /** Returns whether the loader is currently loading. */
+  boolean isLoading();
+
   /**
    * Re-evaluates the buffer given the playback position.
    *
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
index e23a7ea..abaf336 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
@@ -68,7 +68,8 @@ public final class SilenceMediaSource extends BaseMediaSource {
   @Override
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     refreshSourceInfo(
-        new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false));
+        new SinglePeriodTimeline(
+            durationUs, /* isSeekable= */ true, /* isDynamic= */ false, /* isLive= */ false));
   }
 
   @Override
@@ -143,14 +144,6 @@ public final class SilenceMediaSource extends BaseMediaSource {
     }
 
     @Override
-    public void pause() {
-    }
-
-    @Override
-    public void resume() {
-    }
-
-    @Override
     public long seekToUs(long positionUs) {
       positionUs = constrainSeekPosition(positionUs);
       for (int i = 0; i < sampleStreams.size(); i++) {
@@ -180,6 +173,11 @@ public final class SilenceMediaSource extends BaseMediaSource {
     }
 
     @Override
+    public boolean isLoading() {
+      return false;
+    }
+
+    @Override
     public void reevaluateBuffer(long positionUs) {}
 
     private long constrainSeekPosition(long positionUs) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 49d6793..45f64ca 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -35,6 +35,7 @@ public final class SinglePeriodTimeline extends Timeline {
   private final long windowDefaultStartPositionUs;
   private final boolean isSeekable;
   private final boolean isDynamic;
+  private final boolean isLive;
   @Nullable private final Object tag;
   @Nullable private final Object manifest;
 
@@ -44,9 +45,11 @@ public final class SinglePeriodTimeline extends Timeline {
    * @param durationUs The duration of the period, in microseconds.
    * @param isSeekable Whether seeking is supported within the period.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    */
-  public SinglePeriodTimeline(long durationUs, boolean isSeekable, boolean isDynamic) {
-    this(durationUs, isSeekable, isDynamic, /* manifest= */ null, /* tag= */ null);
+  public SinglePeriodTimeline(
+      long durationUs, boolean isSeekable, boolean isDynamic, boolean isLive) {
+    this(durationUs, isSeekable, isDynamic, isLive, /* manifest= */ null, /* tag= */ null);
   }
 
   /**
@@ -55,6 +58,7 @@ public final class SinglePeriodTimeline extends Timeline {
    * @param durationUs The duration of the period, in microseconds.
    * @param isSeekable Whether seeking is supported within the period.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    * @param manifest The manifest. May be {@code null}.
    * @param tag A tag used for {@link Window#tag}.
    */
@@ -62,6 +66,7 @@ public final class SinglePeriodTimeline extends Timeline {
       long durationUs,
       boolean isSeekable,
       boolean isDynamic,
+      boolean isLive,
       @Nullable Object manifest,
       @Nullable Object tag) {
     this(
@@ -71,6 +76,7 @@ public final class SinglePeriodTimeline extends Timeline {
         /* windowDefaultStartPositionUs= */ 0,
         isSeekable,
         isDynamic,
+        isLive,
         manifest,
         tag);
   }
@@ -87,6 +93,7 @@ public final class SinglePeriodTimeline extends Timeline {
    *     which to begin playback, in microseconds.
    * @param isSeekable Whether seeking is supported within the window.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    * @param manifest The manifest. May be (@code null}.
    * @param tag A tag used for {@link Timeline.Window#tag}.
    */
@@ -97,6 +104,7 @@ public final class SinglePeriodTimeline extends Timeline {
       long windowDefaultStartPositionUs,
       boolean isSeekable,
       boolean isDynamic,
+      boolean isLive,
       @Nullable Object manifest,
       @Nullable Object tag) {
     this(
@@ -108,6 +116,7 @@ public final class SinglePeriodTimeline extends Timeline {
         windowDefaultStartPositionUs,
         isSeekable,
         isDynamic,
+        isLive,
         manifest,
         tag);
   }
@@ -127,6 +136,7 @@ public final class SinglePeriodTimeline extends Timeline {
    *     which to begin playback, in microseconds.
    * @param isSeekable Whether seeking is supported within the window.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    * @param manifest The manifest. May be {@code null}.
    * @param tag A tag used for {@link Timeline.Window#tag}.
    */
@@ -139,6 +149,7 @@ public final class SinglePeriodTimeline extends Timeline {
       long windowDefaultStartPositionUs,
       boolean isSeekable,
       boolean isDynamic,
+      boolean isLive,
       @Nullable Object manifest,
       @Nullable Object tag) {
     this.presentationStartTimeMs = presentationStartTimeMs;
@@ -149,6 +160,7 @@ public final class SinglePeriodTimeline extends Timeline {
     this.windowDefaultStartPositionUs = windowDefaultStartPositionUs;
     this.isSeekable = isSeekable;
     this.isDynamic = isDynamic;
+    this.isLive = isLive;
     this.manifest = manifest;
     this.tag = tag;
   }
@@ -182,6 +194,7 @@ public final class SinglePeriodTimeline extends Timeline {
         windowStartTimeMs,
         isSeekable,
         isDynamic,
+        isLive,
         windowDefaultStartPositionUs,
         windowDurationUs,
         0,
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 1e1ccf9..ca50c34 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -173,6 +173,11 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   }
 
   @Override
+  public boolean isLoading() {
+    return loader.isLoading();
+  }
+
+  @Override
   public long readDiscontinuity() {
     if (!notifiedReadingStarted) {
       eventDispatcher.readingStarted();
@@ -192,16 +197,6 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   }
 
   @Override
-  public void pause() {
-    // Do nothing.
-  }
-
-  @Override
-  public void resume() {
-    // Do nothing.
-  }
-
-  @Override
   public long seekToUs(long positionUs) {
     for (int i = 0; i < sampleStreams.size(); i++) {
       sampleStreams.get(i).reset();
@@ -388,6 +383,8 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
     @Nullable private byte[] sampleData;
 
+    // the constructor does not initialize fields: sampleData
+    @SuppressWarnings("nullness:initialization.fields.uninitialized")
     public SourceLoadable(DataSpec dataSpec, DataSource dataSource) {
       this.dataSpec = dataSpec;
       this.dataSource = new StatsDataSource(dataSource);
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 04ee3a1..db14149 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -291,7 +291,12 @@ public final class SingleSampleMediaSource extends BaseMediaSource {
     dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP);
     timeline =
         new SinglePeriodTimeline(
-            durationUs, /* isSeekable= */ true, /* isDynamic= */ false, /* manifest= */ null, tag);
+            durationUs,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false,
+            /* manifest= */ null,
+            tag);
   }
 
   // MediaSource implementation.
@@ -342,7 +347,7 @@ public final class SingleSampleMediaSource extends BaseMediaSource {
    */
   @Deprecated
   @SuppressWarnings("deprecation")
-  private static final class EventListenerWrapper extends DefaultMediaSourceEventListener {
+  private static final class EventListenerWrapper implements MediaSourceEventListener {
 
     private final EventListener eventListener;
     private final int eventSourceId;
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 6817f29..3216090 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -23,7 +23,6 @@ import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmSession;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.source.DecryptableSampleQueueReader;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.SampleStream;
@@ -74,7 +73,6 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
   private final ArrayList<BaseMediaChunk> mediaChunks;
   private final List<BaseMediaChunk> readOnlyMediaChunks;
   private final SampleQueue primarySampleQueue;
-  private final DecryptableSampleQueueReader primarySampleQueueReader;
   private final SampleQueue[] embeddedSampleQueues;
   private final BaseMediaChunkOutput mediaChunkOutput;
 
@@ -132,14 +130,13 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
     int[] trackTypes = new int[1 + embeddedTrackCount];
     SampleQueue[] sampleQueues = new SampleQueue[1 + embeddedTrackCount];
 
-    primarySampleQueue = new SampleQueue(allocator);
-    primarySampleQueueReader =
-        new DecryptableSampleQueueReader(primarySampleQueue, drmSessionManager);
+    primarySampleQueue = new SampleQueue(allocator, drmSessionManager);
     trackTypes[0] = primaryTrackType;
     sampleQueues[0] = primarySampleQueue;
 
     for (int i = 0; i < embeddedTrackCount; i++) {
-      SampleQueue sampleQueue = new SampleQueue(allocator);
+      SampleQueue sampleQueue =
+          new SampleQueue(allocator, DrmSessionManager.getDummyDrmSessionManager());
       embeddedSampleQueues[i] = sampleQueue;
       sampleQueues[i + 1] = sampleQueue;
       trackTypes[i + 1] = embeddedTrackTypes[i];
@@ -337,19 +334,18 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
   public void release(@Nullable ReleaseCallback<T> callback) {
     this.releaseCallback = callback;
     // Discard as much as we can synchronously.
-    primarySampleQueue.discardToEnd();
-    primarySampleQueueReader.release();
+    primarySampleQueue.preRelease();
     for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
-      embeddedSampleQueue.discardToEnd();
+      embeddedSampleQueue.preRelease();
     }
     loader.release(this);
   }
 
   @Override
   public void onLoaderReleased() {
-    primarySampleQueue.reset();
+    primarySampleQueue.release();
     for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
-      embeddedSampleQueue.reset();
+      embeddedSampleQueue.release();
     }
     if (releaseCallback != null) {
       releaseCallback.onSampleStreamReleased(this);
@@ -360,13 +356,13 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
 
   @Override
   public boolean isReady() {
-    return !isPendingReset() && primarySampleQueueReader.isReady(loadingFinished);
+    return !isPendingReset() && primarySampleQueue.isReady(loadingFinished);
   }
 
   @Override
   public void maybeThrowError() throws IOException {
     loader.maybeThrowError();
-    primarySampleQueueReader.maybeThrowError();
+    primarySampleQueue.maybeThrowError();
     if (!loader.isLoading()) {
       chunkSource.maybeThrowError();
     }
@@ -380,7 +376,7 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
     }
     maybeNotifyPrimaryTrackFormatChanged();
 
-    return primarySampleQueueReader.read(
+    return primarySampleQueue.read(
         formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
   }
 
@@ -578,6 +574,11 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
   }
 
   @Override
+  public boolean isLoading() {
+    return loader.isLoading();
+  }
+
+  @Override
   public long getNextLoadPositionUs() {
     if (isPendingReset()) {
       return pendingResetPositionUs;
@@ -739,7 +740,7 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
 
     @Override
     public boolean isReady() {
-      return loadingFinished || (!isPendingReset() && sampleQueue.hasNextSample());
+      return !isPendingReset() && sampleQueue.isReady(loadingFinished);
     }
 
     @Override
@@ -776,7 +777,6 @@ public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, S
           formatHolder,
           buffer,
           formatRequired,
-          /* allowOnlyClearBuffers= */ false,
           loadingFinished,
           decodeOnlyUntilPositionUs);
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java b/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
index 7ea2521..f3bea8a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
+++ b/core/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -44,8 +45,14 @@ public abstract class DataChunk extends Chunk {
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param data An optional recycled array that can be used as a holder for the data.
    */
-  public DataChunk(DataSource dataSource, DataSpec dataSpec, int type, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, byte[] data) {
+  public DataChunk(
+      DataSource dataSource,
+      DataSpec dataSpec,
+      int type,
+      Format trackFormat,
+      int trackSelectionReason,
+      @Nullable Object trackSelectionData,
+      byte[] data) {
     super(dataSource, dataSpec, type, trackFormat, trackSelectionReason, trackSelectionData,
         C.TIME_UNSET, C.TIME_UNSET);
     this.data = data;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/Cue.java b/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 3dea941..946af76 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -32,8 +32,9 @@ public class Cue {
   /** The empty cue. */
   public static final Cue EMPTY = new Cue("");
 
-  /** An unset position or width. */
-  public static final float DIMEN_UNSET = Float.MIN_VALUE;
+  /** An unset position, width or size. */
+  // Note: We deliberately don't use Float.MIN_VALUE because it's positive & very close to zero.
+  public static final float DIMEN_UNSET = -Float.MAX_VALUE;
 
   /**
    * The type of anchor, which may be unset. One of {@link #TYPE_UNSET}, {@link #ANCHOR_TYPE_START},
@@ -332,7 +333,7 @@ public class Cue {
    */
   public Cue(
       CharSequence text,
-      Alignment textAlignment,
+      @Nullable Alignment textAlignment,
       float line,
       @LineType int lineType,
       @AnchorType int lineAnchor,
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java b/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
index bd561af..8a1aea1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
@@ -18,6 +18,7 @@ package com.google.android.exoplayer2.text;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.util.Assertions;
 import java.nio.ByteBuffer;
 
 /**
@@ -29,9 +30,8 @@ public abstract class SimpleSubtitleDecoder extends
 
   private final String name;
 
-  /**
-   * @param name The name of the decoder.
-   */
+  /** @param name The name of the decoder. */
+  @SuppressWarnings("initialization:method.invocation.invalid")
   protected SimpleSubtitleDecoder(String name) {
     super(new SubtitleInputBuffer[2], new SubtitleOutputBuffer[2]);
     this.name = name;
@@ -74,7 +74,7 @@ public abstract class SimpleSubtitleDecoder extends
   protected final SubtitleDecoderException decode(
       SubtitleInputBuffer inputBuffer, SubtitleOutputBuffer outputBuffer, boolean reset) {
     try {
-      ByteBuffer inputData = inputBuffer.data;
+      ByteBuffer inputData = Assertions.checkNotNull(inputBuffer.data);
       Subtitle subtitle = decode(inputData.array(), inputData.limit(), reset);
       outputBuffer.setContent(inputBuffer.timeUs, subtitle, inputBuffer.subsampleOffsetUs);
       // Clear BUFFER_FLAG_DECODE_ONLY (see [Internal: b/27893809]).
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index a64a183..927ee8b 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.cea.Cea608Decoder;
 import com.google.android.exoplayer2.text.cea.Cea708Decoder;
@@ -74,7 +75,7 @@ public interface SubtitleDecoderFactory {
 
         @Override
         public boolean supportsFormat(Format format) {
-          String mimeType = format.sampleMimeType;
+          @Nullable String mimeType = format.sampleMimeType;
           return MimeTypes.TEXT_VTT.equals(mimeType)
               || MimeTypes.TEXT_SSA.equals(mimeType)
               || MimeTypes.APPLICATION_TTML.equals(mimeType)
@@ -90,32 +91,36 @@ public interface SubtitleDecoderFactory {
 
         @Override
         public SubtitleDecoder createDecoder(Format format) {
-          switch (format.sampleMimeType) {
-            case MimeTypes.TEXT_VTT:
-              return new WebvttDecoder();
-            case MimeTypes.TEXT_SSA:
-              return new SsaDecoder(format.initializationData);
-            case MimeTypes.APPLICATION_MP4VTT:
-              return new Mp4WebvttDecoder();
-            case MimeTypes.APPLICATION_TTML:
-              return new TtmlDecoder();
-            case MimeTypes.APPLICATION_SUBRIP:
-              return new SubripDecoder();
-            case MimeTypes.APPLICATION_TX3G:
-              return new Tx3gDecoder(format.initializationData);
-            case MimeTypes.APPLICATION_CEA608:
-            case MimeTypes.APPLICATION_MP4CEA608:
-              return new Cea608Decoder(format.sampleMimeType, format.accessibilityChannel);
-            case MimeTypes.APPLICATION_CEA708:
-              return new Cea708Decoder(format.accessibilityChannel, format.initializationData);
-            case MimeTypes.APPLICATION_DVBSUBS:
-              return new DvbDecoder(format.initializationData);
-            case MimeTypes.APPLICATION_PGS:
-              return new PgsDecoder();
-            default:
-              throw new IllegalArgumentException(
-                  "Attempted to create decoder for unsupported format");
+          @Nullable String mimeType = format.sampleMimeType;
+          if (mimeType != null) {
+            switch (mimeType) {
+              case MimeTypes.TEXT_VTT:
+                return new WebvttDecoder();
+              case MimeTypes.TEXT_SSA:
+                return new SsaDecoder(format.initializationData);
+              case MimeTypes.APPLICATION_MP4VTT:
+                return new Mp4WebvttDecoder();
+              case MimeTypes.APPLICATION_TTML:
+                return new TtmlDecoder();
+              case MimeTypes.APPLICATION_SUBRIP:
+                return new SubripDecoder();
+              case MimeTypes.APPLICATION_TX3G:
+                return new Tx3gDecoder(format.initializationData);
+              case MimeTypes.APPLICATION_CEA608:
+              case MimeTypes.APPLICATION_MP4CEA608:
+                return new Cea608Decoder(mimeType, format.accessibilityChannel);
+              case MimeTypes.APPLICATION_CEA708:
+                return new Cea708Decoder(format.accessibilityChannel, format.initializationData);
+              case MimeTypes.APPLICATION_DVBSUBS:
+                return new DvbDecoder(format.initializationData);
+              case MimeTypes.APPLICATION_PGS:
+                return new PgsDecoder();
+              default:
+                break;
+            }
           }
+          throw new IllegalArgumentException(
+              "Attempted to create decoder for unsupported MIME type: " + mimeType);
         }
       };
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index 1622d68..058b1c4 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -26,6 +26,7 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -79,11 +80,11 @@ public final class TextRenderer extends BaseRenderer implements Callback {
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   @ReplacementState private int decoderReplacementState;
-  private Format streamFormat;
-  private SubtitleDecoder decoder;
-  private SubtitleInputBuffer nextInputBuffer;
-  private SubtitleOutputBuffer subtitle;
-  private SubtitleOutputBuffer nextSubtitle;
+  @Nullable private Format streamFormat;
+  @Nullable private SubtitleDecoder decoder;
+  @Nullable private SubtitleInputBuffer nextInputBuffer;
+  @Nullable private SubtitleOutputBuffer subtitle;
+  @Nullable private SubtitleOutputBuffer nextSubtitle;
   private int nextSubtitleEventIndex;
 
   /**
@@ -118,18 +119,20 @@ public final class TextRenderer extends BaseRenderer implements Callback {
   }
 
   @Override
+  @Capabilities
   public int supportsFormat(Format format) {
     if (decoderFactory.supportsFormat(format)) {
-      return supportsFormatDrm(null, format.drmInitData) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_DRM;
+      return RendererCapabilities.create(
+          supportsFormatDrm(null, format.drmInitData) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_DRM);
     } else if (MimeTypes.isText(format.sampleMimeType)) {
-      return FORMAT_UNSUPPORTED_SUBTYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_SUBTYPE);
     } else {
-      return FORMAT_UNSUPPORTED_TYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
     }
   }
 
   @Override
-  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
+  protected void onStreamChanged(Format[] formats, long offsetUs) {
     streamFormat = formats[0];
     if (decoder != null) {
       decoderReplacementState = REPLACEMENT_STATE_SIGNAL_END_OF_STREAM;
@@ -162,7 +165,7 @@ public final class TextRenderer extends BaseRenderer implements Callback {
       try {
         nextSubtitle = decoder.dequeueOutputBuffer();
       } catch (SubtitleDecoderException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
+        throw createRendererException(e, streamFormat);
       }
     }
 
@@ -244,7 +247,7 @@ public final class TextRenderer extends BaseRenderer implements Callback {
         }
       }
     } catch (SubtitleDecoderException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, streamFormat);
     }
   }
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java b/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
index fc1f0e2..e04094a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
@@ -25,11 +25,6 @@ import com.google.android.exoplayer2.text.Cue;
 /* package */ final class Cea708Cue extends Cue implements Comparable<Cea708Cue> {
 
   /**
-   * An unset priority.
-   */
-  public static final int PRIORITY_UNSET = -1;
-
-  /**
    * The priority of the cue box.
    */
   public final int priority;
@@ -64,5 +59,4 @@ import com.google.android.exoplayer2.text.Cue;
     }
     return 0;
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
index b3be88b..4391bc0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -25,6 +25,7 @@ import android.text.style.BackgroundColorSpan;
 import android.text.style.ForegroundColorSpan;
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Cue;
@@ -152,7 +153,8 @@ public final class Cea708Decoder extends CeaDecoder {
   private DtvCcPacket currentDtvCcPacket;
   private int currentWindow;
 
-  public Cea708Decoder(int accessibilityChannel, List<byte[]> initializationData) {
+  // TODO: Retrieve isWideAspectRatio from initializationData and use it.
+  public Cea708Decoder(int accessibilityChannel, @Nullable List<byte[]> initializationData) {
     ccData = new ParsableByteArray();
     serviceBlockPacket = new ParsableBitArray();
     selectedServiceNumber = accessibilityChannel == Format.NO_VALUE ? 1 : accessibilityChannel;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/cea/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/cea/package-info.java
new file mode 100644
index 0000000..cbdf178
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/cea/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.cea;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java b/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
index 3f2fef4..8382d9d 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbParser.java
@@ -22,6 +22,7 @@ import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
 import android.util.SparseArray;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableBitArray;
@@ -29,6 +30,7 @@ import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
  * Parses {@link Cue}s from a DVB subtitle bitstream.
@@ -85,7 +87,7 @@ import java.util.List;
   private final ClutDefinition defaultClutDefinition;
   private final SubtitleService subtitleService;
 
-  private Bitmap bitmap;
+  @MonotonicNonNull private Bitmap bitmap;
 
   /**
    * Construct an instance for the given subtitle and ancillary page ids.
@@ -131,7 +133,8 @@ import java.util.List;
       parseSubtitlingSegment(dataBitArray, subtitleService);
     }
 
-    if (subtitleService.pageComposition == null) {
+    @Nullable PageComposition pageComposition = subtitleService.pageComposition;
+    if (pageComposition == null) {
       return Collections.emptyList();
     }
 
@@ -147,7 +150,7 @@ import java.util.List;
 
     // Build the cues.
     List<Cue> cues = new ArrayList<>();
-    SparseArray<PageRegion> pageRegions = subtitleService.pageComposition.regions;
+    SparseArray<PageRegion> pageRegions = pageComposition.regions;
     for (int i = 0; i < pageRegions.size(); i++) {
       // Save clean clipping state.
       canvas.save();
@@ -182,7 +185,7 @@ import java.util.List;
           objectData = subtitleService.ancillaryObjects.get(objectId);
         }
         if (objectData != null) {
-          Paint paint = objectData.nonModifyingColorFlag ? null : defaultPaint;
+          @Nullable Paint paint = objectData.nonModifyingColorFlag ? null : defaultPaint;
           paintPixelDataSubBlocks(objectData, clutDefinition, regionComposition.depth,
               baseHorizontalAddress + regionObject.horizontalPosition,
               baseVerticalAddress + regionObject.verticalPosition, paint, canvas);
@@ -248,7 +251,7 @@ import java.util.List;
         break;
       case SEGMENT_TYPE_PAGE_COMPOSITION:
         if (pageId == service.subtitlePageId) {
-          PageComposition current = service.pageComposition;
+          @Nullable PageComposition current = service.pageComposition;
           PageComposition pageComposition = parsePageComposition(data, dataFieldLength);
           if (pageComposition.state != PAGE_STATE_NORMAL) {
             service.pageComposition = pageComposition;
@@ -261,11 +264,15 @@ import java.util.List;
         }
         break;
       case SEGMENT_TYPE_REGION_COMPOSITION:
-        PageComposition pageComposition = service.pageComposition;
+        @Nullable PageComposition pageComposition = service.pageComposition;
         if (pageId == service.subtitlePageId && pageComposition != null) {
           RegionComposition regionComposition = parseRegionComposition(data, dataFieldLength);
           if (pageComposition.state == PAGE_STATE_NORMAL) {
-            regionComposition.mergeFrom(service.regions.get(regionComposition.id));
+            @Nullable
+            RegionComposition existingRegionComposition = service.regions.get(regionComposition.id);
+            if (existingRegionComposition != null) {
+              regionComposition.mergeFrom(existingRegionComposition);
+            }
           }
           service.regions.put(regionComposition.id, regionComposition);
         }
@@ -470,8 +477,8 @@ import java.util.List;
     boolean nonModifyingColorFlag = data.readBit();
     data.skipBits(1); // Skip reserved.
 
-    byte[] topFieldData = null;
-    byte[] bottomFieldData = null;
+    @Nullable byte[] topFieldData = null;
+    @Nullable byte[] bottomFieldData = null;
 
     if (objectCodingMethod == OBJECT_CODING_STRING) {
       int numberOfCodes = data.readBits(8);
@@ -577,11 +584,15 @@ import java.util.List;
 
   // Static drawing.
 
-  /**
-   * Draws a pixel data sub-block, as defined by ETSI EN 300 743 7.2.5.1, into a canvas.
-   */
-  private static void paintPixelDataSubBlocks(ObjectData objectData, ClutDefinition clutDefinition,
-      int regionDepth, int horizontalAddress, int verticalAddress, Paint paint, Canvas canvas) {
+  /** Draws a pixel data sub-block, as defined by ETSI EN 300 743 7.2.5.1, into a canvas. */
+  private static void paintPixelDataSubBlocks(
+      ObjectData objectData,
+      ClutDefinition clutDefinition,
+      int regionDepth,
+      int horizontalAddress,
+      int verticalAddress,
+      @Nullable Paint paint,
+      Canvas canvas) {
     int[] clutEntries;
     if (regionDepth == REGION_DEPTH_8_BIT) {
       clutEntries = clutDefinition.clutEntries8Bit;
@@ -596,23 +607,27 @@ import java.util.List;
         verticalAddress + 1, paint, canvas);
   }
 
-  /**
-   * Draws a pixel data sub-block, as defined by ETSI EN 300 743 7.2.5.1, into a canvas.
-   */
-  private static void paintPixelDataSubBlock(byte[] pixelData, int[] clutEntries, int regionDepth,
-      int horizontalAddress, int verticalAddress, Paint paint, Canvas canvas) {
+  /** Draws a pixel data sub-block, as defined by ETSI EN 300 743 7.2.5.1, into a canvas. */
+  private static void paintPixelDataSubBlock(
+      byte[] pixelData,
+      int[] clutEntries,
+      int regionDepth,
+      int horizontalAddress,
+      int verticalAddress,
+      @Nullable Paint paint,
+      Canvas canvas) {
     ParsableBitArray data = new ParsableBitArray(pixelData);
     int column = horizontalAddress;
     int line = verticalAddress;
-    byte[] clutMapTable2To4 = null;
-    byte[] clutMapTable2To8 = null;
-    byte[] clutMapTable4To8 = null;
+    @Nullable byte[] clutMapTable2To4 = null;
+    @Nullable byte[] clutMapTable2To8 = null;
+    @Nullable byte[] clutMapTable4To8 = null;
 
     while (data.bitsLeft() != 0) {
       int dataType = data.readBits(8);
       switch (dataType) {
         case DATA_TYPE_2BP_CODE_STRING:
-          byte[] clutMapTable2ToX;
+          @Nullable byte[] clutMapTable2ToX;
           if (regionDepth == REGION_DEPTH_8_BIT) {
             clutMapTable2ToX = clutMapTable2To8 == null ? defaultMap2To8 : clutMapTable2To8;
           } else if (regionDepth == REGION_DEPTH_4_BIT) {
@@ -625,7 +640,7 @@ import java.util.List;
           data.byteAlign();
           break;
         case DATA_TYPE_4BP_CODE_STRING:
-          byte[] clutMapTable4ToX;
+          @Nullable byte[] clutMapTable4ToX;
           if (regionDepth == REGION_DEPTH_8_BIT) {
             clutMapTable4ToX = clutMapTable4To8 == null ? defaultMap4To8 : clutMapTable4To8;
           } else {
@@ -636,7 +651,9 @@ import java.util.List;
           data.byteAlign();
           break;
         case DATA_TYPE_8BP_CODE_STRING:
-          column = paint8BitPixelCodeString(data, clutEntries, null, column, line, paint, canvas);
+          column =
+              paint8BitPixelCodeString(
+                  data, clutEntries, /* clutMapTable= */ null, column, line, paint, canvas);
           break;
         case DATA_TYPE_24_TABLE_DATA:
           clutMapTable2To4 = buildClutMapTable(4, 4, data);
@@ -645,7 +662,7 @@ import java.util.List;
           clutMapTable2To8 = buildClutMapTable(4, 8, data);
           break;
         case DATA_TYPE_48_TABLE_DATA:
-          clutMapTable2To8 = buildClutMapTable(16, 8, data);
+          clutMapTable4To8 = buildClutMapTable(16, 8, data);
           break;
         case DATA_TYPE_END_LINE:
           column = horizontalAddress;
@@ -658,11 +675,15 @@ import java.util.List;
     }
   }
 
-  /**
-   * Paint a 2-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
-   */
-  private static int paint2BitPixelCodeString(ParsableBitArray data, int[] clutEntries,
-      byte[] clutMapTable, int column, int line, Paint paint, Canvas canvas) {
+  /** Paint a 2-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas. */
+  private static int paint2BitPixelCodeString(
+      ParsableBitArray data,
+      int[] clutEntries,
+      @Nullable byte[] clutMapTable,
+      int column,
+      int line,
+      @Nullable Paint paint,
+      Canvas canvas) {
     boolean endOfPixelCodeString = false;
     do {
       int runLength = 0;
@@ -706,11 +727,15 @@ import java.util.List;
     return column;
   }
 
-  /**
-   * Paint a 4-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
-   */
-  private static int paint4BitPixelCodeString(ParsableBitArray data, int[] clutEntries,
-      byte[] clutMapTable, int column, int line, Paint paint, Canvas canvas) {
+  /** Paint a 4-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas. */
+  private static int paint4BitPixelCodeString(
+      ParsableBitArray data,
+      int[] clutEntries,
+      @Nullable byte[] clutMapTable,
+      int column,
+      int line,
+      @Nullable Paint paint,
+      Canvas canvas) {
     boolean endOfPixelCodeString = false;
     do {
       int runLength = 0;
@@ -760,11 +785,15 @@ import java.util.List;
     return column;
   }
 
-  /**
-   * Paint an 8-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
-   */
-  private static int paint8BitPixelCodeString(ParsableBitArray data, int[] clutEntries,
-      byte[] clutMapTable, int column, int line, Paint paint, Canvas canvas) {
+  /** Paint an 8-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas. */
+  private static int paint8BitPixelCodeString(
+      ParsableBitArray data,
+      int[] clutEntries,
+      @Nullable byte[] clutMapTable,
+      int column,
+      int line,
+      @Nullable Paint paint,
+      Canvas canvas) {
     boolean endOfPixelCodeString = false;
     do {
       int runLength = 0;
@@ -816,18 +845,23 @@ import java.util.List;
     public final int subtitlePageId;
     public final int ancillaryPageId;
 
-    public final SparseArray<RegionComposition> regions = new SparseArray<>();
-    public final SparseArray<ClutDefinition> cluts = new SparseArray<>();
-    public final SparseArray<ObjectData> objects = new SparseArray<>();
-    public final SparseArray<ClutDefinition> ancillaryCluts = new SparseArray<>();
-    public final SparseArray<ObjectData> ancillaryObjects = new SparseArray<>();
+    public final SparseArray<RegionComposition> regions;
+    public final SparseArray<ClutDefinition> cluts;
+    public final SparseArray<ObjectData> objects;
+    public final SparseArray<ClutDefinition> ancillaryCluts;
+    public final SparseArray<ObjectData> ancillaryObjects;
 
-    public DisplayDefinition displayDefinition;
-    public PageComposition pageComposition;
+    @Nullable public DisplayDefinition displayDefinition;
+    @Nullable public PageComposition pageComposition;
 
     public SubtitleService(int subtitlePageId, int ancillaryPageId) {
       this.subtitlePageId = subtitlePageId;
       this.ancillaryPageId = ancillaryPageId;
+      regions = new SparseArray<>();
+      cluts = new SparseArray<>();
+      objects = new SparseArray<>();
+      ancillaryCluts = new SparseArray<>();
+      ancillaryObjects = new SparseArray<>();
     }
 
     public void reset() {
@@ -944,9 +978,6 @@ import java.util.List;
     }
 
     public void mergeFrom(RegionComposition otherRegionComposition) {
-      if (otherRegionComposition == null) {
-        return;
-      }
       SparseArray<RegionObject> otherRegionObjects = otherRegionComposition.regionObjects;
       for (int i = 0; i < otherRegionObjects.size(); i++) {
         regionObjects.put(otherRegionObjects.keyAt(i), otherRegionObjects.valueAt(i));
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/dvb/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/dvb/package-info.java
new file mode 100644
index 0000000..e5ec87a
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/dvb/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.dvb;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/package-info.java
new file mode 100644
index 0000000..5c5b3bb
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/pgs/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/pgs/package-info.java
new file mode 100644
index 0000000..ff0819d
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/pgs/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.pgs;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
index 8da37e7..eef9d2e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
@@ -15,7 +15,9 @@
  */
 package com.google.android.exoplayer2.text.ssa;
 
-import android.text.TextUtils;
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
+import android.text.Layout;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
@@ -23,71 +25,90 @@ import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
-import com.google.android.exoplayer2.util.LongArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
-/**
- * A {@link SimpleSubtitleDecoder} for SSA/ASS.
- */
+/** A {@link SimpleSubtitleDecoder} for SSA/ASS. */
 public final class SsaDecoder extends SimpleSubtitleDecoder {
 
   private static final String TAG = "SsaDecoder";
 
-  private static final Pattern SSA_TIMECODE_PATTERN = Pattern.compile(
-      "(?:(\\d+):)?(\\d+):(\\d+)(?::|\\.)(\\d+)");
-  private static final String FORMAT_LINE_PREFIX = "Format: ";
-  private static final String DIALOGUE_LINE_PREFIX = "Dialogue: ";
+  private static final Pattern SSA_TIMECODE_PATTERN =
+      Pattern.compile("(?:(\\d+):)?(\\d+):(\\d+)[:.](\\d+)");
+
+  /* package */ static final String FORMAT_LINE_PREFIX = "Format:";
+  /* package */ static final String STYLE_LINE_PREFIX = "Style:";
+  private static final String DIALOGUE_LINE_PREFIX = "Dialogue:";
+
+  private static final float DEFAULT_MARGIN = 0.05f;
 
   private final boolean haveInitializationData;
+  @Nullable private final SsaDialogueFormat dialogueFormatFromInitializationData;
 
-  private int formatKeyCount;
-  private int formatStartIndex;
-  private int formatEndIndex;
-  private int formatTextIndex;
+  private @MonotonicNonNull Map<String, SsaStyle> styles;
+
+  /**
+   * The horizontal resolution used by the subtitle author - all cue positions are relative to this.
+   *
+   * <p>Parsed from the {@code PlayResX} value in the {@code [Script Info]} section.
+   */
+  private float screenWidth;
+  /**
+   * The vertical resolution used by the subtitle author - all cue positions are relative to this.
+   *
+   * <p>Parsed from the {@code PlayResY} value in the {@code [Script Info]} section.
+   */
+  private float screenHeight;
 
   public SsaDecoder() {
     this(/* initializationData= */ null);
   }
 
   /**
+   * Constructs an SsaDecoder with optional format and header info.
+   *
    * @param initializationData Optional initialization data for the decoder. If not null or empty,
    *     the initialization data must consist of two byte arrays. The first must contain an SSA
    *     format line. The second must contain an SSA header that will be assumed common to all
-   *     samples.
+   *     samples. The header is everything in an SSA file before the {@code [Events]} section (i.e.
+   *     {@code [Script Info]} and optional {@code [V4+ Styles]} section.
    */
   public SsaDecoder(@Nullable List<byte[]> initializationData) {
     super("SsaDecoder");
+    screenWidth = Cue.DIMEN_UNSET;
+    screenHeight = Cue.DIMEN_UNSET;
+
     if (initializationData != null && !initializationData.isEmpty()) {
       haveInitializationData = true;
       String formatLine = Util.fromUtf8Bytes(initializationData.get(0));
       Assertions.checkArgument(formatLine.startsWith(FORMAT_LINE_PREFIX));
-      parseFormatLine(formatLine);
+      dialogueFormatFromInitializationData =
+          Assertions.checkNotNull(SsaDialogueFormat.fromFormatLine(formatLine));
       parseHeader(new ParsableByteArray(initializationData.get(1)));
     } else {
       haveInitializationData = false;
+      dialogueFormatFromInitializationData = null;
     }
   }
 
   @Override
   protected Subtitle decode(byte[] bytes, int length, boolean reset) {
-    ArrayList<Cue> cues = new ArrayList<>();
-    LongArray cueTimesUs = new LongArray();
+    List<List<Cue>> cues = new ArrayList<>();
+    List<Long> cueTimesUs = new ArrayList<>();
 
     ParsableByteArray data = new ParsableByteArray(bytes, length);
     if (!haveInitializationData) {
       parseHeader(data);
     }
     parseEventBody(data, cues, cueTimesUs);
-
-    Cue[] cuesArray = new Cue[cues.size()];
-    cues.toArray(cuesArray);
-    long[] cueTimesUsArray = cueTimesUs.toArray();
-    return new SsaSubtitle(cuesArray, cueTimesUsArray);
+    return new SsaSubtitle(cues, cueTimesUs);
   }
 
   /**
@@ -96,115 +117,160 @@ public final class SsaDecoder extends SimpleSubtitleDecoder {
    * @param data A {@link ParsableByteArray} from which the header should be read.
    */
   private void parseHeader(ParsableByteArray data) {
-    String currentLine;
+    @Nullable String currentLine;
     while ((currentLine = data.readLine()) != null) {
-      // TODO: Parse useful data from the header.
-      if (currentLine.startsWith("[Events]")) {
-        // We've reached the event body.
+      if ("[Script Info]".equalsIgnoreCase(currentLine)) {
+        parseScriptInfo(data);
+      } else if ("[V4+ Styles]".equalsIgnoreCase(currentLine)) {
+        styles = parseStyles(data);
+      } else if ("[V4 Styles]".equalsIgnoreCase(currentLine)) {
+        Log.i(TAG, "[V4 Styles] are not supported");
+      } else if ("[Events]".equalsIgnoreCase(currentLine)) {
+        // We've reached the [Events] section, so the header is over.
         return;
       }
     }
   }
 
   /**
-   * Parses the event body of the subtitle.
+   * Parse the {@code [Script Info]} section.
    *
-   * @param data A {@link ParsableByteArray} from which the body should be read.
-   * @param cues A list to which parsed cues will be added.
-   * @param cueTimesUs An array to which parsed cue timestamps will be added.
+   * <p>When this returns, {@code data.position} will be set to the beginning of the first line that
+   * starts with {@code [} (i.e. the title of the next section).
+   *
+   * @param data A {@link ParsableByteArray} with {@link ParsableByteArray#getPosition() position}
+   *     set to the beginning of of the first line after {@code [Script Info]}.
    */
-  private void parseEventBody(ParsableByteArray data, List<Cue> cues, LongArray cueTimesUs) {
-    String currentLine;
-    while ((currentLine = data.readLine()) != null) {
-      if (!haveInitializationData && currentLine.startsWith(FORMAT_LINE_PREFIX)) {
-        parseFormatLine(currentLine);
-      } else if (currentLine.startsWith(DIALOGUE_LINE_PREFIX)) {
-        parseDialogueLine(currentLine, cues, cueTimesUs);
+  private void parseScriptInfo(ParsableByteArray data) {
+    @Nullable String currentLine;
+    while ((currentLine = data.readLine()) != null
+        && (data.bytesLeft() == 0 || data.peekUnsignedByte() != '[')) {
+      String[] infoNameAndValue = currentLine.split(":");
+      if (infoNameAndValue.length != 2) {
+        continue;
+      }
+      switch (Util.toLowerInvariant(infoNameAndValue[0].trim())) {
+        case "playresx":
+          try {
+            screenWidth = Float.parseFloat(infoNameAndValue[1].trim());
+          } catch (NumberFormatException e) {
+            // Ignore invalid PlayResX value.
+          }
+          break;
+        case "playresy":
+          try {
+            screenHeight = Float.parseFloat(infoNameAndValue[1].trim());
+          } catch (NumberFormatException e) {
+            // Ignore invalid PlayResY value.
+          }
+          break;
       }
     }
   }
 
   /**
-   * Parses a format line.
+   * Parse the {@code [V4+ Styles]} section.
+   *
+   * <p>When this returns, {@code data.position} will be set to the beginning of the first line that
+   * starts with {@code [} (i.e. the title of the next section).
    *
-   * @param formatLine The line to parse.
+   * @param data A {@link ParsableByteArray} with {@link ParsableByteArray#getPosition()} pointing
+   *     at the beginning of of the first line after {@code [V4+ Styles]}.
    */
-  private void parseFormatLine(String formatLine) {
-    String[] values = TextUtils.split(formatLine.substring(FORMAT_LINE_PREFIX.length()), ",");
-    formatKeyCount = values.length;
-    formatStartIndex = C.INDEX_UNSET;
-    formatEndIndex = C.INDEX_UNSET;
-    formatTextIndex = C.INDEX_UNSET;
-    for (int i = 0; i < formatKeyCount; i++) {
-      String key = Util.toLowerInvariant(values[i].trim());
-      switch (key) {
-        case "start":
-          formatStartIndex = i;
-          break;
-        case "end":
-          formatEndIndex = i;
-          break;
-        case "text":
-          formatTextIndex = i;
-          break;
-        default:
-          // Do nothing.
-          break;
+  private static Map<String, SsaStyle> parseStyles(ParsableByteArray data) {
+    Map<String, SsaStyle> styles = new LinkedHashMap<>();
+    @Nullable SsaStyle.Format formatInfo = null;
+    @Nullable String currentLine;
+    while ((currentLine = data.readLine()) != null
+        && (data.bytesLeft() == 0 || data.peekUnsignedByte() != '[')) {
+      if (currentLine.startsWith(FORMAT_LINE_PREFIX)) {
+        formatInfo = SsaStyle.Format.fromFormatLine(currentLine);
+      } else if (currentLine.startsWith(STYLE_LINE_PREFIX)) {
+        if (formatInfo == null) {
+          Log.w(TAG, "Skipping 'Style:' line before 'Format:' line: " + currentLine);
+          continue;
+        }
+        @Nullable SsaStyle style = SsaStyle.fromStyleLine(currentLine, formatInfo);
+        if (style != null) {
+          styles.put(style.name, style);
+        }
       }
     }
-    if (formatStartIndex == C.INDEX_UNSET
-        || formatEndIndex == C.INDEX_UNSET
-        || formatTextIndex == C.INDEX_UNSET) {
-      // Set to 0 so that parseDialogueLine skips lines until a complete format line is found.
-      formatKeyCount = 0;
-    }
+    return styles;
   }
 
   /**
-   * Parses a dialogue line.
+   * Parses the event body of the subtitle.
    *
-   * @param dialogueLine The line to parse.
+   * @param data A {@link ParsableByteArray} from which the body should be read.
    * @param cues A list to which parsed cues will be added.
-   * @param cueTimesUs An array to which parsed cue timestamps will be added.
+   * @param cueTimesUs A sorted list to which parsed cue timestamps will be added.
    */
-  private void parseDialogueLine(String dialogueLine, List<Cue> cues, LongArray cueTimesUs) {
-    if (formatKeyCount == 0) {
-      Log.w(TAG, "Skipping dialogue line before complete format: " + dialogueLine);
-      return;
+  private void parseEventBody(ParsableByteArray data, List<List<Cue>> cues, List<Long> cueTimesUs) {
+    @Nullable
+    SsaDialogueFormat format = haveInitializationData ? dialogueFormatFromInitializationData : null;
+    @Nullable String currentLine;
+    while ((currentLine = data.readLine()) != null) {
+      if (currentLine.startsWith(FORMAT_LINE_PREFIX)) {
+        format = SsaDialogueFormat.fromFormatLine(currentLine);
+      } else if (currentLine.startsWith(DIALOGUE_LINE_PREFIX)) {
+        if (format == null) {
+          Log.w(TAG, "Skipping dialogue line before complete format: " + currentLine);
+          continue;
+        }
+        parseDialogueLine(currentLine, format, cues, cueTimesUs);
+      }
     }
+  }
 
-    String[] lineValues = dialogueLine.substring(DIALOGUE_LINE_PREFIX.length())
-        .split(",", formatKeyCount);
-    if (lineValues.length != formatKeyCount) {
+  /**
+   * Parses a dialogue line.
+   *
+   * @param dialogueLine The dialogue values (i.e. everything after {@code Dialogue:}).
+   * @param format The dialogue format to use when parsing {@code dialogueLine}.
+   * @param cues A list to which parsed cues will be added.
+   * @param cueTimesUs A sorted list to which parsed cue timestamps will be added.
+   */
+  private void parseDialogueLine(
+      String dialogueLine, SsaDialogueFormat format, List<List<Cue>> cues, List<Long> cueTimesUs) {
+    Assertions.checkArgument(dialogueLine.startsWith(DIALOGUE_LINE_PREFIX));
+    String[] lineValues =
+        dialogueLine.substring(DIALOGUE_LINE_PREFIX.length()).split(",", format.length);
+    if (lineValues.length != format.length) {
       Log.w(TAG, "Skipping dialogue line with fewer columns than format: " + dialogueLine);
       return;
     }
 
-    long startTimeUs = SsaDecoder.parseTimecodeUs(lineValues[formatStartIndex]);
+    long startTimeUs = parseTimecodeUs(lineValues[format.startTimeIndex]);
     if (startTimeUs == C.TIME_UNSET) {
       Log.w(TAG, "Skipping invalid timing: " + dialogueLine);
       return;
     }
 
-    long endTimeUs = C.TIME_UNSET;
-    String endTimeString = lineValues[formatEndIndex];
-    if (!endTimeString.trim().isEmpty()) {
-      endTimeUs = SsaDecoder.parseTimecodeUs(endTimeString);
-      if (endTimeUs == C.TIME_UNSET) {
-        Log.w(TAG, "Skipping invalid timing: " + dialogueLine);
-        return;
-      }
+    long endTimeUs = parseTimecodeUs(lineValues[format.endTimeIndex]);
+    if (endTimeUs == C.TIME_UNSET) {
+      Log.w(TAG, "Skipping invalid timing: " + dialogueLine);
+      return;
     }
 
-    String text = lineValues[formatTextIndex]
-        .replaceAll("\\{.*?\\}", "")
-        .replaceAll("\\\\N", "\n")
-        .replaceAll("\\\\n", "\n");
-    cues.add(new Cue(text));
-    cueTimesUs.add(startTimeUs);
-    if (endTimeUs != C.TIME_UNSET) {
-      cues.add(Cue.EMPTY);
-      cueTimesUs.add(endTimeUs);
+    @Nullable
+    SsaStyle style =
+        styles != null && format.styleIndex != C.INDEX_UNSET
+            ? styles.get(lineValues[format.styleIndex].trim())
+            : null;
+    String rawText = lineValues[format.textIndex];
+    SsaStyle.Overrides styleOverrides = SsaStyle.Overrides.parseFromDialogue(rawText);
+    String text =
+        SsaStyle.Overrides.stripStyleOverrides(rawText)
+            .replaceAll("\\\\N", "\n")
+            .replaceAll("\\\\n", "\n");
+    Cue cue = createCue(text, style, styleOverrides, screenWidth, screenHeight);
+
+    int startTimeIndex = addCuePlacerholderByTime(startTimeUs, cueTimesUs, cues);
+    int endTimeIndex = addCuePlacerholderByTime(endTimeUs, cueTimesUs, cues);
+    // Iterate on cues from startTimeIndex until endTimeIndex, adding the current cue.
+    for (int i = startTimeIndex; i < endTimeIndex; i++) {
+      cues.get(i).add(cue);
     }
   }
 
@@ -214,16 +280,167 @@ public final class SsaDecoder extends SimpleSubtitleDecoder {
    * @param timeString The string to parse.
    * @return The parsed timestamp in microseconds.
    */
-  public static long parseTimecodeUs(String timeString) {
-    Matcher matcher = SSA_TIMECODE_PATTERN.matcher(timeString);
+  private static long parseTimecodeUs(String timeString) {
+    Matcher matcher = SSA_TIMECODE_PATTERN.matcher(timeString.trim());
     if (!matcher.matches()) {
       return C.TIME_UNSET;
     }
-    long timestampUs = Long.parseLong(matcher.group(1)) * 60 * 60 * C.MICROS_PER_SECOND;
-    timestampUs += Long.parseLong(matcher.group(2)) * 60 * C.MICROS_PER_SECOND;
-    timestampUs += Long.parseLong(matcher.group(3)) * C.MICROS_PER_SECOND;
-    timestampUs += Long.parseLong(matcher.group(4)) * 10000; // 100ths of a second.
+    long timestampUs =
+        Long.parseLong(castNonNull(matcher.group(1))) * 60 * 60 * C.MICROS_PER_SECOND;
+    timestampUs += Long.parseLong(castNonNull(matcher.group(2))) * 60 * C.MICROS_PER_SECOND;
+    timestampUs += Long.parseLong(castNonNull(matcher.group(3))) * C.MICROS_PER_SECOND;
+    timestampUs += Long.parseLong(castNonNull(matcher.group(4))) * 10000; // 100ths of a second.
     return timestampUs;
   }
 
+  private static Cue createCue(
+      String text,
+      @Nullable SsaStyle style,
+      SsaStyle.Overrides styleOverrides,
+      float screenWidth,
+      float screenHeight) {
+    @SsaStyle.SsaAlignment int alignment;
+    if (styleOverrides.alignment != SsaStyle.SSA_ALIGNMENT_UNKNOWN) {
+      alignment = styleOverrides.alignment;
+    } else if (style != null) {
+      alignment = style.alignment;
+    } else {
+      alignment = SsaStyle.SSA_ALIGNMENT_UNKNOWN;
+    }
+    @Cue.AnchorType int positionAnchor = toPositionAnchor(alignment);
+    @Cue.AnchorType int lineAnchor = toLineAnchor(alignment);
+
+    float position;
+    float line;
+    if (styleOverrides.position != null
+        && screenHeight != Cue.DIMEN_UNSET
+        && screenWidth != Cue.DIMEN_UNSET) {
+      position = styleOverrides.position.x / screenWidth;
+      line = styleOverrides.position.y / screenHeight;
+    } else {
+      // TODO: Read the MarginL, MarginR and MarginV values from the Style & Dialogue lines.
+      position = computeDefaultLineOrPosition(positionAnchor);
+      line = computeDefaultLineOrPosition(lineAnchor);
+    }
+
+    return new Cue(
+        text,
+        toTextAlignment(alignment),
+        line,
+        Cue.LINE_TYPE_FRACTION,
+        lineAnchor,
+        position,
+        positionAnchor,
+        /* size= */ Cue.DIMEN_UNSET);
+  }
+
+  @Nullable
+  private static Layout.Alignment toTextAlignment(@SsaStyle.SsaAlignment int alignment) {
+    switch (alignment) {
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_TOP_LEFT:
+        return Layout.Alignment.ALIGN_NORMAL;
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_TOP_CENTER:
+        return Layout.Alignment.ALIGN_CENTER;
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_RIGHT:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_RIGHT:
+      case SsaStyle.SSA_ALIGNMENT_TOP_RIGHT:
+        return Layout.Alignment.ALIGN_OPPOSITE;
+      case SsaStyle.SSA_ALIGNMENT_UNKNOWN:
+        return null;
+      default:
+        Log.w(TAG, "Unknown alignment: " + alignment);
+        return null;
+    }
+  }
+
+  @Cue.AnchorType
+  private static int toLineAnchor(@SsaStyle.SsaAlignment int alignment) {
+    switch (alignment) {
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_RIGHT:
+        return Cue.ANCHOR_TYPE_END;
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_RIGHT:
+        return Cue.ANCHOR_TYPE_MIDDLE;
+      case SsaStyle.SSA_ALIGNMENT_TOP_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_TOP_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_TOP_RIGHT:
+        return Cue.ANCHOR_TYPE_START;
+      case SsaStyle.SSA_ALIGNMENT_UNKNOWN:
+        return Cue.TYPE_UNSET;
+      default:
+        Log.w(TAG, "Unknown alignment: " + alignment);
+        return Cue.TYPE_UNSET;
+    }
+  }
+
+  @Cue.AnchorType
+  private static int toPositionAnchor(@SsaStyle.SsaAlignment int alignment) {
+    switch (alignment) {
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_LEFT:
+      case SsaStyle.SSA_ALIGNMENT_TOP_LEFT:
+        return Cue.ANCHOR_TYPE_START;
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_CENTER:
+      case SsaStyle.SSA_ALIGNMENT_TOP_CENTER:
+        return Cue.ANCHOR_TYPE_MIDDLE;
+      case SsaStyle.SSA_ALIGNMENT_BOTTOM_RIGHT:
+      case SsaStyle.SSA_ALIGNMENT_MIDDLE_RIGHT:
+      case SsaStyle.SSA_ALIGNMENT_TOP_RIGHT:
+        return Cue.ANCHOR_TYPE_END;
+      case SsaStyle.SSA_ALIGNMENT_UNKNOWN:
+        return Cue.TYPE_UNSET;
+      default:
+        Log.w(TAG, "Unknown alignment: " + alignment);
+        return Cue.TYPE_UNSET;
+    }
+  }
+
+  private static float computeDefaultLineOrPosition(@Cue.AnchorType int anchor) {
+    switch (anchor) {
+      case Cue.ANCHOR_TYPE_START:
+        return DEFAULT_MARGIN;
+      case Cue.ANCHOR_TYPE_MIDDLE:
+        return 0.5f;
+      case Cue.ANCHOR_TYPE_END:
+        return 1.0f - DEFAULT_MARGIN;
+      case Cue.TYPE_UNSET:
+      default:
+        return Cue.DIMEN_UNSET;
+    }
+  }
+
+  /**
+   * Searches for {@code timeUs} in {@code sortedCueTimesUs}, inserting it if it's not found, and
+   * returns the index.
+   *
+   * <p>If it's inserted, we also insert a matching entry to {@code cues}.
+   */
+  private static int addCuePlacerholderByTime(
+      long timeUs, List<Long> sortedCueTimesUs, List<List<Cue>> cues) {
+    int insertionIndex = 0;
+    for (int i = sortedCueTimesUs.size() - 1; i >= 0; i--) {
+      if (sortedCueTimesUs.get(i) == timeUs) {
+        return i;
+      }
+
+      if (sortedCueTimesUs.get(i) < timeUs) {
+        insertionIndex = i + 1;
+        break;
+      }
+    }
+    sortedCueTimesUs.add(insertionIndex, timeUs);
+    // Copy over cues from left, or use an empty list if we're inserting at the beginning.
+    cues.add(
+        insertionIndex,
+        insertionIndex == 0 ? new ArrayList<>() : new ArrayList<>(cues.get(insertionIndex - 1)));
+    return insertionIndex;
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDialogueFormat.java b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDialogueFormat.java
new file mode 100644
index 0000000..03c025c
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDialogueFormat.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.google.android.exoplayer2.text.ssa;
+
+import static com.google.android.exoplayer2.text.ssa.SsaDecoder.FORMAT_LINE_PREFIX;
+
+import android.text.TextUtils;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Represents a {@code Format:} line from the {@code [Events]} section
+ *
+ * <p>The indices are used to determine the location of particular properties in each {@code
+ * Dialogue:} line.
+ */
+/* package */ final class SsaDialogueFormat {
+
+  public final int startTimeIndex;
+  public final int endTimeIndex;
+  public final int styleIndex;
+  public final int textIndex;
+  public final int length;
+
+  private SsaDialogueFormat(
+      int startTimeIndex, int endTimeIndex, int styleIndex, int textIndex, int length) {
+    this.startTimeIndex = startTimeIndex;
+    this.endTimeIndex = endTimeIndex;
+    this.styleIndex = styleIndex;
+    this.textIndex = textIndex;
+    this.length = length;
+  }
+
+  /**
+   * Parses the format info from a 'Format:' line in the [Events] section.
+   *
+   * @return the parsed info, or null if {@code formatLine} doesn't contain both 'start' and 'end'.
+   */
+  @Nullable
+  public static SsaDialogueFormat fromFormatLine(String formatLine) {
+    int startTimeIndex = C.INDEX_UNSET;
+    int endTimeIndex = C.INDEX_UNSET;
+    int styleIndex = C.INDEX_UNSET;
+    int textIndex = C.INDEX_UNSET;
+    Assertions.checkArgument(formatLine.startsWith(FORMAT_LINE_PREFIX));
+    String[] keys = TextUtils.split(formatLine.substring(FORMAT_LINE_PREFIX.length()), ",");
+    for (int i = 0; i < keys.length; i++) {
+      switch (Util.toLowerInvariant(keys[i].trim())) {
+        case "start":
+          startTimeIndex = i;
+          break;
+        case "end":
+          endTimeIndex = i;
+          break;
+        case "style":
+          styleIndex = i;
+          break;
+        case "text":
+          textIndex = i;
+          break;
+      }
+    }
+    return (startTimeIndex != C.INDEX_UNSET && endTimeIndex != C.INDEX_UNSET)
+        ? new SsaDialogueFormat(startTimeIndex, endTimeIndex, styleIndex, textIndex, keys.length)
+        : null;
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaStyle.java b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaStyle.java
new file mode 100644
index 0000000..fd2cb03
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaStyle.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.google.android.exoplayer2.text.ssa;
+
+import static com.google.android.exoplayer2.text.ssa.SsaDecoder.STYLE_LINE_PREFIX;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import android.graphics.PointF;
+import android.text.TextUtils;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Represents a line from an SSA/ASS {@code [V4+ Styles]} section. */
+/* package */ final class SsaStyle {
+
+  private static final String TAG = "SsaStyle";
+
+  /**
+   * The SSA/ASS alignments.
+   *
+   * <p>Allowed values:
+   *
+   * <ul>
+   *   <li>{@link #SSA_ALIGNMENT_UNKNOWN}
+   *   <li>{@link #SSA_ALIGNMENT_BOTTOM_LEFT}
+   *   <li>{@link #SSA_ALIGNMENT_BOTTOM_CENTER}
+   *   <li>{@link #SSA_ALIGNMENT_BOTTOM_RIGHT}
+   *   <li>{@link #SSA_ALIGNMENT_MIDDLE_LEFT}
+   *   <li>{@link #SSA_ALIGNMENT_MIDDLE_CENTER}
+   *   <li>{@link #SSA_ALIGNMENT_MIDDLE_RIGHT}
+   *   <li>{@link #SSA_ALIGNMENT_TOP_LEFT}
+   *   <li>{@link #SSA_ALIGNMENT_TOP_CENTER}
+   *   <li>{@link #SSA_ALIGNMENT_TOP_RIGHT}
+   * </ul>
+   */
+  @IntDef({
+    SSA_ALIGNMENT_UNKNOWN,
+    SSA_ALIGNMENT_BOTTOM_LEFT,
+    SSA_ALIGNMENT_BOTTOM_CENTER,
+    SSA_ALIGNMENT_BOTTOM_RIGHT,
+    SSA_ALIGNMENT_MIDDLE_LEFT,
+    SSA_ALIGNMENT_MIDDLE_CENTER,
+    SSA_ALIGNMENT_MIDDLE_RIGHT,
+    SSA_ALIGNMENT_TOP_LEFT,
+    SSA_ALIGNMENT_TOP_CENTER,
+    SSA_ALIGNMENT_TOP_RIGHT,
+  })
+  @Documented
+  @Retention(SOURCE)
+  public @interface SsaAlignment {}
+
+  // The numbering follows the ASS (v4+) spec (i.e. the points on the number pad).
+  public static final int SSA_ALIGNMENT_UNKNOWN = -1;
+  public static final int SSA_ALIGNMENT_BOTTOM_LEFT = 1;
+  public static final int SSA_ALIGNMENT_BOTTOM_CENTER = 2;
+  public static final int SSA_ALIGNMENT_BOTTOM_RIGHT = 3;
+  public static final int SSA_ALIGNMENT_MIDDLE_LEFT = 4;
+  public static final int SSA_ALIGNMENT_MIDDLE_CENTER = 5;
+  public static final int SSA_ALIGNMENT_MIDDLE_RIGHT = 6;
+  public static final int SSA_ALIGNMENT_TOP_LEFT = 7;
+  public static final int SSA_ALIGNMENT_TOP_CENTER = 8;
+  public static final int SSA_ALIGNMENT_TOP_RIGHT = 9;
+
+  public final String name;
+  @SsaAlignment public final int alignment;
+
+  private SsaStyle(String name, @SsaAlignment int alignment) {
+    this.name = name;
+    this.alignment = alignment;
+  }
+
+  @Nullable
+  public static SsaStyle fromStyleLine(String styleLine, Format format) {
+    Assertions.checkArgument(styleLine.startsWith(STYLE_LINE_PREFIX));
+    String[] styleValues = TextUtils.split(styleLine.substring(STYLE_LINE_PREFIX.length()), ",");
+    if (styleValues.length != format.length) {
+      Log.w(
+          TAG,
+          Util.formatInvariant(
+              "Skipping malformed 'Style:' line (expected %s values, found %s): '%s'",
+              format.length, styleValues.length, styleLine));
+      return null;
+    }
+    try {
+      return new SsaStyle(
+          styleValues[format.nameIndex].trim(), parseAlignment(styleValues[format.alignmentIndex]));
+    } catch (RuntimeException e) {
+      Log.w(TAG, "Skipping malformed 'Style:' line: '" + styleLine + "'", e);
+      return null;
+    }
+  }
+
+  @SsaAlignment
+  private static int parseAlignment(String alignmentStr) {
+    try {
+      @SsaAlignment int alignment = Integer.parseInt(alignmentStr.trim());
+      if (isValidAlignment(alignment)) {
+        return alignment;
+      }
+    } catch (NumberFormatException e) {
+      // Swallow the exception and return UNKNOWN below.
+    }
+    Log.w(TAG, "Ignoring unknown alignment: " + alignmentStr);
+    return SSA_ALIGNMENT_UNKNOWN;
+  }
+
+  private static boolean isValidAlignment(@SsaAlignment int alignment) {
+    switch (alignment) {
+      case SSA_ALIGNMENT_BOTTOM_CENTER:
+      case SSA_ALIGNMENT_BOTTOM_LEFT:
+      case SSA_ALIGNMENT_BOTTOM_RIGHT:
+      case SSA_ALIGNMENT_MIDDLE_CENTER:
+      case SSA_ALIGNMENT_MIDDLE_LEFT:
+      case SSA_ALIGNMENT_MIDDLE_RIGHT:
+      case SSA_ALIGNMENT_TOP_CENTER:
+      case SSA_ALIGNMENT_TOP_LEFT:
+      case SSA_ALIGNMENT_TOP_RIGHT:
+        return true;
+      case SSA_ALIGNMENT_UNKNOWN:
+      default:
+        return false;
+    }
+  }
+
+  /**
+   * Represents a {@code Format:} line from the {@code [V4+ Styles]} section
+   *
+   * <p>The indices are used to determine the location of particular properties in each {@code
+   * Style:} line.
+   */
+  /* package */ static final class Format {
+
+    public final int nameIndex;
+    public final int alignmentIndex;
+    public final int length;
+
+    private Format(int nameIndex, int alignmentIndex, int length) {
+      this.nameIndex = nameIndex;
+      this.alignmentIndex = alignmentIndex;
+      this.length = length;
+    }
+
+    /**
+     * Parses the format info from a 'Format:' line in the [V4+ Styles] section.
+     *
+     * @return the parsed info, or null if {@code styleFormatLine} doesn't contain 'name'.
+     */
+    @Nullable
+    public static Format fromFormatLine(String styleFormatLine) {
+      int nameIndex = C.INDEX_UNSET;
+      int alignmentIndex = C.INDEX_UNSET;
+      String[] keys =
+          TextUtils.split(styleFormatLine.substring(SsaDecoder.FORMAT_LINE_PREFIX.length()), ",");
+      for (int i = 0; i < keys.length; i++) {
+        switch (Util.toLowerInvariant(keys[i].trim())) {
+          case "name":
+            nameIndex = i;
+            break;
+          case "alignment":
+            alignmentIndex = i;
+            break;
+        }
+      }
+      return nameIndex != C.INDEX_UNSET ? new Format(nameIndex, alignmentIndex, keys.length) : null;
+    }
+  }
+
+  /**
+   * Represents the style override information parsed from an SSA/ASS dialogue line.
+   *
+   * <p>Overrides are contained in braces embedded in the dialogue text of the cue.
+   */
+  /* package */ static final class Overrides {
+
+    private static final String TAG = "SsaStyle.Overrides";
+
+    /** Matches "{foo}" and returns "foo" in group 1 */
+    // Warning that \\} can be replaced with } is bogus [internal: b/144480183].
+    private static final Pattern BRACES_PATTERN = Pattern.compile("\\{([^}]*)\\}");
+
+    private static final String PADDED_DECIMAL_PATTERN = "\\s*\\d+(?:\\.\\d+)?\\s*";
+
+    /** Matches "\pos(x,y)" and returns "x" in group 1 and "y" in group 2 */
+    private static final Pattern POSITION_PATTERN =
+        Pattern.compile(Util.formatInvariant("\\\\pos\\((%1$s),(%1$s)\\)", PADDED_DECIMAL_PATTERN));
+    /** Matches "\move(x1,y1,x2,y2[,t1,t2])" and returns "x2" in group 1 and "y2" in group 2 */
+    private static final Pattern MOVE_PATTERN =
+        Pattern.compile(
+            Util.formatInvariant(
+                "\\\\move\\(%1$s,%1$s,(%1$s),(%1$s)(?:,%1$s,%1$s)?\\)", PADDED_DECIMAL_PATTERN));
+
+    /** Matches "\anx" and returns x in group 1 */
+    private static final Pattern ALIGNMENT_OVERRIDE_PATTERN = Pattern.compile("\\\\an(\\d+)");
+
+    @SsaAlignment public final int alignment;
+    @Nullable public final PointF position;
+
+    private Overrides(@SsaAlignment int alignment, @Nullable PointF position) {
+      this.alignment = alignment;
+      this.position = position;
+    }
+
+    public static Overrides parseFromDialogue(String text) {
+      @SsaAlignment int alignment = SSA_ALIGNMENT_UNKNOWN;
+      PointF position = null;
+      Matcher matcher = BRACES_PATTERN.matcher(text);
+      while (matcher.find()) {
+        String braceContents = matcher.group(1);
+        try {
+          PointF parsedPosition = parsePosition(braceContents);
+          if (parsedPosition != null) {
+            position = parsedPosition;
+          }
+        } catch (RuntimeException e) {
+          // Ignore invalid \pos() or \move() function.
+        }
+        try {
+          @SsaAlignment int parsedAlignment = parseAlignmentOverride(braceContents);
+          if (parsedAlignment != SSA_ALIGNMENT_UNKNOWN) {
+            alignment = parsedAlignment;
+          }
+        } catch (RuntimeException e) {
+          // Ignore invalid \an alignment override.
+        }
+      }
+      return new Overrides(alignment, position);
+    }
+
+    public static String stripStyleOverrides(String dialogueLine) {
+      return BRACES_PATTERN.matcher(dialogueLine).replaceAll("");
+    }
+
+    /**
+     * Parses the position from a style override, returns null if no position is found.
+     *
+     * <p>The attribute is expected to be in the form {@code \pos(x,y)} or {@code
+     * \move(x1,y1,x2,y2,startTime,endTime)} (startTime and endTime are optional). In the case of
+     * {@code \move()}, this returns {@code (x2, y2)} (i.e. the end position of the move).
+     *
+     * @param styleOverride The string to parse.
+     * @return The parsed position, or null if no position is found.
+     */
+    @Nullable
+    private static PointF parsePosition(String styleOverride) {
+      Matcher positionMatcher = POSITION_PATTERN.matcher(styleOverride);
+      Matcher moveMatcher = MOVE_PATTERN.matcher(styleOverride);
+      boolean hasPosition = positionMatcher.find();
+      boolean hasMove = moveMatcher.find();
+
+      String x;
+      String y;
+      if (hasPosition) {
+        if (hasMove) {
+          Log.i(
+              TAG,
+              "Override has both \\pos(x,y) and \\move(x1,y1,x2,y2); using \\pos values. override='"
+                  + styleOverride
+                  + "'");
+        }
+        x = positionMatcher.group(1);
+        y = positionMatcher.group(2);
+      } else if (hasMove) {
+        x = moveMatcher.group(1);
+        y = moveMatcher.group(2);
+      } else {
+        return null;
+      }
+      return new PointF(
+          Float.parseFloat(Assertions.checkNotNull(x).trim()),
+          Float.parseFloat(Assertions.checkNotNull(y).trim()));
+    }
+
+    @SsaAlignment
+    private static int parseAlignmentOverride(String braceContents) {
+      Matcher matcher = ALIGNMENT_OVERRIDE_PATTERN.matcher(braceContents);
+      return matcher.find() ? parseAlignment(matcher.group(1)) : SSA_ALIGNMENT_UNKNOWN;
+    }
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java
index 9a37561..4093f79 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaSubtitle.java
@@ -28,14 +28,14 @@ import java.util.List;
  */
 /* package */ final class SsaSubtitle implements Subtitle {
 
-  private final Cue[] cues;
-  private final long[] cueTimesUs;
+  private final List<List<Cue>> cues;
+  private final List<Long> cueTimesUs;
 
   /**
    * @param cues The cues in the subtitle.
    * @param cueTimesUs The cue times, in microseconds.
    */
-  public SsaSubtitle(Cue[] cues, long[] cueTimesUs) {
+  public SsaSubtitle(List<List<Cue>> cues, List<Long> cueTimesUs) {
     this.cues = cues;
     this.cueTimesUs = cueTimesUs;
   }
@@ -43,30 +43,29 @@ import java.util.List;
   @Override
   public int getNextEventTimeIndex(long timeUs) {
     int index = Util.binarySearchCeil(cueTimesUs, timeUs, false, false);
-    return index < cueTimesUs.length ? index : C.INDEX_UNSET;
+    return index < cueTimesUs.size() ? index : C.INDEX_UNSET;
   }
 
   @Override
   public int getEventTimeCount() {
-    return cueTimesUs.length;
+    return cueTimesUs.size();
   }
 
   @Override
   public long getEventTime(int index) {
     Assertions.checkArgument(index >= 0);
-    Assertions.checkArgument(index < cueTimesUs.length);
-    return cueTimesUs[index];
+    Assertions.checkArgument(index < cueTimesUs.size());
+    return cueTimesUs.get(index);
   }
 
   @Override
   public List<Cue> getCues(long timeUs) {
     int index = Util.binarySearchFloor(cueTimesUs, timeUs, true, false);
-    if (index == -1 || cues[index] == Cue.EMPTY) {
-      // timeUs is earlier than the start of the first cue, or we have an empty cue.
+    if (index == -1) {
+      // timeUs is earlier than the start of the first cue.
       return Collections.emptyList();
     } else {
-      return Collections.singletonList(cues[index]);
+      return cues.get(index);
     }
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/ssa/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/ssa/package-info.java
new file mode 100644
index 0000000..cdf891d
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/ssa/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.ssa;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java b/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
index 8d1b743..0c402ac 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
@@ -43,7 +43,7 @@ public final class SubripDecoder extends SimpleSubtitleDecoder {
 
   private static final String SUBRIP_TIMECODE = "(?:(\\d+):)?(\\d+):(\\d+),(\\d+)";
   private static final Pattern SUBRIP_TIMING_LINE =
-      Pattern.compile("\\s*(" + SUBRIP_TIMECODE + ")\\s*-->\\s*(" + SUBRIP_TIMECODE + ")?\\s*");
+      Pattern.compile("\\s*(" + SUBRIP_TIMECODE + ")\\s*-->\\s*(" + SUBRIP_TIMECODE + ")\\s*");
 
   private static final Pattern SUBRIP_TAG_PATTERN = Pattern.compile("\\{\\\\.*?\\}");
   private static final String SUBRIP_ALIGNMENT_TAG = "\\{\\\\an[1-9]\\}";
@@ -73,8 +73,8 @@ public final class SubripDecoder extends SimpleSubtitleDecoder {
     ArrayList<Cue> cues = new ArrayList<>();
     LongArray cueTimesUs = new LongArray();
     ParsableByteArray subripData = new ParsableByteArray(bytes, length);
-    String currentLine;
 
+    @Nullable String currentLine;
     while ((currentLine = subripData.readLine()) != null) {
       if (currentLine.length() == 0) {
         // Skip blank lines.
@@ -90,7 +90,6 @@ public final class SubripDecoder extends SimpleSubtitleDecoder {
       }
 
       // Read and parse the timing line.
-      boolean haveEndTimecode = false;
       currentLine = subripData.readLine();
       if (currentLine == null) {
         Log.w(TAG, "Unexpected end");
@@ -99,11 +98,8 @@ public final class SubripDecoder extends SimpleSubtitleDecoder {
 
       Matcher matcher = SUBRIP_TIMING_LINE.matcher(currentLine);
       if (matcher.matches()) {
-        cueTimesUs.add(parseTimecode(matcher, 1));
-        if (!TextUtils.isEmpty(matcher.group(6))) {
-          haveEndTimecode = true;
-          cueTimesUs.add(parseTimecode(matcher, 6));
-        }
+        cueTimesUs.add(parseTimecode(matcher, /* groupOffset= */ 1));
+        cueTimesUs.add(parseTimecode(matcher, /* groupOffset= */ 6));
       } else {
         Log.w(TAG, "Skipping invalid timing: " + currentLine);
         continue;
@@ -123,7 +119,7 @@ public final class SubripDecoder extends SimpleSubtitleDecoder {
 
       Spanned text = Html.fromHtml(textBuilder.toString());
 
-      String alignmentTag = null;
+      @Nullable String alignmentTag = null;
       for (int i = 0; i < tags.size(); i++) {
         String tag = tags.get(i);
         if (tag.matches(SUBRIP_ALIGNMENT_TAG)) {
@@ -133,10 +129,7 @@ public final class SubripDecoder extends SimpleSubtitleDecoder {
         }
       }
       cues.add(buildCue(text, alignmentTag));
-
-      if (haveEndTimecode) {
-        cues.add(Cue.EMPTY);
-      }
+      cues.add(Cue.EMPTY);
     }
 
     Cue[] cuesArray = new Cue[cues.size()];
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/subrip/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/subrip/package-info.java
new file mode 100644
index 0000000..bb7565c
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/subrip/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.subrip;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/ttml/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/ttml/package-info.java
new file mode 100644
index 0000000..5b0685e
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/ttml/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.ttml;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/tx3g/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/tx3g/package-info.java
new file mode 100644
index 0000000..2ae99ad
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/tx3g/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.tx3g;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index 2bd1af0..97c0acb 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -17,7 +17,9 @@ package com.google.android.exoplayer2.text.webvtt;
 
 import android.graphics.Typeface;
 import android.text.Layout;
+import android.text.TextUtils;
 import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -25,6 +27,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
 
 /**
  * Style object of a Css style block in a Webvtt file.
@@ -80,7 +83,7 @@ public final class WebvttCssStyle {
   private String targetVoice;
 
   // Style properties.
-  private String fontFamily;
+  @Nullable private String fontFamily;
   private int fontColor;
   private boolean hasFontColor;
   private int backgroundColor;
@@ -91,12 +94,16 @@ public final class WebvttCssStyle {
   @OptionalBoolean private int italic;
   @FontSizeUnit private int fontSizeUnit;
   private float fontSize;
-  private Layout.Alignment textAlign;
+  @Nullable private Layout.Alignment textAlign;
 
+  // Calling reset() is forbidden because `this` isn't initialized. This can be safely suppressed
+  // because reset() only assigns fields, it doesn't read any.
+  @SuppressWarnings("nullness:method.invocation.invalid")
   public WebvttCssStyle() {
     reset();
   }
 
+  @EnsuresNonNull({"targetId", "targetTag", "targetClasses", "targetVoice"})
   public void reset() {
     targetId = "";
     targetTag = "";
@@ -133,14 +140,13 @@ public final class WebvttCssStyle {
    * Returns a value in a score system compliant with the CSS Specificity rules.
    *
    * @see <a href="https://www.w3.org/TR/CSS2/cascade.html">CSS Cascading</a>
-   *
-   * The score works as follows:
-   * <ul>
-   * <li> Id match adds 0x40000000 to the score.
-   * <li> Each class and voice match adds 4 to the score.
-   * <li> Tag matching adds 2 to the score.
-   * <li> Universal selector matching scores 1.
-   * </ul>
+   *     <p>The score works as follows:
+   *     <ul>
+   *       <li>Id match adds 0x40000000 to the score.
+   *       <li>Each class and voice match adds 4 to the score.
+   *       <li>Tag matching adds 2 to the score.
+   *       <li>Universal selector matching scores 1.
+   *     </ul>
    *
    * @param id The id of the cue if present, {@code null} otherwise.
    * @param tag Name of the tag, {@code null} if it refers to the entire cue.
@@ -148,12 +154,13 @@ public final class WebvttCssStyle {
    * @param voice Annotated voice if present, {@code null} otherwise.
    * @return The score of the match, zero if there is no match.
    */
-  public int getSpecificityScore(String id, String tag, String[] classes, String voice) {
+  public int getSpecificityScore(
+      @Nullable String id, @Nullable String tag, String[] classes, @Nullable String voice) {
     if (targetId.isEmpty() && targetTag.isEmpty() && targetClasses.isEmpty()
         && targetVoice.isEmpty()) {
       // The selector is universal. It matches with the minimum score if and only if the given
       // element is a whole cue.
-      return tag.isEmpty() ? 1 : 0;
+      return TextUtils.isEmpty(tag) ? 1 : 0;
     }
     int score = 0;
     score = updateScoreForMatch(score, targetId, id, 0x40000000);
@@ -208,11 +215,12 @@ public final class WebvttCssStyle {
     return this;
   }
 
+  @Nullable
   public String getFontFamily() {
     return fontFamily;
   }
 
-  public WebvttCssStyle setFontFamily(String fontFamily) {
+  public WebvttCssStyle setFontFamily(@Nullable String fontFamily) {
     this.fontFamily = Util.toLowerInvariant(fontFamily);
     return this;
   }
@@ -251,11 +259,12 @@ public final class WebvttCssStyle {
     return hasBackgroundColor;
   }
 
+  @Nullable
   public Layout.Alignment getTextAlign() {
     return textAlign;
   }
 
-  public WebvttCssStyle setTextAlign(Layout.Alignment textAlign) {
+  public WebvttCssStyle setTextAlign(@Nullable Layout.Alignment textAlign) {
     this.textAlign = textAlign;
     return this;
   }
@@ -309,8 +318,8 @@ public final class WebvttCssStyle {
     }
   }
 
-  private static int updateScoreForMatch(int currentScore, String target, String actual,
-      int score) {
+  private static int updateScoreForMatch(
+      int currentScore, String target, @Nullable String actual, int score) {
     if (target.isEmpty() || currentScore == -1) {
       return currentScore;
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
index 857b156..55e568e 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
@@ -15,31 +15,36 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
 import android.text.Layout.Alignment;
-import android.text.SpannableStringBuilder;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 
-/**
- * A representation of a WebVTT cue.
- */
+/** A representation of a WebVTT cue. */
 public final class WebvttCue extends Cue {
 
+  private static final float DEFAULT_POSITION = 0.5f;
+
   public final long startTime;
   public final long endTime;
 
-  public WebvttCue(CharSequence text) {
-    this(0, 0, text);
-  }
-
-  public WebvttCue(long startTime, long endTime, CharSequence text) {
-    this(startTime, endTime, text, null, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET,
-        Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
-  }
-
-  public WebvttCue(long startTime, long endTime, CharSequence text, Alignment textAlignment,
-      float line, @Cue.LineType int lineType, @Cue.AnchorType int lineAnchor, float position,
-      @Cue.AnchorType int positionAnchor, float width) {
+  private WebvttCue(
+      long startTime,
+      long endTime,
+      CharSequence text,
+      @Nullable Alignment textAlignment,
+      float line,
+      @Cue.LineType int lineType,
+      @Cue.AnchorType int lineAnchor,
+      float position,
+      @Cue.AnchorType int positionAnchor,
+      float width) {
     super(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, width);
     this.startTime = startTime;
     this.endTime = endTime;
@@ -52,30 +57,81 @@ public final class WebvttCue extends Cue {
    * @return Whether this cue should be placed in the default position.
    */
   public boolean isNormalCue() {
-    return (line == DIMEN_UNSET && position == DIMEN_UNSET);
+    return (line == DIMEN_UNSET && position == DEFAULT_POSITION);
   }
 
-  /**
-   * Builder for WebVTT cues.
-   */
+  /** Builder for WebVTT cues. */
   @SuppressWarnings("hiding")
   public static class Builder {
 
+    /**
+     * Valid values for {@link #setTextAlignment(int)}.
+     *
+     * <p>We use a custom list (and not {@link Alignment} directly) in order to include both {@code
+     * START}/{@code LEFT} and {@code END}/{@code RIGHT}. The distinction is important for {@link
+     * #derivePosition(int)}.
+     *
+     * <p>These correspond to the valid values for the 'align' cue setting in the <a
+     * href="https://www.w3.org/TR/webvtt1/#webvtt-cue-text-alignment">WebVTT spec</a>.
+     */
+    @Documented
+    @Retention(SOURCE)
+    @IntDef({
+        TEXT_ALIGNMENT_START,
+        TEXT_ALIGNMENT_CENTER,
+        TEXT_ALIGNMENT_END,
+        TEXT_ALIGNMENT_LEFT,
+        TEXT_ALIGNMENT_RIGHT
+    })
+    public @interface TextAlignment {}
+    /**
+     * See WebVTT's <a
+     * href="https://www.w3.org/TR/webvtt1/#webvtt-cue-start-alignment">align:start</a>.
+     */
+    public static final int TEXT_ALIGNMENT_START = 1;
+
+    /**
+     * See WebVTT's <a
+     * href="https://www.w3.org/TR/webvtt1/#webvtt-cue-center-alignment">align:center</a>.
+     */
+    public static final int TEXT_ALIGNMENT_CENTER = 2;
+
+    /**
+     * See WebVTT's <a href="https://www.w3.org/TR/webvtt1/#webvtt-cue-end-alignment">align:end</a>.
+     */
+    public static final int TEXT_ALIGNMENT_END = 3;
+
+    /**
+     * See WebVTT's <a href="https://www.w3.org/TR/webvtt1/#webvtt-cue-left-alignment">align:left</a>.
+     */
+    public static final int TEXT_ALIGNMENT_LEFT = 4;
+
+    /**
+     * See WebVTT's <a
+     * href="https://www.w3.org/TR/webvtt1/#webvtt-cue-right-alignment">align:right</a>.
+     */
+    public static final int TEXT_ALIGNMENT_RIGHT = 5;
+
     private static final String TAG = "WebvttCueBuilder";
 
     private long startTime;
     private long endTime;
-    private SpannableStringBuilder text;
-    private Alignment textAlignment;
+    @Nullable private CharSequence text;
+    @TextAlignment private int textAlignment;
     private float line;
-    private int lineType;
-    private int lineAnchor;
+    // Equivalent to WebVTT's snap-to-lines flag:
+    // https://www.w3.org/TR/webvtt1/#webvtt-cue-snap-to-lines-flag
+    @LineType private int lineType;
+    @AnchorType private int lineAnchor;
     private float position;
-    private int positionAnchor;
+    @AnchorType private int positionAnchor;
     private float width;
 
     // Initialization methods
 
+    // Calling reset() is forbidden because `this` isn't initialized. This can be safely
+    // suppressed because reset() only assigns fields, it doesn't read any.
+    @SuppressWarnings("nullness:method.invocation.invalid")
     public Builder() {
       reset();
     }
@@ -84,23 +140,45 @@ public final class WebvttCue extends Cue {
       startTime = 0;
       endTime = 0;
       text = null;
-      textAlignment = null;
+      // Default: https://www.w3.org/TR/webvtt1/#webvtt-cue-text-alignment
+      textAlignment = TEXT_ALIGNMENT_CENTER;
       line = Cue.DIMEN_UNSET;
-      lineType = Cue.TYPE_UNSET;
-      lineAnchor = Cue.TYPE_UNSET;
+      // Defaults to NUMBER (true): https://www.w3.org/TR/webvtt1/#webvtt-cue-snap-to-lines-flag
+      lineType = Cue.LINE_TYPE_NUMBER;
+      // Default: https://www.w3.org/TR/webvtt1/#webvtt-cue-line-alignment
+      lineAnchor = Cue.ANCHOR_TYPE_START;
       position = Cue.DIMEN_UNSET;
       positionAnchor = Cue.TYPE_UNSET;
-      width = Cue.DIMEN_UNSET;
+      // Default: https://www.w3.org/TR/webvtt1/#webvtt-cue-size
+      width = 1.0f;
     }
 
     // Construction methods.
 
     public WebvttCue build() {
-      if (position != Cue.DIMEN_UNSET && positionAnchor == Cue.TYPE_UNSET) {
-        derivePositionAnchorFromAlignment();
+      line = computeLine(line, lineType);
+
+      if (position == Cue.DIMEN_UNSET) {
+        position = derivePosition(textAlignment);
+      }
+
+      if (positionAnchor == Cue.TYPE_UNSET) {
+        positionAnchor = derivePositionAnchor(textAlignment);
       }
-      return new WebvttCue(startTime, endTime, text, textAlignment, line, lineType, lineAnchor,
-          position, positionAnchor, width);
+
+      width = Math.min(width, deriveMaxSize(positionAnchor, position));
+
+      return new WebvttCue(
+          startTime,
+          endTime,
+          Assertions.checkNotNull(text),
+          convertTextAlignment(textAlignment),
+          line,
+          lineType,
+          lineAnchor,
+          position,
+          positionAnchor,
+          width);
     }
 
     public Builder setStartTime(long time) {
@@ -113,12 +191,12 @@ public final class WebvttCue extends Cue {
       return this;
     }
 
-    public Builder setText(SpannableStringBuilder aText) {
-      text = aText;
+    public Builder setText(CharSequence text) {
+      this.text = text;
       return this;
     }
 
-    public Builder setTextAlignment(Alignment textAlignment) {
+    public Builder setTextAlignment(@TextAlignment int textAlignment) {
       this.textAlignment = textAlignment;
       return this;
     }
@@ -128,12 +206,12 @@ public final class WebvttCue extends Cue {
       return this;
     }
 
-    public Builder setLineType(int lineType) {
+    public Builder setLineType(@LineType int lineType) {
       this.lineType = lineType;
       return this;
     }
 
-    public Builder setLineAnchor(int lineAnchor) {
+    public Builder setLineAnchor(@AnchorType int lineAnchor) {
       this.lineAnchor = lineAnchor;
       return this;
     }
@@ -143,7 +221,7 @@ public final class WebvttCue extends Cue {
       return this;
     }
 
-    public Builder setPositionAnchor(int positionAnchor) {
+    public Builder setPositionAnchor(@AnchorType int positionAnchor) {
       this.positionAnchor = positionAnchor;
       return this;
     }
@@ -153,29 +231,89 @@ public final class WebvttCue extends Cue {
       return this;
     }
 
-    private Builder derivePositionAnchorFromAlignment() {
-      if (textAlignment == null) {
-        positionAnchor = Cue.TYPE_UNSET;
+    // https://www.w3.org/TR/webvtt1/#webvtt-cue-line
+    private static float computeLine(float line, @LineType int lineType) {
+      if (line != Cue.DIMEN_UNSET
+          && lineType == Cue.LINE_TYPE_FRACTION
+          && (line < 0.0f || line > 1.0f)) {
+        return 1.0f; // Step 1
+      } else if (line != Cue.DIMEN_UNSET) {
+        // Step 2: Do nothing, line is already correct.
+        return line;
+      } else if (lineType == Cue.LINE_TYPE_FRACTION) {
+        return 1.0f; // Step 3
       } else {
-        switch (textAlignment) {
-          case ALIGN_NORMAL:
-            positionAnchor = Cue.ANCHOR_TYPE_START;
-            break;
-          case ALIGN_CENTER:
-            positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
-            break;
-          case ALIGN_OPPOSITE:
-            positionAnchor = Cue.ANCHOR_TYPE_END;
-            break;
-          default:
-            Log.w(TAG, "Unrecognized alignment: " + textAlignment);
-            positionAnchor = Cue.ANCHOR_TYPE_START;
-            break;
-        }
+        // Steps 4 - 10 (stacking multiple simultaneous cues) are handled by WebvttSubtitle#getCues
+        // and WebvttCue#isNormalCue.
+        return DIMEN_UNSET;
       }
-      return this;
     }
 
-  }
+    // https://www.w3.org/TR/webvtt1/#webvtt-cue-position
+    private static float derivePosition(@TextAlignment int textAlignment) {
+      switch (textAlignment) {
+        case TEXT_ALIGNMENT_LEFT:
+          return 0.0f;
+        case TEXT_ALIGNMENT_RIGHT:
+          return 1.0f;
+        case TEXT_ALIGNMENT_START:
+        case TEXT_ALIGNMENT_CENTER:
+        case TEXT_ALIGNMENT_END:
+        default:
+          return DEFAULT_POSITION;
+      }
+    }
+
+    // https://www.w3.org/TR/webvtt1/#webvtt-cue-position-alignment
+    @AnchorType
+    private static int derivePositionAnchor(@TextAlignment int textAlignment) {
+      switch (textAlignment) {
+        case TEXT_ALIGNMENT_LEFT:
+        case TEXT_ALIGNMENT_START:
+          return Cue.ANCHOR_TYPE_START;
+        case TEXT_ALIGNMENT_RIGHT:
+        case TEXT_ALIGNMENT_END:
+          return Cue.ANCHOR_TYPE_END;
+        case TEXT_ALIGNMENT_CENTER:
+        default:
+          return Cue.ANCHOR_TYPE_MIDDLE;
+      }
+    }
+
+    @Nullable
+    private static Alignment convertTextAlignment(@TextAlignment int textAlignment) {
+      switch (textAlignment) {
+        case TEXT_ALIGNMENT_START:
+        case TEXT_ALIGNMENT_LEFT:
+          return Alignment.ALIGN_NORMAL;
+        case TEXT_ALIGNMENT_CENTER:
+          return Alignment.ALIGN_CENTER;
+        case TEXT_ALIGNMENT_END:
+        case TEXT_ALIGNMENT_RIGHT:
+          return Alignment.ALIGN_OPPOSITE;
+        default:
+          Log.w(TAG, "Unknown textAlignment: " + textAlignment);
+          return null;
+      }
+    }
 
+    // Step 2 here: https://www.w3.org/TR/webvtt1/#processing-cue-settings
+    private static float deriveMaxSize(@AnchorType int positionAnchor, float position) {
+      switch (positionAnchor) {
+        case Cue.ANCHOR_TYPE_START:
+          return 1.0f - position;
+        case Cue.ANCHOR_TYPE_END:
+          return position;
+        case Cue.ANCHOR_TYPE_MIDDLE:
+          if (position <= 0.5f) {
+            return position * 2;
+          } else {
+            return (1.0f - position) * 2;
+          }
+        case Cue.TYPE_UNSET:
+        default:
+          throw new IllegalStateException(String.valueOf(positionAnchor));
+      }
+    }
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
index bb639bf..b6ddf89 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.text.webvtt;
 
 import android.graphics.Typeface;
-import android.text.Layout.Alignment;
+import android.text.Layout;
 import android.text.Spannable;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
@@ -31,21 +31,20 @@ import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
 import android.text.style.UnderlineSpan;
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-/**
- * Parser for WebVTT cues. (https://w3c.github.io/webvtt/#cues)
- */
+/** Parser for WebVTT cues. (https://w3c.github.io/webvtt/#cues) */
 public final class WebvttCueParser {
 
   public static final Pattern CUE_HEADER_PATTERN = Pattern
@@ -87,13 +86,13 @@ public final class WebvttCueParser {
    * Parses the next valid WebVTT cue in a parsable array, including timestamps, settings and text.
    *
    * @param webvttData Parsable WebVTT file data.
-   * @param builder Builder for WebVTT Cues.
-   * @param styles List of styles defined by the CSS style blocks preceeding the cues.
+   * @param builder Builder for WebVTT Cues (output parameter).
+   * @param styles List of styles defined by the CSS style blocks preceding the cues.
    * @return Whether a valid Cue was found.
    */
-  public boolean parseCue(ParsableByteArray webvttData, WebvttCue.Builder builder,
-      List<WebvttCssStyle> styles) {
-    String firstLine = webvttData.readLine();
+  public boolean parseCue(
+      ParsableByteArray webvttData, WebvttCue.Builder builder, List<WebvttCssStyle> styles) {
+    @Nullable String firstLine = webvttData.readLine();
     if (firstLine == null) {
       return false;
     }
@@ -103,7 +102,7 @@ public final class WebvttCueParser {
       return parseCue(null, cueHeaderMatcher, webvttData, builder, textBuilder, styles);
     }
     // The first line is not the timestamps, but could be the cue id.
-    String secondLine = webvttData.readLine();
+    @Nullable String secondLine = webvttData.readLine();
     if (secondLine == null) {
       return false;
     }
@@ -152,11 +151,11 @@ public final class WebvttCueParser {
    *
    * @param id Id of the cue, {@code null} if it is not present.
    * @param markup The markup text to be parsed.
-   * @param styles List of styles defined by the CSS style blocks preceeding the cues.
+   * @param styles List of styles defined by the CSS style blocks preceding the cues.
    * @param builder Output builder.
    */
-  /* package */ static void parseCueText(String id, String markup, WebvttCue.Builder builder,
-      List<WebvttCssStyle> styles) {
+  /* package */ static void parseCueText(
+      @Nullable String id, String markup, WebvttCue.Builder builder, List<WebvttCssStyle> styles) {
     SpannableStringBuilder spannedText = new SpannableStringBuilder();
     ArrayDeque<StartTag> startTagStack = new ArrayDeque<>();
     List<StyleMatch> scratchStyleMatches = new ArrayList<>();
@@ -175,8 +174,11 @@ public final class WebvttCueParser {
           boolean isVoidTag = markup.charAt(pos - 2) == CHAR_SLASH;
           String fullTagExpression = markup.substring(ltPos + (isClosingTag ? 2 : 1),
               isVoidTag ? pos - 2 : pos - 1);
+          if (fullTagExpression.trim().isEmpty()) {
+            continue;
+          }
           String tagName = getTagName(fullTagExpression);
-          if (tagName == null || !isSupportedTag(tagName)) {
+          if (!isSupportedTag(tagName)) {
             continue;
           }
           if (isClosingTag) {
@@ -224,8 +226,13 @@ public final class WebvttCueParser {
     builder.setText(spannedText);
   }
 
-  private static boolean parseCue(String id, Matcher cueHeaderMatcher, ParsableByteArray webvttData,
-      WebvttCue.Builder builder, StringBuilder textBuilder, List<WebvttCssStyle> styles) {
+  private static boolean parseCue(
+      @Nullable String id,
+      Matcher cueHeaderMatcher,
+      ParsableByteArray webvttData,
+      WebvttCue.Builder builder,
+      StringBuilder textBuilder,
+      List<WebvttCssStyle> styles) {
     try {
       // Parse the cue start and end times.
       builder.setStartTime(WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(1)))
@@ -239,8 +246,9 @@ public final class WebvttCueParser {
 
     // Parse the cue text.
     textBuilder.setLength(0);
-    String line;
-    while (!TextUtils.isEmpty(line = webvttData.readLine())) {
+    for (String line = webvttData.readLine();
+        !TextUtils.isEmpty(line);
+        line = webvttData.readLine()) {
       if (textBuilder.length() > 0) {
         textBuilder.append("\n");
       }
@@ -252,14 +260,11 @@ public final class WebvttCueParser {
 
   // Internal methods
 
-  private static void parseLineAttribute(String s, WebvttCue.Builder builder)
-      throws NumberFormatException {
+  private static void parseLineAttribute(String s, WebvttCue.Builder builder) {
     int commaIndex = s.indexOf(',');
     if (commaIndex != -1) {
       builder.setLineAnchor(parsePositionAnchor(s.substring(commaIndex + 1)));
       s = s.substring(0, commaIndex);
-    } else {
-      builder.setLineAnchor(Cue.TYPE_UNSET);
     }
     if (s.endsWith("%")) {
       builder.setLine(WebvttParserUtil.parsePercentage(s)).setLineType(Cue.LINE_TYPE_FRACTION);
@@ -274,18 +279,16 @@ public final class WebvttCueParser {
     }
   }
 
-  private static void parsePositionAttribute(String s, WebvttCue.Builder builder)
-      throws NumberFormatException {
+  private static void parsePositionAttribute(String s, WebvttCue.Builder builder) {
     int commaIndex = s.indexOf(',');
     if (commaIndex != -1) {
       builder.setPositionAnchor(parsePositionAnchor(s.substring(commaIndex + 1)));
       s = s.substring(0, commaIndex);
-    } else {
-      builder.setPositionAnchor(Cue.TYPE_UNSET);
     }
     builder.setPosition(WebvttParserUtil.parsePercentage(s));
   }
 
+  @Cue.AnchorType
   private static int parsePositionAnchor(String s) {
     switch (s) {
       case "start":
@@ -301,20 +304,24 @@ public final class WebvttCueParser {
     }
   }
 
-  private static Alignment parseTextAlignment(String s) {
+  @WebvttCue.Builder.TextAlignment
+  private static int parseTextAlignment(String s) {
     switch (s) {
       case "start":
+        return WebvttCue.Builder.TEXT_ALIGNMENT_START;
       case "left":
-        return Alignment.ALIGN_NORMAL;
+        return WebvttCue.Builder.TEXT_ALIGNMENT_LEFT;
       case "center":
       case "middle":
-        return Alignment.ALIGN_CENTER;
+        return WebvttCue.Builder.TEXT_ALIGNMENT_CENTER;
       case "end":
+        return WebvttCue.Builder.TEXT_ALIGNMENT_END;
       case "right":
-        return Alignment.ALIGN_OPPOSITE;
+        return WebvttCue.Builder.TEXT_ALIGNMENT_RIGHT;
       default:
         Log.w(TAG, "Invalid alignment value: " + s);
-        return null;
+        // Default value: https://www.w3.org/TR/webvtt1/#webvtt-cue-text-alignment
+        return WebvttCue.Builder.TEXT_ALIGNMENT_CENTER;
     }
   }
 
@@ -364,8 +371,12 @@ public final class WebvttCueParser {
     }
   }
 
-  private static void applySpansForTag(String cueId, StartTag startTag, SpannableStringBuilder text,
-      List<WebvttCssStyle> styles, List<StyleMatch> scratchStyleMatches) {
+  private static void applySpansForTag(
+      @Nullable String cueId,
+      StartTag startTag,
+      SpannableStringBuilder text,
+      List<WebvttCssStyle> styles,
+      List<StyleMatch> scratchStyleMatches) {
     int start = startTag.position;
     int end = text.length();
     switch(startTag.name) {
@@ -423,9 +434,10 @@ public final class WebvttCueParser {
       spannedText.setSpan(new TypefaceSpan(style.getFontFamily()), start, end,
           Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
-    if (style.getTextAlign() != null) {
-      spannedText.setSpan(new AlignmentSpan.Standard(style.getTextAlign()), start, end,
-          Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+    Layout.Alignment textAlign = style.getTextAlign();
+    if (textAlign != null) {
+      spannedText.setSpan(
+          new AlignmentSpan.Standard(textAlign), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
     switch (style.getFontSizeUnit()) {
       case WebvttCssStyle.FONT_SIZE_UNIT_PIXEL:
@@ -454,14 +466,15 @@ public final class WebvttCueParser {
    */
   private static String getTagName(String tagExpression) {
     tagExpression = tagExpression.trim();
-    if (tagExpression.isEmpty()) {
-      return null;
-    }
+    Assertions.checkArgument(!tagExpression.isEmpty());
     return Util.splitAtFirst(tagExpression, "[ \\.]")[0];
   }
 
-  private static void getApplicableStyles(List<WebvttCssStyle> declaredStyles, String id,
-      StartTag tag, List<StyleMatch> output) {
+  private static void getApplicableStyles(
+      List<WebvttCssStyle> declaredStyles,
+      @Nullable String id,
+      StartTag tag,
+      List<StyleMatch> output) {
     int styleCount = declaredStyles.size();
     for (int i = 0; i < styleCount; i++) {
       WebvttCssStyle style = declaredStyles.get(i);
@@ -508,9 +521,7 @@ public final class WebvttCueParser {
 
     public static StartTag buildStartTag(String fullTagExpression, int position) {
       fullTagExpression = fullTagExpression.trim();
-      if (fullTagExpression.isEmpty()) {
-        return null;
-      }
+      Assertions.checkArgument(!fullTagExpression.isEmpty());
       int voiceStartIndex = fullTagExpression.indexOf(" ");
       String voice;
       if (voiceStartIndex == -1) {
@@ -523,7 +534,7 @@ public final class WebvttCueParser {
       String name = nameAndClasses[0];
       String[] classes;
       if (nameAndClasses.length > 1) {
-        classes = Arrays.copyOfRange(nameAndClasses, 1, nameAndClasses.length);
+        classes = Util.nullSafeArrayCopyOfRange(nameAndClasses, 1, nameAndClasses.length);
       } else {
         classes = NO_CLASSES;
       }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
index 22aee60..9075083 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttParserUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text.webvtt;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -26,7 +27,7 @@ import java.util.regex.Pattern;
  */
 public final class WebvttParserUtil {
 
-  private static final Pattern COMMENT = Pattern.compile("^NOTE((\u0020|\u0009).*)?$");
+  private static final Pattern COMMENT = Pattern.compile("^NOTE([ \t].*)?$");
   private static final String WEBVTT_HEADER = "WEBVTT";
 
   private WebvttParserUtil() {}
@@ -51,7 +52,7 @@ public final class WebvttParserUtil {
    * @param input The input from which the line should be read.
    */
   public static boolean isWebvttHeaderLine(ParsableByteArray input) {
-    String line = input.readLine();
+    @Nullable String line = input.readLine();
     return line != null && line.startsWith(WEBVTT_HEADER);
   }
 
@@ -98,8 +99,9 @@ public final class WebvttParserUtil {
    *     reached without a cue header being found. In the case that a cue header is found, groups 1,
    *     2 and 3 of the returned matcher contain the start time, end time and settings list.
    */
+  @Nullable
   public static Matcher findNextCueHeader(ParsableByteArray input) {
-    String line;
+    @Nullable String line;
     while ((line = input.readLine()) != null) {
       if (COMMENT.matcher(line).matches()) {
         // Skip until the end of the comment block.
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitle.java b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitle.java
index 1dd8000..2833ff2 100644
--- a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitle.java
+++ b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitle.java
@@ -23,7 +23,6 @@ import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -73,16 +72,16 @@ import java.util.List;
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    ArrayList<Cue> list = null;
+    List<Cue> list = new ArrayList<>();
     WebvttCue firstNormalCue = null;
     SpannableStringBuilder normalCueTextBuilder = null;
 
     for (int i = 0; i < numCues; i++) {
       if ((cueTimesUs[i * 2] <= timeUs) && (timeUs < cueTimesUs[i * 2 + 1])) {
-        if (list == null) {
-          list = new ArrayList<>();
-        }
         WebvttCue cue = cues.get(i);
+        // TODO(ibaker): Replace this with a closer implementation of the WebVTT spec (keeping
+        // individual cues, but tweaking their `line` value):
+        // https://www.w3.org/TR/webvtt1/#cue-computed-line
         if (cue.isNormalCue()) {
           // we want to merge all of the normal cues into a single cue to ensure they are drawn
           // correctly (i.e. don't overlap) and to emulate roll-up, but only if there are multiple
@@ -91,9 +90,12 @@ import java.util.List;
             firstNormalCue = cue;
           } else if (normalCueTextBuilder == null) {
             normalCueTextBuilder = new SpannableStringBuilder();
-            normalCueTextBuilder.append(firstNormalCue.text).append("\n").append(cue.text);
+            normalCueTextBuilder
+                .append(Assertions.checkNotNull(firstNormalCue.text))
+                .append("\n")
+                .append(Assertions.checkNotNull(cue.text));
           } else {
-            normalCueTextBuilder.append("\n").append(cue.text);
+            normalCueTextBuilder.append("\n").append(Assertions.checkNotNull(cue.text));
           }
         } else {
           list.add(cue);
@@ -102,17 +104,12 @@ import java.util.List;
     }
     if (normalCueTextBuilder != null) {
       // there were multiple normal cues, so create a new cue with all of the text
-      list.add(new WebvttCue(normalCueTextBuilder));
+      list.add(new WebvttCue.Builder().setText(normalCueTextBuilder).build());
     } else if (firstNormalCue != null) {
       // there was only a single normal cue, so just add it to the list
       list.add(firstNormalCue);
     }
-
-    if (list != null) {
-      return list;
-    } else {
-      return Collections.emptyList();
-    }
+    return list;
   }
 
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/text/webvtt/package-info.java b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/package-info.java
new file mode 100644
index 0000000..ee429b5
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/text/webvtt/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+@NonNullApi
+package com.google.android.exoplayer2.text.webvtt;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index fc3783d..3e8cdd1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -18,6 +18,7 @@ package com.google.android.exoplayer2.trackselection;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
@@ -285,7 +286,7 @@ public class AdaptiveTrackSelection extends BaseTrackSelection {
   public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
   public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
   public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
-  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;
+  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.7f;
   public static final float DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE = 0.75f;
   public static final long DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS = 2000;
 
@@ -609,13 +610,18 @@ public class AdaptiveTrackSelection extends BaseTrackSelection {
 
     @Nullable private long[][] allocationCheckpoints;
 
-    /* package */ DefaultBandwidthProvider(
+    /* package */
+    // the constructor does not initialize fields: allocationCheckpoints
+    @SuppressWarnings("nullness:initialization.fields.uninitialized")
+    DefaultBandwidthProvider(
         BandwidthMeter bandwidthMeter, float bandwidthFraction, long reservedBandwidth) {
       this.bandwidthMeter = bandwidthMeter;
       this.bandwidthFraction = bandwidthFraction;
       this.reservedBandwidth = reservedBandwidth;
     }
 
+    // unboxing a possibly-null reference allocationCheckpoints[nextIndex][0]
+    @SuppressWarnings("nullness:unboxing.of.nullable")
     @Override
     public long getAllocatedBandwidth() {
       long totalBandwidth = (long) (bandwidthMeter.getBitrateEstimate() * bandwidthFraction);
diff --git a/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index c36f23c..9982ce5 100644
--- a/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -30,6 +30,9 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererCapabilities.AdaptiveSupport;
+import com.google.android.exoplayer2.RendererCapabilities.Capabilities;
+import com.google.android.exoplayer2.RendererCapabilities.FormatSupport;
 import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -184,7 +187,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     private boolean exceedRendererCapabilitiesIfNecessary;
     private int tunnelingAudioSessionId;
 
-    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
+    private final SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>>
+        selectionOverrides;
     private final SparseBooleanArray rendererDisabledFlags;
 
     /**
@@ -646,8 +650,9 @@ public class DefaultTrackSelector extends MappingTrackSelector {
      * @return This builder.
      */
     public final ParametersBuilder setSelectionOverride(
-        int rendererIndex, TrackGroupArray groups, SelectionOverride override) {
-      Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+        int rendererIndex, TrackGroupArray groups, @Nullable SelectionOverride override) {
+      Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+          selectionOverrides.get(rendererIndex);
       if (overrides == null) {
         overrides = new HashMap<>();
         selectionOverrides.put(rendererIndex, overrides);
@@ -669,7 +674,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
      */
     public final ParametersBuilder clearSelectionOverride(
         int rendererIndex, TrackGroupArray groups) {
-      Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+      Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+          selectionOverrides.get(rendererIndex);
       if (overrides == null || !overrides.containsKey(groups)) {
         // Nothing to clear.
         return this;
@@ -688,7 +694,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
      * @return This builder.
      */
     public final ParametersBuilder clearSelectionOverrides(int rendererIndex) {
-      Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+      Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+          selectionOverrides.get(rendererIndex);
       if (overrides == null || overrides.isEmpty()) {
         // Nothing to clear.
         return this;
@@ -775,9 +782,11 @@ public class DefaultTrackSelector extends MappingTrackSelector {
       tunnelingAudioSessionId = C.AUDIO_SESSION_ID_UNSET;
     }
 
-    private static SparseArray<Map<TrackGroupArray, SelectionOverride>> cloneSelectionOverrides(
-        SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides) {
-      SparseArray<Map<TrackGroupArray, SelectionOverride>> clone = new SparseArray<>();
+    private static SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>>
+        cloneSelectionOverrides(
+            SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> selectionOverrides) {
+      SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> clone =
+          new SparseArray<>();
       for (int i = 0; i < selectionOverrides.size(); i++) {
         clone.put(selectionOverrides.keyAt(i), new HashMap<>(selectionOverrides.valueAt(i)));
       }
@@ -820,7 +829,6 @@ public class DefaultTrackSelector extends MappingTrackSelector {
      * @deprecated This instance does not have {@link Context} constraints configured. Use {@link
      *     #getDefaults(Context)} instead.
      */
-    @SuppressWarnings("deprecation")
     @Deprecated
     public static final Parameters DEFAULT = DEFAULT_WITHOUT_CONTEXT;
 
@@ -963,7 +971,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     public final int tunnelingAudioSessionId;
 
     // Overrides
-    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
+    private final SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>>
+        selectionOverrides;
     private final SparseBooleanArray rendererDisabledFlags;
 
     /* package */ Parameters(
@@ -997,7 +1006,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
         boolean exceedRendererCapabilitiesIfNecessary,
         int tunnelingAudioSessionId,
         // Overrides
-        SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides,
+        SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> selectionOverrides,
         SparseBooleanArray rendererDisabledFlags) {
       super(
           preferredAudioLanguage,
@@ -1088,7 +1097,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
      * @return Whether there is an override.
      */
     public final boolean hasSelectionOverride(int rendererIndex, TrackGroupArray groups) {
-      Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+      Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+          selectionOverrides.get(rendererIndex);
       return overrides != null && overrides.containsKey(groups);
     }
 
@@ -1101,7 +1111,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
      */
     @Nullable
     public final SelectionOverride getSelectionOverride(int rendererIndex, TrackGroupArray groups) {
-      Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+      Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+          selectionOverrides.get(rendererIndex);
       return overrides != null ? overrides.get(groups) : null;
     }
 
@@ -1234,17 +1245,20 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
     // Static utility methods.
 
-    private static SparseArray<Map<TrackGroupArray, SelectionOverride>> readSelectionOverrides(
-        Parcel in) {
+    private static SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>>
+        readSelectionOverrides(Parcel in) {
       int renderersWithOverridesCount = in.readInt();
-      SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides =
+      SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> selectionOverrides =
           new SparseArray<>(renderersWithOverridesCount);
       for (int i = 0; i < renderersWithOverridesCount; i++) {
         int rendererIndex = in.readInt();
         int overrideCount = in.readInt();
-        Map<TrackGroupArray, SelectionOverride> overrides = new HashMap<>(overrideCount);
+        Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+            new HashMap<>(overrideCount);
         for (int j = 0; j < overrideCount; j++) {
-          TrackGroupArray trackGroups = in.readParcelable(TrackGroupArray.class.getClassLoader());
+          TrackGroupArray trackGroups =
+              Assertions.checkNotNull(in.readParcelable(TrackGroupArray.class.getClassLoader()));
+          @Nullable
           SelectionOverride override = in.readParcelable(SelectionOverride.class.getClassLoader());
           overrides.put(trackGroups, override);
         }
@@ -1254,16 +1268,19 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     }
 
     private static void writeSelectionOverridesToParcel(
-        Parcel dest, SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides) {
+        Parcel dest,
+        SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> selectionOverrides) {
       int renderersWithOverridesCount = selectionOverrides.size();
       dest.writeInt(renderersWithOverridesCount);
       for (int i = 0; i < renderersWithOverridesCount; i++) {
         int rendererIndex = selectionOverrides.keyAt(i);
-        Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.valueAt(i);
+        Map<TrackGroupArray, @NullableType SelectionOverride> overrides =
+            selectionOverrides.valueAt(i);
         int overrideCount = overrides.size();
         dest.writeInt(rendererIndex);
         dest.writeInt(overrideCount);
-        for (Map.Entry<TrackGroupArray, SelectionOverride> override : overrides.entrySet()) {
+        for (Map.Entry<TrackGroupArray, @NullableType SelectionOverride> override :
+            overrides.entrySet()) {
           dest.writeParcelable(override.getKey(), /* parcelableFlags= */ 0);
           dest.writeParcelable(override.getValue(), /* parcelableFlags= */ 0);
         }
@@ -1286,8 +1303,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     }
 
     private static boolean areSelectionOverridesEqual(
-        SparseArray<Map<TrackGroupArray, SelectionOverride>> first,
-        SparseArray<Map<TrackGroupArray, SelectionOverride>> second) {
+        SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> first,
+        SparseArray<Map<TrackGroupArray, @NullableType SelectionOverride>> second) {
       int firstSize = first.size();
       if (second.size() != firstSize) {
         return false;
@@ -1304,13 +1321,14 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     }
 
     private static boolean areSelectionOverridesEqual(
-        Map<TrackGroupArray, SelectionOverride> first,
-        Map<TrackGroupArray, SelectionOverride> second) {
+        Map<TrackGroupArray, @NullableType SelectionOverride> first,
+        Map<TrackGroupArray, @NullableType SelectionOverride> second) {
       int firstSize = first.size();
       if (second.size() != firstSize) {
         return false;
       }
-      for (Map.Entry<TrackGroupArray, SelectionOverride> firstEntry : first.entrySet()) {
+      for (Map.Entry<TrackGroupArray, @NullableType SelectionOverride> firstEntry :
+          first.entrySet()) {
         TrackGroupArray key = firstEntry.getKey();
         if (!second.containsKey(key) || !Util.areEqual(firstEntry.getValue(), second.get(key))) {
           return false;
@@ -1458,7 +1476,6 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   /** @deprecated Use {@link #DefaultTrackSelector(Context, TrackSelection.Factory)}. */
   @Deprecated
-  @SuppressWarnings("deprecation")
   public DefaultTrackSelector(TrackSelection.Factory trackSelectionFactory) {
     this(Parameters.DEFAULT_WITHOUT_CONTEXT, trackSelectionFactory);
   }
@@ -1526,7 +1543,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     setParameters(buildUponParameters().setRendererDisabled(rendererIndex, disabled));
   }
 
-  /** @deprecated Use {@link Parameters#getRendererDisabled(int)}. * */
+  /** @deprecated Use {@link Parameters#getRendererDisabled(int)}. */
   @Deprecated
   public final boolean getRendererDisabled(int rendererIndex) {
     return getParameters().getRendererDisabled(rendererIndex);
@@ -1538,11 +1555,11 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    */
   @Deprecated
   public final void setSelectionOverride(
-      int rendererIndex, TrackGroupArray groups, SelectionOverride override) {
+      int rendererIndex, TrackGroupArray groups, @Nullable SelectionOverride override) {
     setParameters(buildUponParameters().setSelectionOverride(rendererIndex, groups, override));
   }
 
-  /** @deprecated Use {@link Parameters#hasSelectionOverride(int, TrackGroupArray)}. * */
+  /** @deprecated Use {@link Parameters#hasSelectionOverride(int, TrackGroupArray)}. */
   @Deprecated
   public final boolean hasSelectionOverride(int rendererIndex, TrackGroupArray groups) {
     return getParameters().hasSelectionOverride(rendererIndex, groups);
@@ -1594,8 +1611,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   protected final Pair<@NullableType RendererConfiguration[], @NullableType TrackSelection[]>
       selectTracks(
           MappedTrackInfo mappedTrackInfo,
-          int[][][] rendererFormatSupports,
-          int[] rendererMixedMimeTypeAdaptationSupports)
+          @Capabilities int[][][] rendererFormatSupports,
+          @AdaptiveSupport int[] rendererMixedMimeTypeAdaptationSupports)
           throws ExoPlaybackException {
     Parameters params = parametersReference.get();
     int rendererCount = mappedTrackInfo.getRendererCount();
@@ -1664,18 +1681,18 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    * generated by this method will be overridden to account for these properties.
    *
    * @param mappedTrackInfo Mapped track information.
-   * @param rendererFormatSupports The result of {@link RendererCapabilities#supportsFormat} for
-   *     each mapped track, indexed by renderer, track group and track (in that order).
-   * @param rendererMixedMimeTypeAdaptationSupports The result of {@link
-   *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
+   * @param rendererFormatSupports The {@link Capabilities} for each mapped track, indexed by
+   *     renderer, track group and track (in that order).
+   * @param rendererMixedMimeTypeAdaptationSupports The {@link AdaptiveSupport} for mixed MIME type
+   *     adaptation for the renderer.
    * @return The {@link TrackSelection.Definition}s for the renderers. A null entry indicates no
    *     selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
   protected TrackSelection.@NullableType Definition[] selectAllTracks(
       MappedTrackInfo mappedTrackInfo,
-      int[][][] rendererFormatSupports,
-      int[] rendererMixedMimeTypeAdaptationSupports,
+      @Capabilities int[][][] rendererFormatSupports,
+      @AdaptiveSupport int[] rendererMixedMimeTypeAdaptationSupports,
       Parameters params)
       throws ExoPlaybackException {
     int rendererCount = mappedTrackInfo.getRendererCount();
@@ -1779,10 +1796,10 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    * {@link TrackSelection} for a video renderer.
    *
    * @param groups The {@link TrackGroupArray} mapped to the renderer.
-   * @param formatSupports The result of {@link RendererCapabilities#supportsFormat} for each mapped
-   *     track, indexed by track group index and track index (in that order).
-   * @param mixedMimeTypeAdaptationSupports The result of {@link
-   *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for the renderer.
+   * @param formatSupports The {@link Capabilities} for each mapped track, indexed by renderer,
+   *     track group and track (in that order).
+   * @param mixedMimeTypeAdaptationSupports The {@link AdaptiveSupport} for mixed MIME type
+   *     adaptation for the renderer.
    * @param params The selector's current constraint parameters.
    * @param enableAdaptiveTrackSelection Whether adaptive track selection is allowed.
    * @return The {@link TrackSelection.Definition} for the renderer, or null if no selection was
@@ -1792,8 +1809,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   @Nullable
   protected TrackSelection.Definition selectVideoTrack(
       TrackGroupArray groups,
-      int[][] formatSupports,
-      int mixedMimeTypeAdaptationSupports,
+      @Capabilities int[][] formatSupports,
+      @AdaptiveSupport int mixedMimeTypeAdaptationSupports,
       Parameters params,
       boolean enableAdaptiveTrackSelection)
       throws ExoPlaybackException {
@@ -1813,8 +1830,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   @Nullable
   private static TrackSelection.Definition selectAdaptiveVideoTrack(
       TrackGroupArray groups,
-      int[][] formatSupport,
-      int mixedMimeTypeAdaptationSupports,
+      @Capabilities int[][] formatSupport,
+      @AdaptiveSupport int mixedMimeTypeAdaptationSupports,
       Parameters params) {
     int requiredAdaptiveSupport =
         params.allowVideoNonSeamlessAdaptiveness
@@ -1847,7 +1864,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   private static int[] getAdaptiveVideoTracksForGroup(
       TrackGroup group,
-      int[] formatSupport,
+      @Capabilities int[] formatSupport,
       boolean allowMixedMimeTypes,
       int requiredAdaptiveSupport,
       int maxVideoWidth,
@@ -1912,7 +1929,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   private static int getAdaptiveVideoTrackCountForMimeType(
       TrackGroup group,
-      int[] formatSupport,
+      @Capabilities int[] formatSupport,
       int requiredAdaptiveSupport,
       @Nullable String mimeType,
       int maxVideoWidth,
@@ -1940,7 +1957,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   private static void filterAdaptiveVideoTrackCountForMimeType(
       TrackGroup group,
-      int[] formatSupport,
+      @Capabilities int[] formatSupport,
       int requiredAdaptiveSupport,
       @Nullable String mimeType,
       int maxVideoWidth,
@@ -1967,7 +1984,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   private static boolean isSupportedAdaptiveVideoTrack(
       Format format,
       @Nullable String mimeType,
-      int formatSupport,
+      @Capabilities int formatSupport,
       int requiredAdaptiveSupport,
       int maxVideoWidth,
       int maxVideoHeight,
@@ -1984,7 +2001,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   @Nullable
   private static TrackSelection.Definition selectFixedVideoTrack(
-      TrackGroupArray groups, int[][] formatSupports, Parameters params) {
+      TrackGroupArray groups, @Capabilities int[][] formatSupports, Parameters params) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
@@ -1994,7 +2011,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
       TrackGroup trackGroup = groups.get(groupIndex);
       List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(trackGroup,
           params.viewportWidth, params.viewportHeight, params.viewportOrientationMayChange);
-      int[] trackFormatSupport = formatSupports[groupIndex];
+      @Capabilities int[] trackFormatSupport = formatSupports[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
@@ -2057,10 +2074,10 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    * {@link TrackSelection} for an audio renderer.
    *
    * @param groups The {@link TrackGroupArray} mapped to the renderer.
-   * @param formatSupports The result of {@link RendererCapabilities#supportsFormat} for each mapped
-   *     track, indexed by track group index and track index (in that order).
-   * @param mixedMimeTypeAdaptationSupports The result of {@link
-   *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for the renderer.
+   * @param formatSupports The {@link Capabilities} for each mapped track, indexed by renderer,
+   *     track group and track (in that order).
+   * @param mixedMimeTypeAdaptationSupports The {@link AdaptiveSupport} for mixed MIME type
+   *     adaptation for the renderer.
    * @param params The selector's current constraint parameters.
    * @param enableAdaptiveTrackSelection Whether adaptive track selection is allowed.
    * @return The {@link TrackSelection.Definition} and corresponding {@link AudioTrackScore}, or
@@ -2071,8 +2088,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   @Nullable
   protected Pair<TrackSelection.Definition, AudioTrackScore> selectAudioTrack(
       TrackGroupArray groups,
-      int[][] formatSupports,
-      int mixedMimeTypeAdaptationSupports,
+      @Capabilities int[][] formatSupports,
+      @AdaptiveSupport int mixedMimeTypeAdaptationSupports,
       Parameters params,
       boolean enableAdaptiveTrackSelection)
       throws ExoPlaybackException {
@@ -2081,7 +2098,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     AudioTrackScore selectedTrackScore = null;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
-      int[] trackFormatSupport = formatSupports[groupIndex];
+      @Capabilities int[] trackFormatSupport = formatSupports[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
@@ -2134,7 +2151,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   private static int[] getAdaptiveAudioTracks(
       TrackGroup group,
-      int[] formatSupport,
+      @Capabilities int[] formatSupport,
       int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
       boolean allowMixedSampleRateAdaptiveness,
@@ -2188,7 +2205,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   private static int getAdaptiveAudioTrackCount(
       TrackGroup group,
-      int[] formatSupport,
+      @Capabilities int[] formatSupport,
       AudioConfigurationTuple configuration,
       int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
@@ -2212,7 +2229,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   private static boolean isSupportedAdaptiveAudioTrack(
       Format format,
-      int formatSupport,
+      @Capabilities int formatSupport,
       AudioConfigurationTuple configuration,
       int maxAudioBitrate,
       boolean allowMixedMimeTypeAdaptiveness,
@@ -2238,8 +2255,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    * {@link TrackSelection} for a text renderer.
    *
    * @param groups The {@link TrackGroupArray} mapped to the renderer.
-   * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each mapped
-   *     track, indexed by track group index and track index (in that order).
+   * @param formatSupport The {@link Capabilities} for each mapped track, indexed by renderer, track
+   *     group and track (in that order).
    * @param params The selector's current constraint parameters.
    * @param selectedAudioLanguage The language of the selected audio track. May be null if the
    *     selected text track declares no language or no text track was selected.
@@ -2250,7 +2267,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   @Nullable
   protected Pair<TrackSelection.Definition, TextTrackScore> selectTextTrack(
       TrackGroupArray groups,
-      int[][] formatSupport,
+      @Capabilities int[][] formatSupport,
       Parameters params,
       @Nullable String selectedAudioLanguage)
       throws ExoPlaybackException {
@@ -2259,7 +2276,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     TextTrackScore selectedTrackScore = null;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
-      int[] trackFormatSupport = formatSupport[groupIndex];
+      @Capabilities int[] trackFormatSupport = formatSupport[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
@@ -2291,22 +2308,22 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    *
    * @param trackType The type of the renderer.
    * @param groups The {@link TrackGroupArray} mapped to the renderer.
-   * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each mapped
-   *     track, indexed by track group index and track index (in that order).
+   * @param formatSupport The {@link Capabilities} for each mapped track, indexed by renderer, track
+   *     group and track (in that order).
    * @param params The selector's current constraint parameters.
    * @return The {@link TrackSelection} for the renderer, or null if no selection was made.
    * @throws ExoPlaybackException If an error occurs while selecting the tracks.
    */
   @Nullable
   protected TrackSelection.Definition selectOtherTrack(
-      int trackType, TrackGroupArray groups, int[][] formatSupport, Parameters params)
+      int trackType, TrackGroupArray groups, @Capabilities int[][] formatSupport, Parameters params)
       throws ExoPlaybackException {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
-      int[] trackFormatSupport = formatSupport[groupIndex];
+      @Capabilities int[] trackFormatSupport = formatSupport[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
@@ -2337,6 +2354,8 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    * renderers if so.
    *
    * @param mappedTrackInfo Mapped track information.
+   * @param renderererFormatSupports The {@link Capabilities} for each mapped track, indexed by
+   *     renderer, track group and track (in that order).
    * @param rendererConfigurations The renderer configurations. Configurations may be replaced with
    *     ones that enable tunneling as a result of this call.
    * @param trackSelections The renderer track selections.
@@ -2345,7 +2364,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
    */
   private static void maybeConfigureRenderersForTunneling(
       MappedTrackInfo mappedTrackInfo,
-      int[][][] renderererFormatSupports,
+      @Capabilities int[][][] renderererFormatSupports,
       @NullableType RendererConfiguration[] rendererConfigurations,
       @NullableType TrackSelection[] trackSelections,
       int tunnelingAudioSessionId) {
@@ -2394,21 +2413,22 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   /**
    * Returns whether a renderer supports tunneling for a {@link TrackSelection}.
    *
-   * @param formatSupports The result of {@link RendererCapabilities#supportsFormat} for each track,
-   *     indexed by group index and track index (in that order).
+   * @param formatSupports The {@link Capabilities} for each track, indexed by group index and track
+   *     index (in that order).
    * @param trackGroups The {@link TrackGroupArray}s for the renderer.
    * @param selection The track selection.
    * @return Whether the renderer supports tunneling for the {@link TrackSelection}.
    */
   private static boolean rendererSupportsTunneling(
-      int[][] formatSupports, TrackGroupArray trackGroups, TrackSelection selection) {
+      @Capabilities int[][] formatSupports, TrackGroupArray trackGroups, TrackSelection selection) {
     if (selection == null) {
       return false;
     }
     int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
     for (int i = 0; i < selection.length(); i++) {
+      @Capabilities
       int trackFormatSupport = formatSupports[trackGroupIndex][selection.getIndexInTrackGroup(i)];
-      if ((trackFormatSupport & RendererCapabilities.TUNNELING_SUPPORT_MASK)
+      if (RendererCapabilities.getTunnelingSupport(trackFormatSupport)
           != RendererCapabilities.TUNNELING_SUPPORTED) {
         return false;
       }
@@ -2432,20 +2452,20 @@ public class DefaultTrackSelector extends MappingTrackSelector {
   }
 
   /**
-   * Applies the {@link RendererCapabilities#FORMAT_SUPPORT_MASK} to a value obtained from
-   * {@link RendererCapabilities#supportsFormat(Format)}, returning true if the result is
-   * {@link RendererCapabilities#FORMAT_HANDLED} or if {@code allowExceedsCapabilities} is set
-   * and the result is {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}.
+   * Returns true if the {@link FormatSupport} in the given {@link Capabilities} is {@link
+   * RendererCapabilities#FORMAT_HANDLED} or if {@code allowExceedsCapabilities} is set and the
+   * format support is {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}.
    *
-   * @param formatSupport A value obtained from {@link RendererCapabilities#supportsFormat(Format)}.
-   * @param allowExceedsCapabilities Whether to return true if the format support component of the
-   *     value is {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}.
-   * @return True if the format support component is {@link RendererCapabilities#FORMAT_HANDLED}, or
-   *     if {@code allowExceedsCapabilities} is set and the format support component is
-   *     {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}.
+   * @param formatSupport {@link Capabilities}.
+   * @param allowExceedsCapabilities Whether to return true if {@link FormatSupport} is {@link
+   *     RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}.
+   * @return True if {@link FormatSupport} is {@link RendererCapabilities#FORMAT_HANDLED}, or if
+   *     {@code allowExceedsCapabilities} is set and the format support is {@link
+   *     RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}.
    */
-  protected static boolean isSupported(int formatSupport, boolean allowExceedsCapabilities) {
-    int maskedSupport = formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK;
+  protected static boolean isSupported(
+      @Capabilities int formatSupport, boolean allowExceedsCapabilities) {
+    @FormatSupport int maskedSupport = RendererCapabilities.getFormatSupport(formatSupport);
     return maskedSupport == RendererCapabilities.FORMAT_HANDLED || (allowExceedsCapabilities
         && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
   }
@@ -2601,7 +2621,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     private final int sampleRate;
     private final int bitrate;
 
-    public AudioTrackScore(Format format, Parameters parameters, int formatSupport) {
+    public AudioTrackScore(Format format, Parameters parameters, @Capabilities int formatSupport) {
       this.parameters = parameters;
       this.language = normalizeUndeterminedLanguageToNull(format.language);
       isWithinRendererCapabilities = isSupported(formatSupport, false);
@@ -2740,7 +2760,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     public TextTrackScore(
         Format format,
         Parameters parameters,
-        int trackFormatSupport,
+        @Capabilities int trackFormatSupport,
         @Nullable String selectedAudioLanguage) {
       isWithinRendererCapabilities =
           isSupported(trackFormatSupport, /* allowExceedsCapabilities= */ false);
diff --git a/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 425da6c..9c6b240 100644
--- a/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -22,6 +22,9 @@ import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererCapabilities.AdaptiveSupport;
+import com.google.android.exoplayer2.RendererCapabilities.Capabilities;
+import com.google.android.exoplayer2.RendererCapabilities.FormatSupport;
 import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
@@ -90,25 +93,25 @@ public abstract class MappingTrackSelector extends TrackSelector {
     private final int rendererCount;
     private final int[] rendererTrackTypes;
     private final TrackGroupArray[] rendererTrackGroups;
-    private final int[] rendererMixedMimeTypeAdaptiveSupports;
-    private final int[][][] rendererFormatSupports;
+    @AdaptiveSupport private final int[] rendererMixedMimeTypeAdaptiveSupports;
+    @Capabilities private final int[][][] rendererFormatSupports;
     private final TrackGroupArray unmappedTrackGroups;
 
     /**
      * @param rendererTrackTypes The track type handled by each renderer.
      * @param rendererTrackGroups The {@link TrackGroup}s mapped to each renderer.
-     * @param rendererMixedMimeTypeAdaptiveSupports The result of {@link
-     *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
-     * @param rendererFormatSupports The result of {@link RendererCapabilities#supportsFormat} for
-     *     each mapped track, indexed by renderer, track group and track (in that order).
+     * @param rendererMixedMimeTypeAdaptiveSupports The {@link AdaptiveSupport} for mixed MIME type
+     *     adaptation for the renderer.
+     * @param rendererFormatSupports The {@link Capabilities} for each mapped track, indexed by
+     *     renderer, track group and track (in that order).
      * @param unmappedTrackGroups {@link TrackGroup}s not mapped to any renderer.
      */
     @SuppressWarnings("deprecation")
     /* package */ MappedTrackInfo(
         int[] rendererTrackTypes,
         TrackGroupArray[] rendererTrackGroups,
-        int[] rendererMixedMimeTypeAdaptiveSupports,
-        int[][][] rendererFormatSupports,
+        @AdaptiveSupport int[] rendererMixedMimeTypeAdaptiveSupports,
+        @Capabilities int[][][] rendererFormatSupports,
         TrackGroupArray unmappedTrackGroups) {
       this.rendererTrackTypes = rendererTrackTypes;
       this.rendererTrackGroups = rendererTrackGroups;
@@ -149,25 +152,28 @@ public abstract class MappingTrackSelector extends TrackSelector {
      * Returns the extent to which a renderer can play the tracks that are mapped to it.
      *
      * @param rendererIndex The renderer index.
-     * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS}, {@link
-     *     #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS}, {@link
-     *     #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+     * @return The {@link RendererSupport}.
      */
-    public @RendererSupport int getRendererSupport(int rendererIndex) {
-      int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
-      int[][] rendererFormatSupport = rendererFormatSupports[rendererIndex];
-      for (int[] trackGroupFormatSupport : rendererFormatSupport) {
-        for (int trackFormatSupport : trackGroupFormatSupport) {
+    @RendererSupport
+    public int getRendererSupport(int rendererIndex) {
+      @RendererSupport int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
+      @Capabilities int[][] rendererFormatSupport = rendererFormatSupports[rendererIndex];
+      for (@Capabilities int[] trackGroupFormatSupport : rendererFormatSupport) {
+        for (@Capabilities int trackFormatSupport : trackGroupFormatSupport) {
           int trackRendererSupport;
-          switch (trackFormatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK) {
+          switch (RendererCapabilities.getFormatSupport(trackFormatSupport)) {
             case RendererCapabilities.FORMAT_HANDLED:
               return RENDERER_SUPPORT_PLAYABLE_TRACKS;
             case RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES:
               trackRendererSupport = RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS;
               break;
-            default:
+            case RendererCapabilities.FORMAT_UNSUPPORTED_TYPE:
+            case RendererCapabilities.FORMAT_UNSUPPORTED_SUBTYPE:
+            case RendererCapabilities.FORMAT_UNSUPPORTED_DRM:
               trackRendererSupport = RENDERER_SUPPORT_UNSUPPORTED_TRACKS;
               break;
+            default:
+              throw new IllegalStateException();
           }
           bestRendererSupport = Math.max(bestRendererSupport, trackRendererSupport);
         }
@@ -177,7 +183,8 @@ public abstract class MappingTrackSelector extends TrackSelector {
 
     /** @deprecated Use {@link #getTypeSupport(int)}. */
     @Deprecated
-    public @RendererSupport int getTrackTypeRendererSupport(int trackType) {
+    @RendererSupport
+    public int getTrackTypeRendererSupport(int trackType) {
       return getTypeSupport(trackType);
     }
 
@@ -188,12 +195,11 @@ public abstract class MappingTrackSelector extends TrackSelector {
      * returned.
      *
      * @param trackType The track type. One of the {@link C} {@code TRACK_TYPE_*} constants.
-     * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS}, {@link
-     *     #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS}, {@link
-     *     #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+     * @return The {@link RendererSupport}.
      */
-    public @RendererSupport int getTypeSupport(int trackType) {
-      int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
+    @RendererSupport
+    public int getTypeSupport(int trackType) {
+      @RendererSupport int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
       for (int i = 0; i < rendererCount; i++) {
         if (rendererTrackTypes[i] == trackType) {
           bestRendererSupport = Math.max(bestRendererSupport, getRendererSupport(i));
@@ -204,6 +210,7 @@ public abstract class MappingTrackSelector extends TrackSelector {
 
     /** @deprecated Use {@link #getTrackSupport(int, int, int)}. */
     @Deprecated
+    @FormatSupport
     public int getTrackFormatSupport(int rendererIndex, int groupIndex, int trackIndex) {
       return getTrackSupport(rendererIndex, groupIndex, trackIndex);
     }
@@ -214,15 +221,12 @@ public abstract class MappingTrackSelector extends TrackSelector {
      * @param rendererIndex The renderer index.
      * @param groupIndex The index of the track group to which the track belongs.
      * @param trackIndex The index of the track within the track group.
-     * @return One of {@link RendererCapabilities#FORMAT_HANDLED}, {@link
-     *     RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES}, {@link
-     *     RendererCapabilities#FORMAT_UNSUPPORTED_DRM}, {@link
-     *     RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} and {@link
-     *     RendererCapabilities#FORMAT_UNSUPPORTED_TYPE}.
+     * @return The {@link FormatSupport}.
      */
+    @FormatSupport
     public int getTrackSupport(int rendererIndex, int groupIndex, int trackIndex) {
-      return rendererFormatSupports[rendererIndex][groupIndex][trackIndex]
-          & RendererCapabilities.FORMAT_SUPPORT_MASK;
+      return RendererCapabilities.getFormatSupport(
+          rendererFormatSupports[rendererIndex][groupIndex][trackIndex]);
     }
 
     /**
@@ -242,10 +246,9 @@ public abstract class MappingTrackSelector extends TrackSelector {
      * @param groupIndex The index of the track group.
      * @param includeCapabilitiesExceededTracks Whether tracks that exceed the capabilities of the
      *     renderer are included when determining support.
-     * @return One of {@link RendererCapabilities#ADAPTIVE_SEAMLESS}, {@link
-     *     RendererCapabilities#ADAPTIVE_NOT_SEAMLESS} and {@link
-     *     RendererCapabilities#ADAPTIVE_NOT_SUPPORTED}.
+     * @return The {@link AdaptiveSupport}.
      */
+    @AdaptiveSupport
     public int getAdaptiveSupport(
         int rendererIndex, int groupIndex, boolean includeCapabilitiesExceededTracks) {
       int trackCount = rendererTrackGroups[rendererIndex].get(groupIndex).length;
@@ -253,7 +256,7 @@ public abstract class MappingTrackSelector extends TrackSelector {
       int[] trackIndices = new int[trackCount];
       int trackIndexCount = 0;
       for (int i = 0; i < trackCount; i++) {
-        int fixedSupport = getTrackSupport(rendererIndex, groupIndex, i);
+        @FormatSupport int fixedSupport = getTrackSupport(rendererIndex, groupIndex, i);
         if (fixedSupport == RendererCapabilities.FORMAT_HANDLED
             || (includeCapabilitiesExceededTracks
             && fixedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES)) {
@@ -270,13 +273,12 @@ public abstract class MappingTrackSelector extends TrackSelector {
      *
      * @param rendererIndex The renderer index.
      * @param groupIndex The index of the track group.
-     * @return One of {@link RendererCapabilities#ADAPTIVE_SEAMLESS}, {@link
-     *     RendererCapabilities#ADAPTIVE_NOT_SEAMLESS} and {@link
-     *     RendererCapabilities#ADAPTIVE_NOT_SUPPORTED}.
+     * @return The {@link AdaptiveSupport}.
      */
+    @AdaptiveSupport
     public int getAdaptiveSupport(int rendererIndex, int groupIndex, int[] trackIndices) {
       int handledTrackCount = 0;
-      int adaptiveSupport = RendererCapabilities.ADAPTIVE_SEAMLESS;
+      @AdaptiveSupport int adaptiveSupport = RendererCapabilities.ADAPTIVE_SEAMLESS;
       boolean multipleMimeTypes = false;
       String firstSampleMimeType = null;
       for (int i = 0; i < trackIndices.length; i++) {
@@ -291,8 +293,8 @@ public abstract class MappingTrackSelector extends TrackSelector {
         adaptiveSupport =
             Math.min(
                 adaptiveSupport,
-                rendererFormatSupports[rendererIndex][groupIndex][i]
-                    & RendererCapabilities.ADAPTIVE_SUPPORT_MASK);
+                RendererCapabilities.getAdaptiveSupport(
+                    rendererFormatSupports[rendererIndex][groupIndex][i]));
       }
       return multipleMimeTypes
           ? Math.min(adaptiveSupport, rendererMixedMimeTypeAdaptiveSupports[rendererIndex])
@@ -341,13 +343,14 @@ public abstract class MappingTrackSelector extends TrackSelector {
     // any renderer.
     int[] rendererTrackGroupCounts = new int[rendererCapabilities.length + 1];
     TrackGroup[][] rendererTrackGroups = new TrackGroup[rendererCapabilities.length + 1][];
-    int[][][] rendererFormatSupports = new int[rendererCapabilities.length + 1][][];
+    @Capabilities int[][][] rendererFormatSupports = new int[rendererCapabilities.length + 1][][];
     for (int i = 0; i < rendererTrackGroups.length; i++) {
       rendererTrackGroups[i] = new TrackGroup[trackGroups.length];
       rendererFormatSupports[i] = new int[trackGroups.length][];
     }
 
     // Determine the extent to which each renderer supports mixed mimeType adaptation.
+    @AdaptiveSupport
     int[] rendererMixedMimeTypeAdaptationSupports =
         getMixedMimeTypeAdaptationSupports(rendererCapabilities);
 
@@ -358,8 +361,11 @@ public abstract class MappingTrackSelector extends TrackSelector {
       // Associate the group to a preferred renderer.
       int rendererIndex = findRenderer(rendererCapabilities, group);
       // Evaluate the support that the renderer provides for each track in the group.
-      int[] rendererFormatSupport = rendererIndex == rendererCapabilities.length
-          ? new int[group.length] : getFormatSupport(rendererCapabilities[rendererIndex], group);
+      @Capabilities
+      int[] rendererFormatSupport =
+          rendererIndex == rendererCapabilities.length
+              ? new int[group.length]
+              : getFormatSupport(rendererCapabilities[rendererIndex], group);
       // Stash the results.
       int rendererTrackGroupCount = rendererTrackGroupCounts[rendererIndex];
       rendererTrackGroups[rendererIndex][rendererTrackGroupCount] = group;
@@ -406,10 +412,10 @@ public abstract class MappingTrackSelector extends TrackSelector {
    * Given mapped track information, returns a track selection and configuration for each renderer.
    *
    * @param mappedTrackInfo Mapped track information.
-   * @param rendererFormatSupports The result of {@link RendererCapabilities#supportsFormat} for
-   *     each mapped track, indexed by renderer, track group and track (in that order).
-   * @param rendererMixedMimeTypeAdaptationSupport The result of {@link
-   *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
+   * @param rendererFormatSupports The {@link Capabilities} for ach mapped track, indexed by
+   *     renderer, track group and track (in that order).
+   * @param rendererMixedMimeTypeAdaptationSupport The {@link AdaptiveSupport} for mixed MIME type
+   *     adaptation for the renderer.
    * @return A pair consisting of the track selections and configurations for each renderer. A null
    *     configuration indicates the renderer should be disabled, in which case the track selection
    *     will also be null. A track selection may also be null for a non-disabled renderer if {@link
@@ -419,8 +425,8 @@ public abstract class MappingTrackSelector extends TrackSelector {
   protected abstract Pair<@NullableType RendererConfiguration[], @NullableType TrackSelection[]>
       selectTracks(
           MappedTrackInfo mappedTrackInfo,
-          int[][][] rendererFormatSupports,
-          int[] rendererMixedMimeTypeAdaptationSupport)
+          @Capabilities int[][][] rendererFormatSupports,
+          @AdaptiveSupport int[] rendererMixedMimeTypeAdaptationSupport)
           throws ExoPlaybackException;
 
   /**
@@ -446,12 +452,14 @@ public abstract class MappingTrackSelector extends TrackSelector {
   private static int findRenderer(RendererCapabilities[] rendererCapabilities, TrackGroup group)
       throws ExoPlaybackException {
     int bestRendererIndex = rendererCapabilities.length;
-    int bestFormatSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
+    @FormatSupport int bestFormatSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
     for (int rendererIndex = 0; rendererIndex < rendererCapabilities.length; rendererIndex++) {
       RendererCapabilities rendererCapability = rendererCapabilities[rendererIndex];
       for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-        int formatSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex))
-            & RendererCapabilities.FORMAT_SUPPORT_MASK;
+        @FormatSupport
+        int formatSupportLevel =
+            RendererCapabilities.getFormatSupport(
+                rendererCapability.supportsFormat(group.getFormat(trackIndex)));
         if (formatSupportLevel > bestFormatSupportLevel) {
           bestRendererIndex = rendererIndex;
           bestFormatSupportLevel = formatSupportLevel;
@@ -466,18 +474,18 @@ public abstract class MappingTrackSelector extends TrackSelector {
   }
 
   /**
-   * Calls {@link RendererCapabilities#supportsFormat} for each track in the specified
-   * {@link TrackGroup}, returning the results in an array.
+   * Calls {@link RendererCapabilities#supportsFormat} for each track in the specified {@link
+   * TrackGroup}, returning the results in an array.
    *
    * @param rendererCapabilities The {@link RendererCapabilities} of the renderer.
    * @param group The track group to evaluate.
-   * @return An array containing the result of calling
-   *     {@link RendererCapabilities#supportsFormat} for each track in the group.
+   * @return An array containing {@link Capabilities} for each track in the group.
    * @throws ExoPlaybackException If an error occurs determining the format support.
    */
+  @Capabilities
   private static int[] getFormatSupport(RendererCapabilities rendererCapabilities, TrackGroup group)
       throws ExoPlaybackException {
-    int[] formatSupport = new int[group.length];
+    @Capabilities int[] formatSupport = new int[group.length];
     for (int i = 0; i < group.length; i++) {
       formatSupport[i] = rendererCapabilities.supportsFormat(group.getFormat(i));
     }
@@ -489,13 +497,14 @@ public abstract class MappingTrackSelector extends TrackSelector {
    * returning the results in an array.
    *
    * @param rendererCapabilities The {@link RendererCapabilities} of the renderers.
-   * @return An array containing the result of calling {@link
-   *     RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
+   * @return An array containing the {@link AdaptiveSupport} for mixed MIME type adaptation for the
+   *     renderer.
    * @throws ExoPlaybackException If an error occurs determining the adaptation support.
    */
+  @AdaptiveSupport
   private static int[] getMixedMimeTypeAdaptationSupports(
       RendererCapabilities[] rendererCapabilities) throws ExoPlaybackException {
-    int[] mixedMimeTypeAdaptationSupport = new int[rendererCapabilities.length];
+    @AdaptiveSupport int[] mixedMimeTypeAdaptationSupport = new int[rendererCapabilities.length];
     for (int i = 0; i < mixedMimeTypeAdaptationSupport.length; i++) {
       mixedMimeTypeAdaptationSupport[i] = rendererCapabilities[i].supportsMixedMimeTypeAdaptation();
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java b/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
index bd99403..ad1a6ef 100644
--- a/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
+++ b/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
@@ -21,7 +21,6 @@ import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import com.google.android.exoplayer2.trackselection.TrackSelectionUtil.AdaptiveTrackSelectionFactory;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import java.util.List;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
@@ -77,32 +76,19 @@ public interface TrackSelection {
   interface Factory {
 
     /**
-     * @deprecated Implement {@link #createTrackSelections(Definition[], BandwidthMeter)} instead.
-     *     Calling {@link TrackSelectionUtil#createTrackSelectionsForDefinitions(Definition[],
-     *     AdaptiveTrackSelectionFactory)} helps to create a single adaptive track selection in the
-     *     same way as using this deprecated method.
-     */
-    @Deprecated
-    default TrackSelection createTrackSelection(
-        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {
-      throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Creates a new selection for each {@link Definition}.
+     * Creates track selections for the provided {@link Definition Definitions}.
+     *
+     * <p>Implementations that create at most one adaptive track selection may use {@link
+     * TrackSelectionUtil#createTrackSelectionsForDefinitions}.
      *
      * @param definitions A {@link Definition} array. May include null values.
      * @param bandwidthMeter A {@link BandwidthMeter} which can be used to select tracks.
      * @return The created selections. Must have the same length as {@code definitions} and may
      *     include null values.
      */
-    @SuppressWarnings("deprecation")
-    default @NullableType TrackSelection[] createTrackSelections(
-        @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter) {
-      return TrackSelectionUtil.createTrackSelectionsForDefinitions(
-          definitions,
-          definition -> createTrackSelection(definition.group, bandwidthMeter, definition.tracks));
-    }
+    @NullableType
+    TrackSelection[] createTrackSelections(
+        @NullableType Definition[] definitions, BandwidthMeter bandwidthMeter);
   }
 
   /**
@@ -214,16 +200,6 @@ public interface TrackSelection {
   default void onDiscontinuity() {}
 
   /**
-   * @deprecated Use and implement {@link #updateSelectedTrack(long, long, long, List,
-   *     MediaChunkIterator[])} instead.
-   */
-  @Deprecated
-  default void updateSelectedTrack(
-      long playbackPositionUs, long bufferedDurationUs, long availableDurationUs) {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
    * Updates the selected track for sources that load media in discrete {@link MediaChunk}s.
    *
    * <p>This method may only be called when the selection is enabled.
@@ -247,14 +223,12 @@ public interface TrackSelection {
    *     that this information may not be available for all tracks, and so some iterators may be
    *     empty.
    */
-  default void updateSelectedTrack(
+  void updateSelectedTrack(
       long playbackPositionUs,
       long bufferedDurationUs,
       long availableDurationUs,
       List<? extends MediaChunk> queue,
-      MediaChunkIterator[] mediaChunkIterators) {
-    updateSelectedTrack(playbackPositionUs, bufferedDurationUs, availableDurationUs);
-  }
+      MediaChunkIterator[] mediaChunkIterators);
 
   /**
    * May be called periodically by sources that load media in discrete {@link MediaChunk}s and
diff --git a/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java b/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
index bc21fb2..6e10171 100644
--- a/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
+++ b/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
@@ -17,6 +17,7 @@ package com.google.android.exoplayer2.trackselection;
 
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.os.Looper;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.text.TextUtils;
@@ -171,6 +172,11 @@ public class TrackSelectionParameters implements Parcelable {
     @TargetApi(19)
     private void setPreferredTextLanguageAndRoleFlagsToCaptioningManagerSettingsV19(
         Context context) {
+      if (Util.SDK_INT < 23 && Looper.myLooper() == null) {
+        // Android platform bug (pre-Marshmallow) that causes RuntimeExceptions when
+        // CaptioningService is instantiated from a non-Looper thread. See [internal: b/143779904].
+        return;
+      }
       CaptioningManager captioningManager =
           (CaptioningManager) context.getSystemService(Context.CAPTIONING_SERVICE);
       if (captioningManager == null || !captioningManager.isEnabled()) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index fb74bd9..c2fbeb6 100644
--- a/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -75,7 +75,7 @@ import com.google.android.exoplayer2.util.Assertions;
  * the two are tightly bound together. It may only be possible to play a certain combination tracks
  * if the renderers are configured in a particular way. Equally, it may only be possible to
  * configure renderers in a particular way if certain tracks are selected. Hence it makes sense to
- * determined the track selection and corresponding renderer configurations in a single step.
+ * determine the track selection and corresponding renderer configurations in a single step.
  *
  * <h3>Threading model</h3>
  *
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
index 55c580e..e592c3b 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/DataSchemeDataSource.java
@@ -36,6 +36,8 @@ public final class DataSchemeDataSource extends BaseDataSource {
   private int endPosition;
   private int readPosition;
 
+  // the constructor does not initialize fields: data
+  @SuppressWarnings("nullness:initialization.fields.uninitialized")
   public DataSchemeDataSource() {
     super(/* isNetwork= */ false);
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index 21be0c5..acf5550 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -35,18 +35,14 @@ public final class DataSpec {
 
   /**
    * The flags that apply to any request for data. Possible flag values are {@link
-   * #FLAG_ALLOW_GZIP}, {@link #FLAG_ALLOW_ICY_METADATA}, {@link #FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN}
-   * , {@link #FLAG_ALLOW_CACHE_FRAGMENTATION} and {@link #FLAG_FORCE_BOUND_LOCAL_ADDRESS}
+   * #FLAG_ALLOW_GZIP}, {@link #FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN} and {@link
+   * #FLAG_ALLOW_CACHE_FRAGMENTATION}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {
-      FLAG_ALLOW_GZIP,
-      FLAG_ALLOW_ICY_METADATA,
-      FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN,
-      FLAG_ALLOW_CACHE_FRAGMENTATION,
-      FLAG_FORCE_BOUND_LOCAL_ADDRESS
-  })
+  @IntDef(
+      flag = true,
+      value = {FLAG_ALLOW_GZIP, FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN, FLAG_ALLOW_CACHE_FRAGMENTATION})
   public @interface Flags {}
   /**
    * Allows an underlying network stack to request that the server use gzip compression.
@@ -60,22 +56,15 @@ public final class DataSpec {
    * DataSource#read(byte[], int, int)} will be the decompressed data.
    */
   public static final int FLAG_ALLOW_GZIP = 1;
-  /** Allows an underlying network stack to request that the stream contain ICY metadata. */
-  public static final int FLAG_ALLOW_ICY_METADATA = 1 << 1; // 2
   /** Prevents caching if the length cannot be resolved when the {@link DataSource} is opened. */
-  public static final int FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN = 1 << 2; // 4
+  public static final int FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN = 1 << 1; // 2
   /**
    * Allows fragmentation of this request into multiple cache files, meaning a cache eviction policy
    * will be able to evict individual fragments of the data. Depending on the cache implementation,
    * setting this flag may also enable more concurrent access to the data (e.g. reading one fragment
    * whilst writing another).
    */
-  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 3; // 8
-
-  /**
-   * Force the source to bound to local address.
-   */
-  public static final int FLAG_FORCE_BOUND_LOCAL_ADDRESS = 1 << 8; // 16
+  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 2; // 4
 
   /**
    * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
@@ -177,6 +166,36 @@ public final class DataSpec {
   }
 
   /**
+   * Construct a data spec where {@link #position} equals {@link #absoluteStreamPosition} and has
+   * request headers.
+   *
+   * @param uri {@link #uri}.
+   * @param absoluteStreamPosition {@link #absoluteStreamPosition}, equal to {@link #position}.
+   * @param length {@link #length}.
+   * @param key {@link #key}.
+   * @param flags {@link #flags}.
+   * @param httpRequestHeaders {@link #httpRequestHeaders}
+   */
+  public DataSpec(
+      Uri uri,
+      long absoluteStreamPosition,
+      long length,
+      @Nullable String key,
+      @Flags int flags,
+      Map<String, String> httpRequestHeaders) {
+    this(
+        uri,
+        inferHttpMethod(null),
+        null,
+        absoluteStreamPosition,
+        absoluteStreamPosition,
+        length,
+        key,
+        flags,
+        httpRequestHeaders);
+  }
+
+  /**
    * Construct a data spec where {@link #position} may differ from {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
@@ -220,7 +239,7 @@ public final class DataSpec {
       @Flags int flags) {
     this(
         uri,
-        /* httpMethod= */ postBody != null ? HTTP_METHOD_POST : HTTP_METHOD_GET,
+        /* httpMethod= */ inferHttpMethod(postBody),
         /* httpBody= */ postBody,
         absoluteStreamPosition,
         position,
@@ -407,4 +426,53 @@ public final class DataSpec {
         flags,
         httpRequestHeaders);
   }
+
+  /**
+   * Returns a copy of this data spec with the specified request headers.
+   *
+   * @param requestHeaders The HTTP request headers.
+   * @return The copied data spec with the specified request headers.
+   */
+  public DataSpec withRequestHeaders(Map<String, String> requestHeaders) {
+    return new DataSpec(
+        uri,
+        httpMethod,
+        httpBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags,
+        requestHeaders);
+  }
+
+  /**
+   * Returns a copy this data spec with additional request headers.
+   *
+   * <p>Note: Values in {@code requestHeaders} will overwrite values with the same header key that
+   * were previously set in this instance's {@code #httpRequestHeaders}.
+   *
+   * @param requestHeaders The additional HTTP request headers.
+   * @return The copied data with the additional HTTP request headers.
+   */
+  public DataSpec withAdditionalHeaders(Map<String, String> requestHeaders) {
+    Map<String, String> totalHeaders = new HashMap<>(this.httpRequestHeaders);
+    totalHeaders.putAll(requestHeaders);
+
+    return new DataSpec(
+        uri,
+        httpMethod,
+        httpBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags,
+        totalHeaders);
+  }
+
+  @HttpMethod
+  private static int inferHttpMethod(@Nullable byte[] postBody) {
+    return postBody != null ? HTTP_METHOD_POST : HTTP_METHOD_GET;
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index da12041..f688bb9 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -56,19 +56,19 @@ public final class DefaultBandwidthMeter implements BandwidthMeter, TransferList
 
   /** Default initial Wifi bitrate estimate in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI =
-      new long[] {5_400_000, 3_400_000, 1_900_000, 1_100_000, 400_000};
+      new long[] {5_700_000, 3_500_000, 2_000_000, 1_100_000, 470_000};
 
   /** Default initial 2G bitrate estimates in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_2G =
-      new long[] {170_000, 139_000, 122_000, 107_000, 90_000};
+      new long[] {200_000, 148_000, 132_000, 115_000, 95_000};
 
   /** Default initial 3G bitrate estimates in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_3G =
-      new long[] {2_100_000, 1_300_000, 960_000, 770_000, 450_000};
+      new long[] {2_200_000, 1_300_000, 970_000, 810_000, 490_000};
 
   /** Default initial 4G bitrate estimates in bits per second. */
   public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_4G =
-      new long[] {6_000_000, 3_400_000, 2_100_000, 1_400_000, 570_000};
+      new long[] {5_300_000, 3_200_000, 2_000_000, 1_400_000, 690_000};
 
   /**
    * Default initial bitrate estimate used when the device is offline or the network type cannot be
@@ -487,247 +487,244 @@ public final class DefaultBandwidthMeter implements BandwidthMeter, TransferList
 
   private static Map<String, int[]> createInitialBitrateCountryGroupAssignment() {
     HashMap<String, int[]> countryGroupAssignment = new HashMap<>();
-    countryGroupAssignment.put("AD", new int[] {1, 0, 0, 1});
+    countryGroupAssignment.put("AD", new int[] {1, 1, 0, 0});
     countryGroupAssignment.put("AE", new int[] {1, 4, 4, 4});
     countryGroupAssignment.put("AF", new int[] {4, 4, 3, 3});
-    countryGroupAssignment.put("AG", new int[] {3, 2, 1, 1});
-    countryGroupAssignment.put("AI", new int[] {1, 0, 1, 3});
-    countryGroupAssignment.put("AL", new int[] {1, 2, 1, 1});
-    countryGroupAssignment.put("AM", new int[] {2, 2, 3, 2});
+    countryGroupAssignment.put("AG", new int[] {3, 1, 0, 1});
+    countryGroupAssignment.put("AI", new int[] {1, 0, 0, 3});
+    countryGroupAssignment.put("AL", new int[] {1, 2, 0, 1});
+    countryGroupAssignment.put("AM", new int[] {2, 2, 2, 2});
     countryGroupAssignment.put("AO", new int[] {3, 4, 2, 0});
-    countryGroupAssignment.put("AQ", new int[] {4, 2, 2, 2});
     countryGroupAssignment.put("AR", new int[] {2, 3, 2, 2});
-    countryGroupAssignment.put("AS", new int[] {3, 3, 4, 1});
-    countryGroupAssignment.put("AT", new int[] {0, 2, 0, 0});
-    countryGroupAssignment.put("AU", new int[] {0, 1, 1, 1});
-    countryGroupAssignment.put("AW", new int[] {1, 1, 0, 2});
-    countryGroupAssignment.put("AX", new int[] {0, 2, 1, 0});
-    countryGroupAssignment.put("AZ", new int[] {3, 3, 2, 2});
-    countryGroupAssignment.put("BA", new int[] {1, 1, 1, 2});
-    countryGroupAssignment.put("BB", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("BD", new int[] {2, 2, 3, 2});
+    countryGroupAssignment.put("AS", new int[] {3, 0, 4, 2});
+    countryGroupAssignment.put("AT", new int[] {0, 3, 0, 0});
+    countryGroupAssignment.put("AU", new int[] {0, 3, 0, 1});
+    countryGroupAssignment.put("AW", new int[] {1, 1, 0, 3});
+    countryGroupAssignment.put("AX", new int[] {0, 3, 0, 2});
+    countryGroupAssignment.put("AZ", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("BA", new int[] {1, 1, 0, 1});
+    countryGroupAssignment.put("BB", new int[] {0, 2, 0, 0});
+    countryGroupAssignment.put("BD", new int[] {2, 1, 3, 3});
     countryGroupAssignment.put("BE", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("BF", new int[] {4, 4, 3, 1});
+    countryGroupAssignment.put("BF", new int[] {4, 4, 4, 1});
     countryGroupAssignment.put("BG", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("BH", new int[] {2, 1, 3, 4});
-    countryGroupAssignment.put("BI", new int[] {4, 3, 4, 4});
-    countryGroupAssignment.put("BJ", new int[] {4, 3, 4, 4});
-    countryGroupAssignment.put("BL", new int[] {1, 0, 2, 3});
-    countryGroupAssignment.put("BM", new int[] {1, 0, 0, 0});
-    countryGroupAssignment.put("BN", new int[] {4, 2, 3, 3});
-    countryGroupAssignment.put("BO", new int[] {2, 2, 3, 2});
-    countryGroupAssignment.put("BQ", new int[] {1, 0, 3, 4});
+    countryGroupAssignment.put("BI", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("BJ", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("BL", new int[] {1, 0, 2, 2});
+    countryGroupAssignment.put("BM", new int[] {1, 2, 0, 0});
+    countryGroupAssignment.put("BN", new int[] {4, 1, 3, 2});
+    countryGroupAssignment.put("BO", new int[] {1, 2, 3, 2});
+    countryGroupAssignment.put("BQ", new int[] {1, 1, 2, 4});
     countryGroupAssignment.put("BR", new int[] {2, 3, 3, 2});
-    countryGroupAssignment.put("BS", new int[] {2, 0, 1, 4});
-    countryGroupAssignment.put("BT", new int[] {3, 0, 2, 1});
+    countryGroupAssignment.put("BS", new int[] {2, 1, 1, 4});
+    countryGroupAssignment.put("BT", new int[] {3, 0, 3, 1});
     countryGroupAssignment.put("BW", new int[] {4, 4, 1, 2});
     countryGroupAssignment.put("BY", new int[] {0, 1, 1, 2});
-    countryGroupAssignment.put("BZ", new int[] {2, 2, 3, 1});
-    countryGroupAssignment.put("CA", new int[] {0, 3, 3, 3});
-    countryGroupAssignment.put("CD", new int[] {4, 4, 3, 2});
-    countryGroupAssignment.put("CF", new int[] {4, 3, 3, 4});
-    countryGroupAssignment.put("CG", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("CH", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("BZ", new int[] {2, 2, 2, 1});
+    countryGroupAssignment.put("CA", new int[] {0, 3, 1, 3});
+    countryGroupAssignment.put("CD", new int[] {4, 4, 2, 2});
+    countryGroupAssignment.put("CF", new int[] {4, 4, 3, 0});
+    countryGroupAssignment.put("CG", new int[] {3, 4, 2, 4});
+    countryGroupAssignment.put("CH", new int[] {0, 0, 1, 0});
     countryGroupAssignment.put("CI", new int[] {3, 4, 3, 3});
     countryGroupAssignment.put("CK", new int[] {2, 4, 1, 0});
-    countryGroupAssignment.put("CL", new int[] {2, 2, 2, 3});
-    countryGroupAssignment.put("CM", new int[] {3, 4, 2, 1});
-    countryGroupAssignment.put("CN", new int[] {2, 2, 2, 3});
+    countryGroupAssignment.put("CL", new int[] {1, 2, 2, 3});
+    countryGroupAssignment.put("CM", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("CN", new int[] {2, 0, 2, 3});
     countryGroupAssignment.put("CO", new int[] {2, 3, 2, 2});
-    countryGroupAssignment.put("CR", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("CR", new int[] {2, 3, 4, 4});
     countryGroupAssignment.put("CU", new int[] {4, 4, 3, 1});
-    countryGroupAssignment.put("CV", new int[] {2, 3, 2, 4});
-    countryGroupAssignment.put("CW", new int[] {1, 0, 0, 0});
-    countryGroupAssignment.put("CX", new int[] {2, 2, 2, 2});
-    countryGroupAssignment.put("CY", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("CV", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("CW", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("CY", new int[] {1, 1, 0, 0});
     countryGroupAssignment.put("CZ", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("DE", new int[] {0, 2, 2, 2});
-    countryGroupAssignment.put("DJ", new int[] {3, 3, 4, 0});
-    countryGroupAssignment.put("DK", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("DM", new int[] {1, 0, 0, 3});
+    countryGroupAssignment.put("DE", new int[] {0, 1, 1, 3});
+    countryGroupAssignment.put("DJ", new int[] {4, 3, 4, 1});
+    countryGroupAssignment.put("DK", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("DM", new int[] {1, 0, 1, 3});
     countryGroupAssignment.put("DO", new int[] {3, 3, 4, 4});
     countryGroupAssignment.put("DZ", new int[] {3, 3, 4, 4});
-    countryGroupAssignment.put("EC", new int[] {2, 4, 4, 2});
-    countryGroupAssignment.put("EE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("EC", new int[] {2, 3, 4, 3});
+    countryGroupAssignment.put("EE", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("EG", new int[] {3, 4, 2, 2});
     countryGroupAssignment.put("EH", new int[] {2, 0, 3, 3});
-    countryGroupAssignment.put("ER", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("ER", new int[] {4, 2, 2, 0});
     countryGroupAssignment.put("ES", new int[] {0, 1, 1, 1});
     countryGroupAssignment.put("ET", new int[] {4, 4, 4, 0});
     countryGroupAssignment.put("FI", new int[] {0, 0, 1, 0});
-    countryGroupAssignment.put("FJ", new int[] {3, 1, 3, 3});
-    countryGroupAssignment.put("FK", new int[] {4, 2, 2, 3});
-    countryGroupAssignment.put("FM", new int[] {4, 2, 4, 0});
+    countryGroupAssignment.put("FJ", new int[] {3, 0, 3, 3});
+    countryGroupAssignment.put("FK", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("FM", new int[] {4, 0, 4, 0});
     countryGroupAssignment.put("FO", new int[] {0, 0, 0, 0});
     countryGroupAssignment.put("FR", new int[] {1, 0, 3, 1});
-    countryGroupAssignment.put("GA", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("GA", new int[] {3, 3, 2, 2});
     countryGroupAssignment.put("GB", new int[] {0, 1, 3, 3});
     countryGroupAssignment.put("GD", new int[] {2, 0, 4, 4});
-    countryGroupAssignment.put("GE", new int[] {1, 1, 0, 3});
-    countryGroupAssignment.put("GF", new int[] {1, 2, 4, 4});
-    countryGroupAssignment.put("GG", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("GH", new int[] {3, 3, 3, 2});
+    countryGroupAssignment.put("GE", new int[] {1, 1, 1, 4});
+    countryGroupAssignment.put("GF", new int[] {2, 3, 4, 4});
+    countryGroupAssignment.put("GG", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("GH", new int[] {3, 3, 2, 2});
     countryGroupAssignment.put("GI", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("GL", new int[] {2, 2, 3, 4});
-    countryGroupAssignment.put("GM", new int[] {4, 3, 3, 2});
-    countryGroupAssignment.put("GN", new int[] {4, 4, 4, 0});
-    countryGroupAssignment.put("GP", new int[] {2, 2, 1, 3});
-    countryGroupAssignment.put("GQ", new int[] {4, 3, 3, 0});
-    countryGroupAssignment.put("GR", new int[] {1, 1, 0, 1});
-    countryGroupAssignment.put("GT", new int[] {3, 3, 3, 4});
+    countryGroupAssignment.put("GL", new int[] {2, 2, 0, 2});
+    countryGroupAssignment.put("GM", new int[] {4, 4, 3, 4});
+    countryGroupAssignment.put("GN", new int[] {3, 4, 4, 2});
+    countryGroupAssignment.put("GP", new int[] {2, 1, 1, 4});
+    countryGroupAssignment.put("GQ", new int[] {4, 4, 3, 0});
+    countryGroupAssignment.put("GR", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("GT", new int[] {3, 3, 3, 3});
     countryGroupAssignment.put("GU", new int[] {1, 2, 4, 4});
-    countryGroupAssignment.put("GW", new int[] {4, 4, 4, 0});
-    countryGroupAssignment.put("GY", new int[] {3, 4, 1, 0});
-    countryGroupAssignment.put("HK", new int[] {0, 1, 4, 4});
-    countryGroupAssignment.put("HN", new int[] {3, 3, 2, 2});
-    countryGroupAssignment.put("HR", new int[] {1, 0, 0, 2});
-    countryGroupAssignment.put("HT", new int[] {3, 4, 4, 3});
-    countryGroupAssignment.put("HU", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("GW", new int[] {4, 4, 4, 1});
+    countryGroupAssignment.put("GY", new int[] {3, 2, 1, 1});
+    countryGroupAssignment.put("HK", new int[] {0, 2, 3, 4});
+    countryGroupAssignment.put("HN", new int[] {3, 2, 3, 2});
+    countryGroupAssignment.put("HR", new int[] {1, 1, 0, 1});
+    countryGroupAssignment.put("HT", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("HU", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("ID", new int[] {3, 2, 3, 4});
-    countryGroupAssignment.put("IE", new int[] {0, 0, 3, 2});
-    countryGroupAssignment.put("IL", new int[] {0, 1, 2, 3});
+    countryGroupAssignment.put("IE", new int[] {1, 0, 1, 1});
+    countryGroupAssignment.put("IL", new int[] {0, 0, 2, 3});
     countryGroupAssignment.put("IM", new int[] {0, 0, 0, 1});
     countryGroupAssignment.put("IN", new int[] {2, 2, 4, 4});
-    countryGroupAssignment.put("IO", new int[] {4, 4, 2, 2});
-    countryGroupAssignment.put("IQ", new int[] {3, 3, 4, 4});
-    countryGroupAssignment.put("IR", new int[] {1, 0, 1, 0});
-    countryGroupAssignment.put("IS", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("IT", new int[] {1, 0, 1, 1});
+    countryGroupAssignment.put("IO", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("IQ", new int[] {3, 3, 4, 2});
+    countryGroupAssignment.put("IR", new int[] {3, 0, 2, 2});
+    countryGroupAssignment.put("IS", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("IT", new int[] {1, 0, 1, 2});
     countryGroupAssignment.put("JE", new int[] {1, 0, 0, 1});
-    countryGroupAssignment.put("JM", new int[] {3, 2, 2, 1});
-    countryGroupAssignment.put("JO", new int[] {1, 1, 1, 2});
-    countryGroupAssignment.put("JP", new int[] {0, 2, 2, 2});
-    countryGroupAssignment.put("KE", new int[] {3, 3, 3, 3});
-    countryGroupAssignment.put("KG", new int[] {1, 1, 2, 3});
-    countryGroupAssignment.put("KH", new int[] {2, 0, 4, 4});
+    countryGroupAssignment.put("JM", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("JO", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("JP", new int[] {0, 2, 1, 1});
+    countryGroupAssignment.put("KE", new int[] {3, 4, 4, 3});
+    countryGroupAssignment.put("KG", new int[] {1, 1, 2, 2});
+    countryGroupAssignment.put("KH", new int[] {1, 0, 4, 4});
     countryGroupAssignment.put("KI", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("KM", new int[] {4, 4, 3, 3});
-    countryGroupAssignment.put("KN", new int[] {1, 0, 1, 4});
-    countryGroupAssignment.put("KP", new int[] {1, 2, 0, 2});
-    countryGroupAssignment.put("KR", new int[] {0, 3, 0, 2});
-    countryGroupAssignment.put("KW", new int[] {2, 2, 1, 2});
-    countryGroupAssignment.put("KY", new int[] {1, 1, 0, 2});
-    countryGroupAssignment.put("KZ", new int[] {1, 2, 2, 2});
-    countryGroupAssignment.put("LA", new int[] {2, 1, 1, 0});
+    countryGroupAssignment.put("KM", new int[] {4, 3, 2, 3});
+    countryGroupAssignment.put("KN", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("KP", new int[] {4, 2, 4, 2});
+    countryGroupAssignment.put("KR", new int[] {0, 1, 1, 1});
+    countryGroupAssignment.put("KW", new int[] {2, 3, 1, 1});
+    countryGroupAssignment.put("KY", new int[] {1, 1, 0, 1});
+    countryGroupAssignment.put("KZ", new int[] {1, 2, 2, 3});
+    countryGroupAssignment.put("LA", new int[] {2, 2, 1, 1});
     countryGroupAssignment.put("LB", new int[] {3, 2, 0, 0});
-    countryGroupAssignment.put("LC", new int[] {2, 1, 0, 0});
-    countryGroupAssignment.put("LI", new int[] {0, 0, 2, 2});
-    countryGroupAssignment.put("LK", new int[] {1, 1, 2, 2});
-    countryGroupAssignment.put("LR", new int[] {3, 4, 4, 1});
+    countryGroupAssignment.put("LC", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("LI", new int[] {0, 0, 2, 4});
+    countryGroupAssignment.put("LK", new int[] {2, 1, 2, 3});
+    countryGroupAssignment.put("LR", new int[] {3, 4, 3, 1});
     countryGroupAssignment.put("LS", new int[] {3, 3, 2, 0});
     countryGroupAssignment.put("LT", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("LU", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("LU", new int[] {0, 0, 0, 0});
     countryGroupAssignment.put("LV", new int[] {0, 0, 0, 0});
-    countryGroupAssignment.put("LY", new int[] {4, 3, 4, 4});
-    countryGroupAssignment.put("MA", new int[] {2, 1, 2, 2});
-    countryGroupAssignment.put("MC", new int[] {1, 0, 1, 0});
+    countryGroupAssignment.put("LY", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MA", new int[] {2, 1, 2, 1});
+    countryGroupAssignment.put("MC", new int[] {0, 0, 0, 1});
     countryGroupAssignment.put("MD", new int[] {1, 1, 0, 0});
-    countryGroupAssignment.put("ME", new int[] {1, 2, 2, 3});
-    countryGroupAssignment.put("MF", new int[] {1, 4, 2, 1});
-    countryGroupAssignment.put("MG", new int[] {3, 4, 1, 3});
-    countryGroupAssignment.put("MH", new int[] {4, 0, 2, 3});
+    countryGroupAssignment.put("ME", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("MF", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("MG", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("MH", new int[] {4, 0, 2, 4});
     countryGroupAssignment.put("MK", new int[] {1, 0, 0, 0});
-    countryGroupAssignment.put("ML", new int[] {4, 4, 4, 3});
-    countryGroupAssignment.put("MM", new int[] {2, 3, 1, 2});
-    countryGroupAssignment.put("MN", new int[] {2, 3, 2, 4});
+    countryGroupAssignment.put("ML", new int[] {4, 4, 2, 0});
+    countryGroupAssignment.put("MM", new int[] {3, 3, 1, 2});
+    countryGroupAssignment.put("MN", new int[] {2, 3, 2, 3});
     countryGroupAssignment.put("MO", new int[] {0, 0, 4, 4});
     countryGroupAssignment.put("MP", new int[] {0, 2, 4, 4});
-    countryGroupAssignment.put("MQ", new int[] {1, 1, 1, 3});
-    countryGroupAssignment.put("MR", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("MS", new int[] {1, 4, 0, 3});
+    countryGroupAssignment.put("MQ", new int[] {2, 1, 1, 4});
+    countryGroupAssignment.put("MR", new int[] {4, 2, 4, 2});
+    countryGroupAssignment.put("MS", new int[] {1, 2, 3, 3});
     countryGroupAssignment.put("MT", new int[] {0, 1, 0, 0});
     countryGroupAssignment.put("MU", new int[] {2, 2, 3, 4});
-    countryGroupAssignment.put("MV", new int[] {3, 2, 1, 1});
-    countryGroupAssignment.put("MW", new int[] {4, 2, 1, 1});
-    countryGroupAssignment.put("MX", new int[] {2, 4, 3, 2});
-    countryGroupAssignment.put("MY", new int[] {2, 2, 2, 3});
-    countryGroupAssignment.put("MZ", new int[] {3, 4, 2, 2});
-    countryGroupAssignment.put("NA", new int[] {3, 2, 2, 1});
-    countryGroupAssignment.put("NC", new int[] {2, 1, 3, 2});
+    countryGroupAssignment.put("MV", new int[] {4, 3, 0, 2});
+    countryGroupAssignment.put("MW", new int[] {3, 2, 1, 0});
+    countryGroupAssignment.put("MX", new int[] {2, 4, 4, 3});
+    countryGroupAssignment.put("MY", new int[] {2, 2, 3, 3});
+    countryGroupAssignment.put("MZ", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("NA", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("NC", new int[] {2, 0, 3, 3});
     countryGroupAssignment.put("NE", new int[] {4, 4, 4, 3});
     countryGroupAssignment.put("NF", new int[] {1, 2, 2, 2});
-    countryGroupAssignment.put("NG", new int[] {3, 4, 3, 2});
-    countryGroupAssignment.put("NI", new int[] {3, 3, 3, 4});
-    countryGroupAssignment.put("NL", new int[] {0, 2, 4, 3});
-    countryGroupAssignment.put("NO", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("NP", new int[] {3, 3, 2, 2});
-    countryGroupAssignment.put("NR", new int[] {4, 0, 4, 0});
-    countryGroupAssignment.put("NU", new int[] {2, 2, 2, 1});
-    countryGroupAssignment.put("NZ", new int[] {0, 0, 0, 1});
-    countryGroupAssignment.put("OM", new int[] {2, 2, 1, 3});
+    countryGroupAssignment.put("NG", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("NI", new int[] {3, 3, 4, 4});
+    countryGroupAssignment.put("NL", new int[] {0, 2, 3, 3});
+    countryGroupAssignment.put("NO", new int[] {0, 1, 1, 0});
+    countryGroupAssignment.put("NP", new int[] {2, 2, 2, 2});
+    countryGroupAssignment.put("NR", new int[] {4, 0, 3, 1});
+    countryGroupAssignment.put("NZ", new int[] {0, 0, 1, 2});
+    countryGroupAssignment.put("OM", new int[] {3, 2, 1, 3});
     countryGroupAssignment.put("PA", new int[] {1, 3, 3, 4});
     countryGroupAssignment.put("PE", new int[] {2, 3, 4, 4});
-    countryGroupAssignment.put("PF", new int[] {3, 1, 0, 1});
-    countryGroupAssignment.put("PG", new int[] {4, 3, 1, 1});
-    countryGroupAssignment.put("PH", new int[] {3, 0, 4, 4});
+    countryGroupAssignment.put("PF", new int[] {2, 2, 0, 1});
+    countryGroupAssignment.put("PG", new int[] {4, 3, 3, 1});
+    countryGroupAssignment.put("PH", new int[] {3, 0, 3, 4});
     countryGroupAssignment.put("PK", new int[] {3, 3, 3, 3});
-    countryGroupAssignment.put("PL", new int[] {1, 1, 1, 3});
-    countryGroupAssignment.put("PM", new int[] {0, 2, 0, 0});
-    countryGroupAssignment.put("PR", new int[] {2, 1, 3, 3});
-    countryGroupAssignment.put("PS", new int[] {3, 3, 1, 4});
-    countryGroupAssignment.put("PT", new int[] {1, 1, 0, 1});
-    countryGroupAssignment.put("PW", new int[] {2, 2, 1, 1});
-    countryGroupAssignment.put("PY", new int[] {3, 1, 3, 3});
-    countryGroupAssignment.put("QA", new int[] {2, 3, 0, 1});
+    countryGroupAssignment.put("PL", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("PM", new int[] {0, 2, 2, 0});
+    countryGroupAssignment.put("PR", new int[] {1, 2, 3, 3});
+    countryGroupAssignment.put("PS", new int[] {3, 3, 2, 4});
+    countryGroupAssignment.put("PT", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("PW", new int[] {2, 1, 2, 0});
+    countryGroupAssignment.put("PY", new int[] {2, 0, 2, 3});
+    countryGroupAssignment.put("QA", new int[] {2, 2, 1, 2});
     countryGroupAssignment.put("RE", new int[] {1, 0, 2, 2});
     countryGroupAssignment.put("RO", new int[] {0, 1, 1, 2});
     countryGroupAssignment.put("RS", new int[] {1, 2, 0, 0});
     countryGroupAssignment.put("RU", new int[] {0, 1, 1, 1});
-    countryGroupAssignment.put("RW", new int[] {3, 4, 2, 4});
-    countryGroupAssignment.put("SA", new int[] {2, 2, 1, 2});
+    countryGroupAssignment.put("RW", new int[] {4, 4, 2, 4});
+    countryGroupAssignment.put("SA", new int[] {2, 2, 2, 1});
     countryGroupAssignment.put("SB", new int[] {4, 4, 3, 0});
     countryGroupAssignment.put("SC", new int[] {4, 2, 0, 1});
-    countryGroupAssignment.put("SD", new int[] {4, 4, 4, 2});
+    countryGroupAssignment.put("SD", new int[] {4, 4, 4, 3});
     countryGroupAssignment.put("SE", new int[] {0, 1, 0, 0});
-    countryGroupAssignment.put("SG", new int[] {1, 2, 3, 3});
+    countryGroupAssignment.put("SG", new int[] {0, 2, 3, 3});
     countryGroupAssignment.put("SH", new int[] {4, 4, 2, 3});
-    countryGroupAssignment.put("SI", new int[] {0, 1, 0, 1});
-    countryGroupAssignment.put("SJ", new int[] {0, 0, 2, 0});
-    countryGroupAssignment.put("SK", new int[] {0, 1, 0, 1});
-    countryGroupAssignment.put("SL", new int[] {4, 3, 2, 4});
-    countryGroupAssignment.put("SM", new int[] {0, 0, 1, 3});
-    countryGroupAssignment.put("SN", new int[] {4, 4, 4, 3});
-    countryGroupAssignment.put("SO", new int[] {4, 4, 4, 4});
-    countryGroupAssignment.put("SR", new int[] {3, 2, 2, 4});
-    countryGroupAssignment.put("SS", new int[] {4, 2, 4, 2});
+    countryGroupAssignment.put("SI", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("SJ", new int[] {2, 0, 2, 4});
+    countryGroupAssignment.put("SK", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("SL", new int[] {4, 3, 3, 3});
+    countryGroupAssignment.put("SM", new int[] {0, 0, 2, 4});
+    countryGroupAssignment.put("SN", new int[] {3, 4, 4, 2});
+    countryGroupAssignment.put("SO", new int[] {3, 4, 4, 3});
+    countryGroupAssignment.put("SR", new int[] {2, 2, 1, 0});
+    countryGroupAssignment.put("SS", new int[] {4, 3, 4, 3});
     countryGroupAssignment.put("ST", new int[] {3, 4, 2, 2});
     countryGroupAssignment.put("SV", new int[] {2, 3, 3, 4});
     countryGroupAssignment.put("SX", new int[] {2, 4, 1, 0});
-    countryGroupAssignment.put("SY", new int[] {4, 4, 1, 0});
-    countryGroupAssignment.put("SZ", new int[] {3, 4, 2, 3});
-    countryGroupAssignment.put("TC", new int[] {1, 1, 3, 1});
-    countryGroupAssignment.put("TD", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("SY", new int[] {4, 3, 2, 1});
+    countryGroupAssignment.put("SZ", new int[] {4, 4, 3, 4});
+    countryGroupAssignment.put("TC", new int[] {1, 2, 1, 1});
+    countryGroupAssignment.put("TD", new int[] {4, 4, 4, 2});
     countryGroupAssignment.put("TG", new int[] {3, 3, 1, 0});
     countryGroupAssignment.put("TH", new int[] {1, 3, 4, 4});
     countryGroupAssignment.put("TJ", new int[] {4, 4, 4, 4});
     countryGroupAssignment.put("TL", new int[] {4, 2, 4, 4});
-    countryGroupAssignment.put("TM", new int[] {4, 1, 2, 3});
-    countryGroupAssignment.put("TN", new int[] {2, 1, 1, 1});
+    countryGroupAssignment.put("TM", new int[] {4, 1, 2, 2});
+    countryGroupAssignment.put("TN", new int[] {2, 2, 1, 2});
     countryGroupAssignment.put("TO", new int[] {3, 3, 3, 1});
-    countryGroupAssignment.put("TR", new int[] {1, 2, 0, 1});
-    countryGroupAssignment.put("TT", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("TR", new int[] {2, 2, 1, 2});
+    countryGroupAssignment.put("TT", new int[] {1, 3, 1, 2});
     countryGroupAssignment.put("TV", new int[] {4, 2, 2, 4});
-    countryGroupAssignment.put("TW", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("TW", new int[] {0, 0, 0, 0});
     countryGroupAssignment.put("TZ", new int[] {3, 3, 4, 3});
     countryGroupAssignment.put("UA", new int[] {0, 2, 1, 2});
-    countryGroupAssignment.put("UG", new int[] {4, 3, 2, 3});
-    countryGroupAssignment.put("US", new int[] {0, 1, 3, 3});
-    countryGroupAssignment.put("UY", new int[] {2, 2, 2, 2});
-    countryGroupAssignment.put("UZ", new int[] {3, 2, 2, 2});
-    countryGroupAssignment.put("VA", new int[] {1, 2, 2, 2});
-    countryGroupAssignment.put("VC", new int[] {2, 1, 0, 0});
+    countryGroupAssignment.put("UG", new int[] {4, 3, 3, 2});
+    countryGroupAssignment.put("US", new int[] {1, 1, 3, 3});
+    countryGroupAssignment.put("UY", new int[] {2, 2, 1, 1});
+    countryGroupAssignment.put("UZ", new int[] {2, 2, 2, 2});
+    countryGroupAssignment.put("VA", new int[] {1, 2, 4, 2});
+    countryGroupAssignment.put("VC", new int[] {2, 0, 2, 4});
     countryGroupAssignment.put("VE", new int[] {4, 4, 4, 3});
-    countryGroupAssignment.put("VG", new int[] {2, 1, 1, 2});
-    countryGroupAssignment.put("VI", new int[] {1, 0, 2, 4});
+    countryGroupAssignment.put("VG", new int[] {3, 0, 1, 3});
+    countryGroupAssignment.put("VI", new int[] {1, 1, 4, 4});
     countryGroupAssignment.put("VN", new int[] {0, 2, 4, 4});
     countryGroupAssignment.put("VU", new int[] {4, 1, 3, 1});
-    countryGroupAssignment.put("WS", new int[] {3, 2, 3, 1});
+    countryGroupAssignment.put("WS", new int[] {3, 3, 3, 2});
     countryGroupAssignment.put("XK", new int[] {1, 2, 1, 0});
-    countryGroupAssignment.put("YE", new int[] {4, 4, 4, 2});
-    countryGroupAssignment.put("YT", new int[] {2, 0, 2, 3});
-    countryGroupAssignment.put("ZA", new int[] {2, 3, 2, 2});
-    countryGroupAssignment.put("ZM", new int[] {3, 3, 2, 1});
-    countryGroupAssignment.put("ZW", new int[] {3, 3, 3, 1});
+    countryGroupAssignment.put("YE", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("YT", new int[] {2, 2, 2, 3});
+    countryGroupAssignment.put("ZA", new int[] {2, 4, 2, 2});
+    countryGroupAssignment.put("ZM", new int[] {3, 2, 2, 1});
+    countryGroupAssignment.put("ZW", new int[] {3, 3, 2, 1});
     return Collections.unmodifiableMap(countryGroupAssignment);
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index dec035c..98026c4 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -113,7 +113,6 @@ public final class DefaultDataSource implements DataSource {
         context,
         new DefaultHttpDataSource(
             userAgent,
-            /* contentTypePredicate= */ null,
             connectTimeoutMillis,
             readTimeoutMillis,
             allowCrossProtocolRedirects,
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 37329a4..ae115ab 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -20,7 +20,6 @@ import android.text.TextUtils;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.DataSpec.HttpMethod;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
@@ -50,8 +49,8 @@ import java.util.zip.GZIPInputStream;
  *
  * <p>By default this implementation will not follow cross-protocol redirects (i.e. redirects from
  * HTTP to HTTPS or vice versa). Cross-protocol redirects can be enabled by using the {@link
- * #DefaultHttpDataSource(String, Predicate, int, int, boolean, RequestProperties)} constructor and
- * passing {@code true} as the second last argument.
+ * #DefaultHttpDataSource(String, int, int, boolean, RequestProperties)} constructor and passing
+ * {@code true} for the {@code allowCrossProtocolRedirects} argument.
  *
  * <p>Note: HTTP request headers will be set using all parameters passed via (in order of decreasing
  * priority) the {@code dataSpec}, {@link #setRequestProperty} and the default parameters used to
@@ -172,6 +171,7 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
    * @deprecated Use {@link #DefaultHttpDataSource(String, int, int)} and {@link
    *     #setContentTypePredicate(Predicate)}.
    */
+  @SuppressWarnings("deprecation")
   @Deprecated
   public DefaultHttpDataSource(
       String userAgent,
@@ -432,7 +432,6 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
-    boolean allowIcyMetadata = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA);
 
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
@@ -444,7 +443,6 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
           position,
           length,
           allowGzip,
-          allowIcyMetadata,
           /* followRedirects= */ true,
           dataSpec.httpRequestHeaders);
     }
@@ -460,7 +458,6 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
               position,
               length,
               allowGzip,
-              allowIcyMetadata,
               /* followRedirects= */ false,
               dataSpec.httpRequestHeaders);
       int responseCode = connection.getResponseCode();
@@ -502,7 +499,6 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
    * @param position The byte offset of the requested data.
    * @param length The length of the requested data, or {@link C#LENGTH_UNSET}.
    * @param allowGzip Whether to allow the use of gzip.
-   * @param allowIcyMetadata Whether to allow ICY metadata.
    * @param followRedirects Whether to follow redirects.
    * @param requestParameters parameters (HTTP headers) to include in request.
    */
@@ -513,7 +509,6 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
       long position,
       long length,
       boolean allowGzip,
-      boolean allowIcyMetadata,
       boolean followRedirects,
       Map<String, String> requestParameters)
       throws IOException {
@@ -541,14 +536,10 @@ public class DefaultHttpDataSource extends BaseDataSource implements HttpDataSou
     }
     connection.setRequestProperty("User-Agent", userAgent);
     connection.setRequestProperty("Accept-Encoding", allowGzip ? "gzip" : "identity");
-    if (allowIcyMetadata) {
-      connection.setRequestProperty(
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
-    }
     connection.setInstanceFollowRedirects(followRedirects);
     connection.setDoOutput(httpBody != null);
     connection.setRequestMethod(DataSpec.getStringForHttpMethod(httpMethod));
+    
     if (httpBody != null) {
       connection.setFixedLengthStreamingMode(httpBody.length);
       connection.connect();
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
index 307652f..435f4bf 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicy.java
@@ -71,6 +71,7 @@ public class DefaultLoadErrorHandlingPolicy implements LoadErrorHandlingPolicy {
       int responseCode = ((InvalidResponseCodeException) exception).responseCode;
       return responseCode == 404 // HTTP 404 Not Found.
               || responseCode == 410 // HTTP 410 Gone.
+              || responseCode == 416 // HTTP 416 Range Not Satisfiable.
           ? DEFAULT_TRACK_BLACKLIST_MS
           : C.TIME_UNSET;
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index e329dc7..2661469 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -18,25 +18,54 @@ package com.google.android.exoplayer2.upstream;
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
 import android.net.Uri;
+import android.text.TextUtils;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.EOFException;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 
 /** A {@link DataSource} for reading local files. */
 public final class FileDataSource extends BaseDataSource {
 
-  /**
-   * Thrown when IOException is encountered during local file read operation.
-   */
+  /** Thrown when a {@link FileDataSource} encounters an error reading a file. */
   public static class FileDataSourceException extends IOException {
 
     public FileDataSourceException(IOException cause) {
       super(cause);
     }
 
+    public FileDataSourceException(String message, IOException cause) {
+      super(message, cause);
+    }
+  }
+
+  /** {@link DataSource.Factory} for {@link FileDataSource} instances. */
+  public static final class Factory implements DataSource.Factory {
+
+    @Nullable private TransferListener listener;
+
+    /**
+     * Sets a {@link TransferListener} for {@link FileDataSource} instances created by this factory.
+     *
+     * @param listener The {@link TransferListener}.
+     * @return This factory.
+     */
+    public Factory setListener(@Nullable TransferListener listener) {
+      this.listener = listener;
+      return this;
+    }
+
+    @Override
+    public FileDataSource createDataSource() {
+      FileDataSource dataSource = new FileDataSource();
+      if (listener != null) {
+        dataSource.addTransferListener(listener);
+      }
+      return dataSource;
+    }
   }
 
   @Nullable private RandomAccessFile file;
@@ -55,8 +84,8 @@ public final class FileDataSource extends BaseDataSource {
       this.uri = uri;
 
       transferInitializing(dataSpec);
-      RandomAccessFile file = new RandomAccessFile(Assertions.checkNotNull(uri.getPath()), "r");
-      this.file = file;
+
+      this.file = openLocalFile(uri);
 
       file.seek(dataSpec.position);
       bytesRemaining = dataSpec.length == C.LENGTH_UNSET ? file.length() - dataSpec.position
@@ -74,6 +103,23 @@ public final class FileDataSource extends BaseDataSource {
     return bytesRemaining;
   }
 
+  private static RandomAccessFile openLocalFile(Uri uri) throws FileDataSourceException {
+    try {
+      return new RandomAccessFile(Assertions.checkNotNull(uri.getPath()), "r");
+    } catch (FileNotFoundException e) {
+      if (!TextUtils.isEmpty(uri.getQuery()) || !TextUtils.isEmpty(uri.getFragment())) {
+        throw new FileDataSourceException(
+            String.format(
+                "uri has query and/or fragment, which are not supported. Did you call Uri.parse()"
+                    + " on a string containing '?' or '#'? Use Uri.fromFile(new File(path)) to"
+                    + " avoid this. path=%s,query=%s,fragment=%s",
+                uri.getPath(), uri.getQuery(), uri.getFragment()),
+            e);
+      }
+      throw new FileDataSourceException(e);
+    }
+  }
+
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws FileDataSourceException {
     if (readLength == 0) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java b/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
index 0b4de1b..004a68f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
@@ -17,28 +17,22 @@ package com.google.android.exoplayer2.upstream;
 
 import androidx.annotation.Nullable;
 
-/**
- * A {@link DataSource.Factory} that produces {@link FileDataSource}.
- */
+/** @deprecated Use {@link FileDataSource.Factory}. */
+@Deprecated
 public final class FileDataSourceFactory implements DataSource.Factory {
 
-  @Nullable private final TransferListener listener;
+  private final FileDataSource.Factory wrappedFactory;
 
   public FileDataSourceFactory() {
-    this(null);
+    this(/* listener= */ null);
   }
 
   public FileDataSourceFactory(@Nullable TransferListener listener) {
-    this.listener = listener;
+    wrappedFactory = new FileDataSource.Factory().setListener(listener);
   }
 
   @Override
-  public DataSource createDataSource() {
-    FileDataSource dataSource = new FileDataSource();
-    if (listener != null) {
-      dataSource.addTransferListener(listener);
-    }
-    return dataSource;
+  public FileDataSource createDataSource() {
+    return wrappedFactory.createDataSource();
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
index 99f0dee..412f866 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
@@ -64,9 +64,7 @@ public final class ResolvingDataSource implements DataSource {
     private final Resolver resolver;
 
     /**
-     * Creates factory for {@link ResolvingDataSource} instances.
-     *
-     * @param upstreamFactory The wrapped {@link DataSource.Factory} handling the resolved {@link
+     * @param upstreamFactory The wrapped {@link DataSource.Factory} for handling resolved {@link
      *     DataSpec DataSpecs}.
      * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
      */
@@ -76,7 +74,7 @@ public final class ResolvingDataSource implements DataSource {
     }
 
     @Override
-    public DataSource createDataSource() {
+    public ResolvingDataSource createDataSource() {
       return new ResolvingDataSource(upstreamFactory.createDataSource(), resolver);
     }
   }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java b/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java
index fbc9f37..a8971e7 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/TransferListener.java
@@ -35,7 +35,7 @@ package com.google.android.exoplayer2.upstream;
  *       DataSpec, boolean)}.
  * </ol>
  */
-public interface TransferListener<T> {
+public interface TransferListener {
 
   /**
    * Called when a transfer is being initialized.
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
index 889ad94..4d9b375 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
@@ -27,7 +27,18 @@ import java.net.MulticastSocket;
 import java.net.SocketException;
 
 /** A UDP {@link DataSource}. */
-public class UdpDataSource extends BaseDataSource {
+public class UdpDataSource extends BaseDataSource {
+
+  /**
+   * Thrown when an error is encountered when trying to read from a {@link UdpDataSource}.
+   */
+  public static final class UdpDataSourceException extends IOException {
+
+    public UdpDataSourceException(IOException cause) {
+      super(cause);
+    }
+
+  }
 
   /**
    * The default maximum datagram packet size, in bytes.
@@ -42,11 +53,10 @@ public class UdpDataSource extends BaseDataSource {
   private final DatagramPacket packet;
 
   @Nullable private Uri uri;
-  @Nullable DatagramSocket socket;
+  @Nullable DatagramSocket socket;
   @Nullable private MulticastSocket multicastSocket;
   @Nullable private InetAddress address;
   @Nullable private InetSocketAddress socketAddress;
-
   private boolean opened;
 
   private int packetRemaining;
@@ -79,28 +89,30 @@ public class UdpDataSource extends BaseDataSource {
   }
 
   @Override
-  public long open(DataSpec dataSpec) throws IOException {
+  public long open(DataSpec dataSpec) throws UdpDataSourceException {
     uri = dataSpec.uri;
     String host = uri.getHost();
     int port = uri.getPort();
     transferInitializing(dataSpec);
-
-    address = InetAddress.getByName(host);
-    socketAddress = new InetSocketAddress(address, port);
-    if (address.isMulticastAddress()) {
-      multicastSocket = new MulticastSocket(socketAddress);
-      multicastSocket.joinGroup(address);
-      socket = multicastSocket;
-    } else {
-      if (dataSpec.isFlagSet(DataSpec.FLAG_FORCE_BOUND_LOCAL_ADDRESS)) {
-        socket = new DatagramSocket(uri.getPort());
+    try {
+      address = InetAddress.getByName(host);
+      socketAddress = new InetSocketAddress(address, port);
+      if (address.isMulticastAddress()) {
+        multicastSocket = new MulticastSocket(socketAddress);
+        multicastSocket.joinGroup(address);
+        socket = multicastSocket;
       } else {
-        socket = new DatagramSocket();
-        socket.connect(socketAddress);
+        socket = new DatagramSocket(socketAddress);
       }
+    } catch (IOException e) {
+      throw new UdpDataSourceException(e);
     }
 
-    socket.setSoTimeout(socketTimeoutMillis);
+    try {
+      socket.setSoTimeout(socketTimeoutMillis);
+    } catch (SocketException e) {
+      throw new UdpDataSourceException(e);
+    }
 
     opened = true;
     transferStarted(dataSpec);
@@ -108,14 +120,18 @@ public class UdpDataSource extends BaseDataSource {
   }
 
   @Override
-  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+  public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceException {
     if (readLength == 0) {
       return 0;
     }
 
     if (packetRemaining == 0) {
       // We've read all of the data from the current packet. Get another.
-      socket.receive(packet);
+      try {
+        socket.receive(packet);
+      } catch (IOException e) {
+        throw new UdpDataSourceException(e);
+      }
       packetRemaining = packet.getLength();
       bytesTransferred(packetRemaining);
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index 12905f9..1d50415 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import com.google.android.exoplayer2.C;
 import java.io.File;
 import java.io.IOException;
@@ -100,7 +101,10 @@ public interface Cache {
   /**
    * Releases the cache. This method must be called when the cache is no longer required. The cache
    * must not be used after calling this method.
+   *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
    */
+  @WorkerThread
   void release();
 
   /**
@@ -162,23 +166,29 @@ public interface Cache {
    * calling {@link #commitFile(File, long)}. When the caller has finished writing, it must release
    * the lock by calling {@link #releaseHoleSpan}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param key The key of the data being requested.
    * @param position The position of the data being requested.
    * @return The {@link CacheSpan}.
    * @throws InterruptedException If the thread was interrupted.
    * @throws CacheException If an error is encountered.
    */
+  @WorkerThread
   CacheSpan startReadWrite(String key, long position) throws InterruptedException, CacheException;
 
   /**
    * Same as {@link #startReadWrite(String, long)}. However, if the cache entry is locked, then
    * instead of blocking, this method will return null as the {@link CacheSpan}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param key The key of the data being requested.
    * @param position The position of the data being requested.
    * @return The {@link CacheSpan}. Or null if the cache entry is locked.
    * @throws CacheException If an error is encountered.
    */
+  @WorkerThread
   @Nullable
   CacheSpan startReadWriteNonBlocking(String key, long position) throws CacheException;
 
@@ -186,6 +196,8 @@ public interface Cache {
    * Obtains a cache file into which data can be written. Must only be called when holding a
    * corresponding hole {@link CacheSpan} obtained from {@link #startReadWrite(String, long)}.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param key The cache key for the data.
    * @param position The starting position of the data.
    * @param length The length of the data being written, or {@link C#LENGTH_UNSET} if unknown. Used
@@ -193,16 +205,20 @@ public interface Cache {
    * @return The file into which data should be written.
    * @throws CacheException If an error is encountered.
    */
+  @WorkerThread
   File startFile(String key, long position, long length) throws CacheException;
 
   /**
    * Commits a file into the cache. Must only be called when holding a corresponding hole {@link
-   * CacheSpan} obtained from {@link #startReadWrite(String, long)}
+   * CacheSpan} obtained from {@link #startReadWrite(String, long)}.
+   *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
    *
    * @param file A newly written cache file.
    * @param length The length of the newly written cache file in bytes.
    * @throws CacheException If an error is encountered.
    */
+  @WorkerThread
   void commitFile(File file, long length) throws CacheException;
 
   /**
@@ -216,19 +232,22 @@ public interface Cache {
   /**
    * Removes a cached {@link CacheSpan} from the cache, deleting the underlying file.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param span The {@link CacheSpan} to remove.
    * @throws CacheException If an error is encountered.
    */
+  @WorkerThread
   void removeSpan(CacheSpan span) throws CacheException;
 
- /**
-  * Queries if a range is entirely available in the cache.
-  *
-  * @param key The cache key for the data.
-  * @param position The starting position of the data.
-  * @param length The length of the data.
-  * @return true if the data is available in the Cache otherwise false;
-  */
+  /**
+   * Queries if a range is entirely available in the cache.
+   *
+   * @param key The cache key for the data.
+   * @param position The starting position of the data.
+   * @param length The length of the data.
+   * @return true if the data is available in the Cache otherwise false;
+   */
   boolean isCached(String key, long position, long length);
 
   /**
@@ -247,10 +266,13 @@ public interface Cache {
    * Applies {@code mutations} to the {@link ContentMetadata} for the given key. A new {@link
    * CachedContent} is added if there isn't one already with the given key.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param key The cache key for the data.
    * @param mutations Contains mutations to be applied to the metadata.
    * @throws CacheException If an error is encountered.
    */
+  @WorkerThread
   void applyContentMetadataMutations(String key, ContentMetadataMutations mutations)
       throws CacheException;
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 80fecf1..22ed389 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -53,7 +53,6 @@ public final class CacheDataSink implements DataSink {
   private long dataSpecFragmentSize;
   private File file;
   private OutputStream outputStream;
-  private FileOutputStream underlyingFileOutputStream;
   private long outputStreamBytesWritten;
   private long dataSpecBytesWritten;
   private ReusableBufferedOutputStream bufferedOutputStream;
@@ -171,7 +170,7 @@ public final class CacheDataSink implements DataSink {
     file =
         cache.startFile(
             dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten, length);
-    underlyingFileOutputStream = new FileOutputStream(file);
+    FileOutputStream underlyingFileOutputStream = new FileOutputStream(file);
     if (bufferSize > 0) {
       if (bufferedOutputStream == null) {
         bufferedOutputStream = new ReusableBufferedOutputStream(underlyingFileOutputStream,
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 541c3b2..94ec2c6 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -138,7 +138,8 @@ public final class CacheDataSource implements DataSource {
   @Nullable private Uri actualUri;
   @HttpMethod private int httpMethod;
   @Nullable private byte[] httpBody;
-  private int flags;
+  private Map<String, String> httpRequestHeaders = Collections.emptyMap();
+  @DataSpec.Flags private int flags;
   @Nullable private String key;
   private long readPosition;
   private long bytesRemaining;
@@ -263,6 +264,7 @@ public final class CacheDataSource implements DataSource {
       actualUri = getRedirectedUriOrDefault(cache, key, /* defaultUri= */ uri);
       httpMethod = dataSpec.httpMethod;
       httpBody = dataSpec.httpBody;
+      httpRequestHeaders = dataSpec.httpRequestHeaders;
       flags = dataSpec.flags;
       readPosition = dataSpec.position;
 
@@ -353,6 +355,10 @@ public final class CacheDataSource implements DataSource {
     actualUri = null;
     httpMethod = DataSpec.HTTP_METHOD_GET;
     httpBody = null;
+    httpRequestHeaders = Collections.emptyMap();
+    flags = 0;
+    readPosition = 0;
+    key = null;
     notifyBytesRead();
     try {
       closeCurrentSource();
@@ -399,7 +405,15 @@ public final class CacheDataSource implements DataSource {
       nextDataSource = upstreamDataSource;
       nextDataSpec =
           new DataSpec(
-              uri, httpMethod, httpBody, readPosition, readPosition, bytesRemaining, key, flags);
+              uri,
+              httpMethod,
+              httpBody,
+              readPosition,
+              readPosition,
+              bytesRemaining,
+              key,
+              flags,
+              httpRequestHeaders);
     } else if (nextSpan.isCached) {
       // Data is cached, read from cache.
       Uri fileUri = Uri.fromFile(nextSpan.file);
@@ -408,6 +422,8 @@ public final class CacheDataSource implements DataSource {
       if (bytesRemaining != C.LENGTH_UNSET) {
         length = Math.min(length, bytesRemaining);
       }
+      // Deliberately skip the HTTP-related parameters since we're reading from the cache, not
+      // making an HTTP request.
       nextDataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
       nextDataSource = cacheReadDataSource;
     } else {
@@ -422,7 +438,16 @@ public final class CacheDataSource implements DataSource {
         }
       }
       nextDataSpec =
-          new DataSpec(uri, httpMethod, httpBody, readPosition, readPosition, length, key, flags);
+          new DataSpec(
+              uri,
+              httpMethod,
+              httpBody,
+              readPosition,
+              readPosition,
+              length,
+              key,
+              flags,
+              httpRequestHeaders);
       if (cacheWriteDataSource != null) {
         nextDataSource = cacheWriteDataSource;
       } else {
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
index 2f0f6ca..21758bd 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
@@ -18,7 +18,7 @@ package com.google.android.exoplayer2.upstream.cache;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
+import com.google.android.exoplayer2.upstream.FileDataSource;
 
 /** A {@link DataSource.Factory} that produces {@link CacheDataSource}. */
 public final class CacheDataSourceFactory implements DataSource.Factory {
@@ -49,7 +49,7 @@ public final class CacheDataSourceFactory implements DataSource.Factory {
     this(
         cache,
         upstreamFactory,
-        new FileDataSourceFactory(),
+        new FileDataSource.Factory(),
         new CacheDataSinkFactory(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE),
         flags,
         /* eventListener= */ null);
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java
index 2488ae0..e288a52 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheFileMetadataIndex.java
@@ -19,6 +19,7 @@ import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
+import androidx.annotation.WorkerThread;
 import com.google.android.exoplayer2.database.DatabaseIOException;
 import com.google.android.exoplayer2.database.DatabaseProvider;
 import com.google.android.exoplayer2.database.VersionTable;
@@ -42,7 +43,7 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   private static final int COLUMN_INDEX_LENGTH = 1;
   private static final int COLUMN_INDEX_LAST_TOUCH_TIMESTAMP = 2;
 
-  private static final String WHERE_NAME_EQUALS = COLUMN_INDEX_NAME + " = ?";
+  private static final String WHERE_NAME_EQUALS = COLUMN_NAME + " = ?";
 
   private static final String[] COLUMNS =
       new String[] {
@@ -64,17 +65,20 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   /**
    * Deletes index data for the specified cache.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param databaseProvider Provides the database in which the index is stored.
    * @param uid The cache UID.
    * @throws DatabaseIOException If an error occurs deleting the index data.
    */
+  @WorkerThread
   public static void delete(DatabaseProvider databaseProvider, long uid)
       throws DatabaseIOException {
     String hexUid = Long.toHexString(uid);
     try {
       String tableName = getTableName(hexUid);
       SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-      writableDatabase.beginTransaction();
+      writableDatabase.beginTransactionNonExclusive();
       try {
         VersionTable.removeVersion(
             writableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid);
@@ -96,9 +100,12 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   /**
    * Initializes the index for the given cache UID.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param uid The cache UID.
    * @throws DatabaseIOException If an error occurs initializing the index.
    */
+  @WorkerThread
   public void initialize(long uid) throws DatabaseIOException {
     try {
       String hexUid = Long.toHexString(uid);
@@ -109,7 +116,7 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
               readableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid);
       if (version != TABLE_VERSION) {
         SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-        writableDatabase.beginTransaction();
+        writableDatabase.beginTransactionNonExclusive();
         try {
           VersionTable.setVersion(
               writableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid, TABLE_VERSION);
@@ -129,9 +136,12 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
    * Returns all file metadata keyed by file name. The returned map is mutable and may be modified
    * by the caller.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @return The file metadata keyed by file name.
    * @throws DatabaseIOException If an error occurs loading the metadata.
    */
+  @WorkerThread
   public Map<String, CacheFileMetadata> getAll() throws DatabaseIOException {
     try (Cursor cursor = getCursor()) {
       Map<String, CacheFileMetadata> fileMetadata = new HashMap<>(cursor.getCount());
@@ -150,11 +160,14 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   /**
    * Sets metadata for a given file.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param name The name of the file.
    * @param length The file length.
    * @param lastTouchTimestamp The file last touch timestamp.
    * @throws DatabaseIOException If an error occurs setting the metadata.
    */
+  @WorkerThread
   public void set(String name, long length, long lastTouchTimestamp) throws DatabaseIOException {
     Assertions.checkNotNull(tableName);
     try {
@@ -172,9 +185,12 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   /**
    * Removes metadata.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param name The name of the file whose metadata is to be removed.
    * @throws DatabaseIOException If an error occurs removing the metadata.
    */
+  @WorkerThread
   public void remove(String name) throws DatabaseIOException {
     Assertions.checkNotNull(tableName);
     try {
@@ -188,14 +204,17 @@ import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
   /**
    * Removes metadata.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param names The names of the files whose metadata is to be removed.
    * @throws DatabaseIOException If an error occurs removing the metadata.
    */
+  @WorkerThread
   public void removeAll(Set<String> names) throws DatabaseIOException {
     Assertions.checkNotNull(tableName);
     try {
       SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-      writableDatabase.beginTransaction();
+      writableDatabase.beginTransactionNonExclusive();
       try {
         for (String name : names) {
           writableDatabase.delete(tableName, WHERE_NAME_EQUALS, new String[] {name});
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index bbec189..ce16ea2 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -18,6 +18,7 @@ package com.google.android.exoplayer2.upstream.cache;
 import android.net.Uri;
 import android.util.Pair;
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
@@ -104,6 +105,8 @@ public final class CacheUtil {
    * Caches the data defined by {@code dataSpec}, skipping already cached data. Caching stops early
    * if the end of the input is reached.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param dataSpec Defines the data to be cached.
    * @param cache A {@link Cache} to store the data.
    * @param cacheKeyFactory An optional factory for cache keys.
@@ -113,6 +116,7 @@ public final class CacheUtil {
    * @throws IOException If an error occurs reading from the source.
    * @throws InterruptedException If the thread was interrupted directly or via {@code isCanceled}.
    */
+  @WorkerThread
   public static void cache(
       DataSpec dataSpec,
       Cache cache,
@@ -144,6 +148,8 @@ public final class CacheUtil {
    * PriorityTaskManager#add} to register with the manager before calling this method, and to call
    * {@link PriorityTaskManager#remove} afterwards to unregister.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param dataSpec Defines the data to be cached.
    * @param cache A {@link Cache} to store the data.
    * @param cacheKeyFactory An optional factory for cache keys.
@@ -159,13 +165,14 @@ public final class CacheUtil {
    * @throws IOException If an error occurs reading from the source.
    * @throws InterruptedException If the thread was interrupted directly or via {@code isCanceled}.
    */
+  @WorkerThread
   public static void cache(
       DataSpec dataSpec,
       Cache cache,
       @Nullable CacheKeyFactory cacheKeyFactory,
       CacheDataSource dataSource,
       byte[] buffer,
-      PriorityTaskManager priorityTaskManager,
+      @Nullable PriorityTaskManager priorityTaskManager,
       int priority,
       @Nullable ProgressListener progressListener,
       @Nullable AtomicBoolean isCanceled,
@@ -261,11 +268,11 @@ public final class CacheUtil {
       long length,
       DataSource dataSource,
       byte[] buffer,
-      PriorityTaskManager priorityTaskManager,
+      @Nullable PriorityTaskManager priorityTaskManager,
       int priority,
       @Nullable ProgressNotifier progressNotifier,
       boolean isLastBlock,
-      AtomicBoolean isCanceled)
+      @Nullable AtomicBoolean isCanceled)
       throws IOException, InterruptedException {
     long positionOffset = absoluteStreamPosition - dataSpec.absoluteStreamPosition;
     long initialPositionOffset = positionOffset;
@@ -333,10 +340,13 @@ public final class CacheUtil {
   /**
    * Removes all of the data specified by the {@code dataSpec}.
    *
+   * <p>This methods blocks until the operation is complete.
+   *
    * @param dataSpec Defines the data to be removed.
    * @param cache A {@link Cache} to store the data.
    * @param cacheKeyFactory An optional factory for cache keys.
    */
+  @WorkerThread
   public static void remove(
       DataSpec dataSpec, Cache cache, @Nullable CacheKeyFactory cacheKeyFactory) {
     remove(cache, buildCacheKey(dataSpec, cacheKeyFactory));
@@ -345,9 +355,12 @@ public final class CacheUtil {
   /**
    * Removes all of the data specified by the {@code key}.
    *
+   * <p>This methods blocks until the operation is complete.
+   *
    * @param cache A {@link Cache} to store the data.
    * @param key The key whose data should be removed.
    */
+  @WorkerThread
   public static void remove(Cache cache, String key) {
     NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(key);
     for (CacheSpan cachedSpan : cachedSpans) {
@@ -379,7 +392,7 @@ public final class CacheUtil {
         .buildCacheKey(dataSpec);
   }
 
-  private static void throwExceptionIfInterruptedOrCancelled(AtomicBoolean isCanceled)
+  private static void throwExceptionIfInterruptedOrCancelled(@Nullable AtomicBoolean isCanceled)
       throws InterruptedException {
     if (Thread.interrupted() || (isCanceled != null && isCanceled.get())) {
       throw new InterruptedException();
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 22086f8..7e09025 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -25,6 +25,7 @@ import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
 import com.google.android.exoplayer2.database.DatabaseIOException;
 import com.google.android.exoplayer2.database.DatabaseProvider;
 import com.google.android.exoplayer2.database.VersionTable;
@@ -104,10 +105,13 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   /**
    * Deletes index data for the specified cache.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param databaseProvider Provides the database in which the index is stored.
    * @param uid The cache UID.
    * @throws DatabaseIOException If an error occurs deleting the index data.
    */
+  @WorkerThread
   public static void delete(DatabaseProvider databaseProvider, long uid)
       throws DatabaseIOException {
     DatabaseStorage.delete(databaseProvider, uid);
@@ -174,9 +178,12 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   /**
    * Loads the index data for the given cache UID.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param uid The UID of the cache whose index is to be loaded.
    * @throws IOException If an error occurs initializing the index data.
    */
+  @WorkerThread
   public void initialize(long uid) throws IOException {
     storage.initialize(uid);
     if (previousStorage != null) {
@@ -199,8 +206,11 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
   /**
    * Stores the index data to index file if there is a change.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @throws IOException If an error occurs storing the index data.
    */
+  @WorkerThread
   public void store() throws IOException {
     storage.storeIncremental(keyToContent);
     // Make ids that were removed since the index was last stored eligible for re-use.
@@ -787,7 +797,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
                 hexUid);
         if (version != TABLE_VERSION) {
           SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-          writableDatabase.beginTransaction();
+          writableDatabase.beginTransactionNonExclusive();
           try {
             initializeTable(writableDatabase);
             writableDatabase.setTransactionSuccessful();
@@ -822,7 +832,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
     public void storeFully(HashMap<String, CachedContent> content) throws IOException {
       try {
         SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-        writableDatabase.beginTransaction();
+        writableDatabase.beginTransactionNonExclusive();
         try {
           initializeTable(writableDatabase);
           for (CachedContent cachedContent : content.values()) {
@@ -845,7 +855,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       }
       try {
         SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-        writableDatabase.beginTransaction();
+        writableDatabase.beginTransactionNonExclusive();
         try {
           for (int i = 0; i < pendingUpdates.size(); i++) {
             CachedContent cachedContent = pendingUpdates.valueAt(i);
@@ -921,7 +931,7 @@ import org.checkerframework.checker.nullness.compatqual.NullableType;
       try {
         String tableName = getTableName(hexUid);
         SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();
-        writableDatabase.beginTransaction();
+        writableDatabase.beginTransactionNonExclusive();
         try {
           VersionTable.removeVersion(
               writableDatabase, VersionTable.FEATURE_CACHE_CONTENT_METADATA, hexUid);
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 44a735f..c88e264 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -17,13 +17,10 @@ package com.google.android.exoplayer2.upstream.cache;
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import java.util.Comparator;
 import java.util.TreeSet;
 
-/**
- * Evicts least recently used cache files first.
- */
-public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Comparator<CacheSpan> {
+/** Evicts least recently used cache files first. */
+public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor {
 
   private final long maxBytes;
   private final TreeSet<CacheSpan> leastRecentlyUsed;
@@ -32,7 +29,7 @@ public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Compar
 
   public LeastRecentlyUsedCacheEvictor(long maxBytes) {
     this.maxBytes = maxBytes;
-    this.leastRecentlyUsed = new TreeSet<>(this);
+    this.leastRecentlyUsed = new TreeSet<>(LeastRecentlyUsedCacheEvictor::compare);
   }
 
   @Override
@@ -71,16 +68,6 @@ public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Compar
     onSpanAdded(cache, newSpan);
   }
 
-  @Override
-  public int compare(CacheSpan lhs, CacheSpan rhs) {
-    long lastTouchTimestampDelta = lhs.lastTouchTimestamp - rhs.lastTouchTimestamp;
-    if (lastTouchTimestampDelta == 0) {
-      // Use the standard compareTo method as a tie-break.
-      return lhs.compareTo(rhs);
-    }
-    return lhs.lastTouchTimestamp < rhs.lastTouchTimestamp ? -1 : 1;
-  }
-
   private void evictCache(Cache cache, long requiredSpace) {
     while (currentSize + requiredSpace > maxBytes && !leastRecentlyUsed.isEmpty()) {
       try {
@@ -91,4 +78,12 @@ public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Compar
     }
   }
 
+  private static int compare(CacheSpan lhs, CacheSpan rhs) {
+    long lastTouchTimestampDelta = lhs.lastTouchTimestamp - rhs.lastTouchTimestamp;
+    if (lastTouchTimestampDelta == 0) {
+      // Use the standard compareTo method as a tie-break.
+      return lhs.compareTo(rhs);
+    }
+    return lhs.lastTouchTimestamp < rhs.lastTouchTimestamp ? -1 : 1;
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index e618fca..a4fade2 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -18,6 +18,7 @@ package com.google.android.exoplayer2.upstream.cache;
 import android.os.ConditionVariable;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.database.DatabaseIOException;
 import com.google.android.exoplayer2.database.DatabaseProvider;
@@ -61,9 +62,6 @@ public final class SimpleCache implements Cache {
 
   private static final HashSet<File> lockedCacheDirs = new HashSet<>();
 
-  private static boolean cacheFolderLockingDisabled;
-  private static boolean cacheInitializationExceptionsDisabled;
-
   private final File cacheDir;
   private final CacheEvictor evictor;
   private final CachedContentIndex contentIndex;
@@ -86,39 +84,15 @@ public final class SimpleCache implements Cache {
   }
 
   /**
-   * Disables locking the cache folders which {@link SimpleCache} instances are using and releases
-   * any previous lock.
-   *
-   * <p>The locking prevents multiple {@link SimpleCache} instances from being created for the same
-   * folder. Disabling it may cause the cache data to be corrupted. Use at your own risk.
-   *
-   * @deprecated Don't create multiple {@link SimpleCache} instances for the same cache folder. If
-   *     you need to create another instance, make sure you call {@link #release()} on the previous
-   *     instance.
-   */
-  @Deprecated
-  public static synchronized void disableCacheFolderLocking() {
-    cacheFolderLockingDisabled = true;
-    lockedCacheDirs.clear();
-  }
-
-  /**
-   * Disables throwing of cache initialization exceptions.
-   *
-   * @deprecated Don't use this. Provided for problematic upgrade cases only.
-   */
-  @Deprecated
-  public static void disableCacheInitializationExceptions() {
-    cacheInitializationExceptionsDisabled = true;
-  }
-
-  /**
    * Deletes all content belonging to a cache instance.
    *
+   * <p>This method may be slow and shouldn't normally be called on the main thread.
+   *
    * @param cacheDir The cache directory.
    * @param databaseProvider The database in which index data is stored, or {@code null} if the
    *     cache used a legacy index.
    */
+  @WorkerThread
   public static void delete(File cacheDir, @Nullable DatabaseProvider databaseProvider) {
     if (!cacheDir.exists()) {
       return;
@@ -177,6 +151,7 @@ public final class SimpleCache implements Cache {
    * @deprecated Use a constructor that takes a {@link DatabaseProvider} for improved performance.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public SimpleCache(File cacheDir, CacheEvictor evictor, @Nullable byte[] secretKey) {
     this(cacheDir, evictor, secretKey, secretKey != null);
   }
@@ -304,7 +279,7 @@ public final class SimpleCache implements Cache {
    * @throws CacheException If an error occurred during initialization.
    */
   public synchronized void checkInitialization() throws CacheException {
-    if (!cacheInitializationExceptionsDisabled && initializationException != null) {
+    if (initializationException != null) {
       throw initializationException;
     }
   }
@@ -828,15 +803,10 @@ public final class SimpleCache implements Cache {
   }
 
   private static synchronized boolean lockFolder(File cacheDir) {
-    if (cacheFolderLockingDisabled) {
-      return true;
-    }
     return lockedCacheDirs.add(cacheDir.getAbsoluteFile());
   }
 
   private static synchronized void unlockFolder(File cacheDir) {
-    if (!cacheFolderLockingDisabled) {
-      lockedCacheDirs.remove(cacheDir.getAbsoluteFile());
-    }
+    lockedCacheDirs.remove(cacheDir.getAbsoluteFile());
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
index 7d9f0c9..5f6ea33 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
@@ -116,10 +116,11 @@ import java.util.regex.Pattern;
       File file, long length, long lastTouchTimestamp, CachedContentIndex index) {
     String name = file.getName();
     if (!name.endsWith(SUFFIX)) {
-      file = upgradeFile(file, index);
-      if (file == null) {
+      @Nullable File upgradedFile = upgradeFile(file, index);
+      if (upgradedFile == null) {
         return null;
       }
+      file = upgradedFile;
       name = file.getName();
     }
 
@@ -174,8 +175,12 @@ import java.util.regex.Pattern;
       key = matcher.group(1); // Keys were not escaped in version 1.
     }
 
-    File newCacheFile = getCacheFile(file.getParentFile(), index.assignIdForKey(key),
-        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
+    File newCacheFile =
+        getCacheFile(
+            Assertions.checkStateNotNull(file.getParentFile()),
+            index.assignIdForKey(key),
+            Long.parseLong(matcher.group(2)),
+            Long.parseLong(matcher.group(3)));
     if (!file.renameTo(newCacheFile)) {
       return null;
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java b/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
index 522fdc9..d9b3ff0 100644
--- a/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
+++ b/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
@@ -52,10 +52,10 @@ public final class AesCipherDataSink implements DataSink {
    *
    * @param secretKey The key data.
    * @param wrappedDataSink The wrapped {@link DataSink}.
-   * @param scratch Scratch space. Data is decrypted into this array before being written to the
+   * @param scratch Scratch space. Data is encrypted into this array before being written to the
    *     wrapped {@link DataSink}. It should be of appropriate size for the expected writes. If a
    *     write is larger than the size of this array the write will still succeed, but multiple
-   *     cipher calls will be required to complete the operation. If {@code null} then decryption
+   *     cipher calls will be required to complete the operation. If {@code null} then encryption
    *     will overwrite the input {@code data}.
    */
   public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink, @Nullable byte[] scratch) {
@@ -96,5 +96,4 @@ public final class AesCipherDataSink implements DataSink {
     cipher = null;
     wrappedDataSink.close();
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java b/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
index 9a4891d..0f3bbfa 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/Assertions.java
@@ -97,6 +97,42 @@ public final class Assertions {
   }
 
   /**
+   * Throws {@link IllegalStateException} if {@code reference} is null.
+   *
+   * @param <T> The type of the reference.
+   * @param reference The reference.
+   * @return The non-null reference that was validated.
+   * @throws IllegalStateException If {@code reference} is null.
+   */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
+  @EnsuresNonNull({"#1"})
+  public static <T> T checkStateNotNull(@Nullable T reference) {
+    if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && reference == null) {
+      throw new IllegalStateException();
+    }
+    return reference;
+  }
+
+  /**
+   * Throws {@link IllegalStateException} if {@code reference} is null.
+   *
+   * @param <T> The type of the reference.
+   * @param reference The reference.
+   * @param errorMessage The exception message to use if the check fails. The message is converted
+   *     to a string using {@link String#valueOf(Object)}.
+   * @return The non-null reference that was validated.
+   * @throws IllegalStateException If {@code reference} is null.
+   */
+  @SuppressWarnings({"contracts.postcondition.not.satisfied", "return.type.incompatible"})
+  @EnsuresNonNull({"#1"})
+  public static <T> T checkStateNotNull(@Nullable T reference, Object errorMessage) {
+    if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && reference == null) {
+      throw new IllegalStateException(String.valueOf(errorMessage));
+    }
+    return reference;
+  }
+
+  /**
    * Throws {@link NullPointerException} if {@code reference} is null.
    *
    * @param <T> The type of the reference.
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java b/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
index 058a5d6..c035c62 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
@@ -76,4 +76,8 @@ public final class ConditionVariable {
     return isOpen;
   }
 
+  /** Returns whether the condition is opened. */
+  public synchronized boolean isOpen() {
+    return isOpen;
+  }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java b/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
index 66e78eb..0a303c1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
@@ -23,9 +23,12 @@ import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.PlaybackSuppressionReason;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererCapabilities.AdaptiveSupport;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.LoadEventInfo;
@@ -99,6 +102,20 @@ public class EventLogger implements AnalyticsListener {
   }
 
   @Override
+  public void onPlaybackSuppressionReasonChanged(
+      EventTime eventTime, @PlaybackSuppressionReason int playbackSuppressionReason) {
+    logd(
+        eventTime,
+        "playbackSuppressionReason",
+        getPlaybackSuppressionReasonString(playbackSuppressionReason));
+  }
+
+  @Override
+  public void onIsPlayingChanged(EventTime eventTime, boolean isPlaying) {
+    logd(eventTime, "isPlaying", Boolean.toString(isPlaying));
+  }
+
+  @Override
   public void onRepeatModeChanged(EventTime eventTime, @Player.RepeatMode int repeatMode) {
     logd(eventTime, "repeatMode", getRepeatModeString(repeatMode));
   }
@@ -134,7 +151,7 @@ public class EventLogger implements AnalyticsListener {
     int periodCount = eventTime.timeline.getPeriodCount();
     int windowCount = eventTime.timeline.getWindowCount();
     logd(
-        "timelineChanged ["
+        "timeline ["
             + getEventTimeString(eventTime)
             + ", periodCount="
             + periodCount
@@ -178,10 +195,10 @@ public class EventLogger implements AnalyticsListener {
     MappedTrackInfo mappedTrackInfo =
         trackSelector != null ? trackSelector.getCurrentMappedTrackInfo() : null;
     if (mappedTrackInfo == null) {
-      logd(eventTime, "tracksChanged", "[]");
+      logd(eventTime, "tracks", "[]");
       return;
     }
-    logd("tracksChanged [" + getEventTimeString(eventTime) + ", ");
+    logd("tracks [" + getEventTimeString(eventTime) + ", ");
     // Log tracks associated to renderers.
     int rendererCount = mappedTrackInfo.getRendererCount();
     for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
@@ -194,12 +211,13 @@ public class EventLogger implements AnalyticsListener {
           String adaptiveSupport =
               getAdaptiveSupportString(
                   trackGroup.length,
-                  mappedTrackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false));
+                  mappedTrackInfo.getAdaptiveSupport(
+                      rendererIndex, groupIndex, /* includeCapabilitiesExceededTracks= */ false));
           logd("    Group:" + groupIndex + ", adaptive_supported=" + adaptiveSupport + " [");
           for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
             String status = getTrackStatusString(trackSelection, trackGroup, trackIndex);
             String formatSupport =
-                getFormatSupportString(
+                RendererCapabilities.getFormatSupportString(
                     mappedTrackInfo.getTrackSupport(rendererIndex, groupIndex, trackIndex));
             logd(
                 "      "
@@ -238,7 +256,8 @@ public class EventLogger implements AnalyticsListener {
         for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
           String status = getTrackStatusString(false);
           String formatSupport =
-              getFormatSupportString(RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
+              RendererCapabilities.getFormatSupportString(
+                  RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
           logd(
               "      "
                   + status
@@ -270,7 +289,7 @@ public class EventLogger implements AnalyticsListener {
 
   @Override
   public void onDecoderEnabled(EventTime eventTime, int trackType, DecoderCounters counters) {
-    logd(eventTime, "decoderEnabled", getTrackTypeString(trackType));
+    logd(eventTime, "decoderEnabled", Util.getTrackTypeString(trackType));
   }
 
   @Override
@@ -279,22 +298,41 @@ public class EventLogger implements AnalyticsListener {
   }
 
   @Override
+  public void onAudioAttributesChanged(EventTime eventTime, AudioAttributes audioAttributes) {
+    logd(
+        eventTime,
+        "audioAttributes",
+        audioAttributes.contentType
+            + ","
+            + audioAttributes.flags
+            + ","
+            + audioAttributes.usage
+            + ","
+            + audioAttributes.allowedCapturePolicy);
+  }
+
+  @Override
+  public void onVolumeChanged(EventTime eventTime, float volume) {
+    logd(eventTime, "volume", Float.toString(volume));
+  }
+
+  @Override
   public void onDecoderInitialized(
       EventTime eventTime, int trackType, String decoderName, long initializationDurationMs) {
-    logd(eventTime, "decoderInitialized", getTrackTypeString(trackType) + ", " + decoderName);
+    logd(eventTime, "decoderInitialized", Util.getTrackTypeString(trackType) + ", " + decoderName);
   }
 
   @Override
   public void onDecoderInputFormatChanged(EventTime eventTime, int trackType, Format format) {
     logd(
         eventTime,
-        "decoderInputFormatChanged",
-        getTrackTypeString(trackType) + ", " + Format.toLogString(format));
+        "decoderInputFormat",
+        Util.getTrackTypeString(trackType) + ", " + Format.toLogString(format));
   }
 
   @Override
   public void onDecoderDisabled(EventTime eventTime, int trackType, DecoderCounters counters) {
-    logd(eventTime, "decoderDisabled", getTrackTypeString(trackType));
+    logd(eventTime, "decoderDisabled", Util.getTrackTypeString(trackType));
   }
 
   @Override
@@ -319,7 +357,7 @@ public class EventLogger implements AnalyticsListener {
       int height,
       int unappliedRotationDegrees,
       float pixelWidthHeightRatio) {
-    logd(eventTime, "videoSizeChanged", width + ", " + height);
+    logd(eventTime, "videoSize", width + ", " + height);
   }
 
   @Override
@@ -378,7 +416,7 @@ public class EventLogger implements AnalyticsListener {
 
   @Override
   public void onSurfaceSizeChanged(EventTime eventTime, int width, int height) {
-    logd(eventTime, "surfaceSizeChanged", width + ", " + height);
+    logd(eventTime, "surfaceSize", width + ", " + height);
   }
 
   @Override
@@ -388,7 +426,7 @@ public class EventLogger implements AnalyticsListener {
 
   @Override
   public void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLoadData) {
-    logd(eventTime, "downstreamFormatChanged", Format.toLogString(mediaLoadData.trackFormat));
+    logd(eventTime, "downstreamFormat", Format.toLogString(mediaLoadData.trackFormat));
   }
 
   @Override
@@ -490,8 +528,9 @@ public class EventLogger implements AnalyticsListener {
         windowPeriodString += ", ad=" + eventTime.mediaPeriodId.adIndexInAdGroup;
       }
     }
-    return getTimeString(eventTime.realtimeMs - startTimeMs)
-        + ", "
+    return "eventTime="
+        + getTimeString(eventTime.realtimeMs - startTimeMs)
+        + ", mediaPos="
         + getTimeString(eventTime.currentPlaybackPositionMs)
         + ", "
         + windowPeriodString;
@@ -516,24 +555,8 @@ public class EventLogger implements AnalyticsListener {
     }
   }
 
-  private static String getFormatSupportString(int formatSupport) {
-    switch (formatSupport) {
-      case RendererCapabilities.FORMAT_HANDLED:
-        return "YES";
-      case RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES:
-        return "NO_EXCEEDS_CAPABILITIES";
-      case RendererCapabilities.FORMAT_UNSUPPORTED_DRM:
-        return "NO_UNSUPPORTED_DRM";
-      case RendererCapabilities.FORMAT_UNSUPPORTED_SUBTYPE:
-        return "NO_UNSUPPORTED_TYPE";
-      case RendererCapabilities.FORMAT_UNSUPPORTED_TYPE:
-        return "NO";
-      default:
-        return "?";
-    }
-  }
-
-  private static String getAdaptiveSupportString(int trackCount, int adaptiveSupport) {
+  private static String getAdaptiveSupportString(
+      int trackCount, @AdaptiveSupport int adaptiveSupport) {
     if (trackCount < 2) {
       return "N/A";
     }
@@ -545,7 +568,7 @@ public class EventLogger implements AnalyticsListener {
       case RendererCapabilities.ADAPTIVE_NOT_SUPPORTED:
         return "NO";
       default:
-        return "?";
+        throw new IllegalStateException();
     }
   }
 
@@ -594,33 +617,26 @@ public class EventLogger implements AnalyticsListener {
 
   private static String getTimelineChangeReasonString(@Player.TimelineChangeReason int reason) {
     switch (reason) {
-      case Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE:
-        return "SOURCE_UPDATE";
-      case Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED:
-        return "PLAYLIST_CHANGED";
+      case Player.TIMELINE_CHANGE_REASON_PREPARED:
+        return "PREPARED";
+      case Player.TIMELINE_CHANGE_REASON_RESET:
+        return "RESET";
+      case Player.TIMELINE_CHANGE_REASON_DYNAMIC:
+        return "DYNAMIC";
       default:
         return "?";
     }
   }
 
-  private static String getTrackTypeString(int trackType) {
-    switch (trackType) {
-      case C.TRACK_TYPE_AUDIO:
-        return "audio";
-      case C.TRACK_TYPE_DEFAULT:
-        return "default";
-      case C.TRACK_TYPE_METADATA:
-        return "metadata";
-      case C.TRACK_TYPE_CAMERA_MOTION:
-        return "camera motion";
-      case C.TRACK_TYPE_NONE:
-        return "none";
-      case C.TRACK_TYPE_TEXT:
-        return "text";
-      case C.TRACK_TYPE_VIDEO:
-        return "video";
+  private static String getPlaybackSuppressionReasonString(
+      @PlaybackSuppressionReason int playbackSuppressionReason) {
+    switch (playbackSuppressionReason) {
+      case Player.PLAYBACK_SUPPRESSION_REASON_NONE:
+        return "NONE";
+      case Player.PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS:
+        return "TRANSIENT_AUDIO_FOCUS_LOSS";
       default:
-        return trackType >= C.TRACK_TYPE_CUSTOM_BASE ? "custom (" + trackType + ")" : "?";
+        return "?";
     }
   }
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java b/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java
index 2c81429..9c5862b 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamMetadata.java
@@ -109,7 +109,7 @@ public final class FlacStreamMetadata {
 
   /** Returns the bit-rate of the FLAC stream. */
   public int bitRate() {
-    return bitsPerSample * sampleRate;
+    return bitsPerSample * sampleRate * channels;
   }
 
   /** Returns the duration of the FLAC stream in microseconds. */
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java b/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
index 7fc46dc..c7feff5 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
@@ -42,7 +42,7 @@ public final class GlUtil {
     int lastError = GLES20.GL_NO_ERROR;
     int error;
     while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
-      Log.e(TAG, "glError " + gluErrorString(lastError));
+      Log.e(TAG, "glError " + gluErrorString(error));
       lastError = error;
     }
     if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED && lastError != GLES20.GL_NO_ERROR) {
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java b/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
index 2d8bf95..1d8c302 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
@@ -163,7 +163,7 @@ public final class ParsableBitArray {
    * Reads up to 32 bits.
    *
    * @param numBits The number of bits to read.
-   * @return An integer whose bottom n bits hold the read data.
+   * @return An integer whose bottom {@code numBits} bits hold the read data.
    */
   public int readBits(int numBits) {
     if (numBits == 0) {
@@ -186,11 +186,24 @@ public final class ParsableBitArray {
   }
 
   /**
+   * Reads up to 64 bits.
+   *
+   * @param numBits The number of bits to read.
+   * @return A long whose bottom {@code numBits} bits hold the read data.
+   */
+  public long readBitsToLong(int numBits) {
+    if (numBits <= 32) {
+      return Util.toUnsignedLong(readBits(numBits));
+    }
+    return Util.toUnsignedLong(readBits(numBits - 32)) << 32 | Util.toUnsignedLong(readBits(32));
+  }
+
+  /**
    * Reads {@code numBits} bits into {@code buffer}.
    *
-   * @param buffer The array into which the read data should be written. The trailing
-   *     {@code numBits % 8} bits are written into the most significant bits of the last modified
-   *     {@code buffer} byte. The remaining ones are unmodified.
+   * @param buffer The array into which the read data should be written. The trailing {@code numBits
+   *     % 8} bits are written into the most significant bits of the last modified {@code buffer}
+   *     byte. The remaining ones are unmodified.
    * @param offset The offset in {@code buffer} at which the read data should be written.
    * @param numBits The number of bits to read.
    */
diff --git a/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index 7f607ce..0ee52db 100644
--- a/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -53,7 +53,6 @@ import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SeekParameters;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -147,7 +146,7 @@ public final class Util {
    * Converts the entirety of an {@link InputStream} to a byte array.
    *
    * @param inputStream the {@link InputStream} to be read. The input stream is not closed by this
-   *    method.
+   *     method.
    * @return a byte array containing all of the inputStream's bytes.
    * @throws IOException if an error occurs reading from the stream.
    */
@@ -239,16 +238,6 @@ public final class Util {
   }
 
   /**
-   * Returns true if the URI is a rtsp stream.
-   *
-   * @param uri The uri to test.
-   */
-  public static boolean isRtspUri(Uri uri) {
-    String scheme = uri.getScheme();
-    return "rtsp".equals(scheme);
-  }
-
-  /**
    * Tests two objects for {@link Object#equals(Object)} equality, handling the case where one or
    * both may be null.
    *
@@ -347,7 +336,20 @@ public final class Util {
   }
 
   /**
-   * Concatenates two non-null type arrays.
+   * Creates a new array containing {@code original} with {@code newElement} appended.
+   *
+   * @param original The input array.
+   * @param newElement The element to append.
+   * @return The new array.
+   */
+  public static <T> T[] nullSafeArrayAppend(T[] original, T newElement) {
+    @NullableType T[] result = Arrays.copyOf(original, original.length + 1);
+    result[original.length] = newElement;
+    return castNonNullTypeArray(result);
+  }
+
+  /**
+   * Creates a new array containing the concatenation of two non-null type arrays.
    *
    * @param first The first array.
    * @param second The second array.
@@ -364,7 +366,6 @@ public final class Util {
         /* length= */ second.length);
     return concatenation;
   }
-
   /**
    * Creates a {@link Handler} with the specified {@link Handler.Callback} on the current {@link
    * Looper} thread. The method accepts partially initialized objects as callback under the
@@ -713,10 +714,28 @@ public final class Util {
   }
 
   /**
+   * Returns the index of the first occurrence of {@code value} in {@code array}, or {@link
+   * C#INDEX_UNSET} if {@code value} is not contained in {@code array}.
+   *
+   * @param array The array to search.
+   * @param value The value to search for.
+   * @return The index of the first occurrence of value in {@code array}, or {@link C#INDEX_UNSET}
+   *     if {@code value} is not contained in {@code array}.
+   */
+  public static int linearSearch(int[] array, int value) {
+    for (int i = 0; i < array.length; i++) {
+      if (array[i] == value) {
+        return i;
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
+  /**
    * Returns the index of the largest element in {@code array} that is less than (or optionally
    * equal to) a specified {@code value}.
-   * <p>
-   * The search is performed using a binary search algorithm, so the array must be sorted. If the
+   *
+   * <p>The search is performed using a binary search algorithm, so the array must be sorted. If the
    * array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
    * index of the first one will be returned.
    *
@@ -730,8 +749,8 @@ public final class Util {
    * @return The index of the largest element in {@code array} that is less than (or optionally
    *     equal to) {@code value}.
    */
-  public static int binarySearchFloor(int[] array, int value, boolean inclusive,
-      boolean stayInBounds) {
+  public static int binarySearchFloor(
+      int[] array, int value, boolean inclusive, boolean stayInBounds) {
     int index = Arrays.binarySearch(array, value);
     if (index < 0) {
       index = -(index + 2);
@@ -1191,6 +1210,17 @@ public final class Util {
   }
 
   /**
+   * Converts an integer to a long by unsigned conversion.
+   *
+   * <p>This method is equivalent to {@link Integer#toUnsignedLong(int)} for API 26+.
+   */
+  public static long toUnsignedLong(int x) {
+    // x is implicitly casted to a long before the bit operation is executed but this does not
+    // impact the method correctness.
+    return x & 0xFFFFFFFFL;
+  }
+
+  /**
    * Returns a byte array containing values parsed from the hex string provided.
    *
    * @param hexString The hex string to convert to bytes.
@@ -1250,9 +1280,9 @@ public final class Util {
    * @param codecs A codec sequence string, as defined in RFC 6381.
    * @param trackType One of {@link C}{@code .TRACK_TYPE_*}.
    * @return A copy of {@code codecs} without the codecs whose track type doesn't match {@code
-   *     trackType}.
+   *     trackType}. If this ends up empty, or {@code codecs} is null, return null.
    */
-  public static @Nullable String getCodecsOfType(String codecs, int trackType) {
+  public static @Nullable String getCodecsOfType(@Nullable String codecs, int trackType) {
     String[] codecArray = splitCodecs(codecs);
     if (codecArray.length == 0) {
       return null;
@@ -1273,9 +1303,9 @@ public final class Util {
    * Splits a codecs sequence string, as defined in RFC 6381, into individual codec strings.
    *
    * @param codecs A codec sequence string, as defined in RFC 6381.
-   * @return The split codecs, or an array of length zero if the input was empty.
+   * @return The split codecs, or an array of length zero if the input was empty or null.
    */
-  public static String[] splitCodecs(String codecs) {
+  public static String[] splitCodecs(@Nullable String codecs) {
     if (TextUtils.isEmpty(codecs)) {
       return new String[0];
     }
@@ -1707,8 +1737,8 @@ public final class Util {
   }
 
   /**
-   * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
-   * order.
+   * Returns the result of updating a CRC-32 with the specified bytes in a "most significant bit
+   * first" order.
    *
    * @param bytes Array containing the bytes to update the crc value with.
    * @param start The index to the first byte in the byte range to update the crc with.
@@ -1716,7 +1746,7 @@ public final class Util {
    * @param initialValue The initial value for the crc calculation.
    * @return The result of updating the initial value with the specified bytes.
    */
-  public static int crc(byte[] bytes, int start, int end, int initialValue) {
+  public static int crc32(byte[] bytes, int start, int end, int initialValue) {
     for (int i = start; i < end; i++) {
       initialValue = (initialValue << 8)
           ^ CRC32_BYTES_MSBF[((initialValue >>> 24) ^ (bytes[i] & 0xFF)) & 0xFF];
@@ -1725,6 +1755,23 @@ public final class Util {
   }
 
   /**
+   * Returns the result of updating a CRC-8 with the specified bytes in a "most significant bit
+   * first" order.
+   *
+   * @param bytes Array containing the bytes to update the crc value with.
+   * @param start The index to the first byte in the byte range to update the crc with.
+   * @param end The index after the last byte in the byte range to update the crc with.
+   * @param initialValue The initial value for the crc calculation.
+   * @return The result of updating the initial value with the specified bytes.
+   */
+  public static int crc8(byte[] bytes, int start, int end, int initialValue) {
+    for (int i = start; i < end; i++) {
+      initialValue = CRC8_BYTES_MSBF[initialValue ^ (bytes[i] & 0xFF)];
+    }
+    return initialValue;
+  }
+
+  /**
    * Returns the {@link C.NetworkType} of the current network connection.
    *
    * @param context A context to access the connectivity manager.
@@ -1880,7 +1927,7 @@ public final class Util {
    * @return The physical display size, in pixels.
    */
   public static Point getPhysicalDisplaySize(Context context, Display display) {
-    if (Util.SDK_INT <= 28 && display.getDisplayId() == Display.DEFAULT_DISPLAY && isTv(context)) {
+    if (Util.SDK_INT <= 29 && display.getDisplayId() == Display.DEFAULT_DISPLAY && isTv(context)) {
       // On Android TVs it is common for the UI to be configured for a lower resolution than
       // SurfaceViews can output. Before API 26 the Display object does not provide a way to
       // identify this case, and up to and including API 28 many devices still do not correctly set
@@ -1954,6 +2001,33 @@ public final class Util {
     return capabilities;
   }
 
+  /**
+   * Returns a string representation of a {@code TRACK_TYPE_*} constant defined in {@link C}.
+   *
+   * @param trackType A {@code TRACK_TYPE_*} constant,
+   * @return A string representation of this constant.
+   */
+  public static String getTrackTypeString(int trackType) {
+    switch (trackType) {
+      case C.TRACK_TYPE_AUDIO:
+        return "audio";
+      case C.TRACK_TYPE_DEFAULT:
+        return "default";
+      case C.TRACK_TYPE_METADATA:
+        return "metadata";
+      case C.TRACK_TYPE_CAMERA_MOTION:
+        return "camera motion";
+      case C.TRACK_TYPE_NONE:
+        return "none";
+      case C.TRACK_TYPE_TEXT:
+        return "text";
+      case C.TRACK_TYPE_VIDEO:
+        return "video";
+      default:
+        return trackType >= C.TRACK_TYPE_CUSTOM_BASE ? "custom (" + trackType + ")" : "?";
+    }
+  }
+
   @Nullable
   private static String getSystemProperty(String name) {
     try {
@@ -2035,42 +2109,6 @@ public final class Util {
     }
   }
 
-  /**
-   * Checks whether the timelines are the same.
-   *
-   * @param firstTimeline The first {@link Timeline}.
-   * @param secondTimeline The second {@link Timeline} to compare with.
-   * @return {@code true} if the both timelines are the same.
-   */
-  public static boolean areTimelinesSame(Timeline firstTimeline, Timeline secondTimeline) {
-    if (firstTimeline == secondTimeline) {
-      return true;
-    }
-    if (secondTimeline.getWindowCount() != firstTimeline.getWindowCount()
-        || secondTimeline.getPeriodCount() != firstTimeline.getPeriodCount()) {
-      return false;
-    }
-    Timeline.Window firstWindow = new Timeline.Window();
-    Timeline.Period firstPeriod = new Timeline.Period();
-    Timeline.Window secondWindow = new Timeline.Window();
-    Timeline.Period secondPeriod = new Timeline.Period();
-    for (int i = 0; i < firstTimeline.getWindowCount(); i++) {
-      if (!firstTimeline
-          .getWindow(i, firstWindow)
-          .equals(secondTimeline.getWindow(i, secondWindow))) {
-        return false;
-      }
-    }
-    for (int i = 0; i < firstTimeline.getPeriodCount(); i++) {
-      if (!firstTimeline
-          .getPeriod(i, firstPeriod, /* setIds= */ true)
-          .equals(secondTimeline.getPeriod(i, secondPeriod, /* setIds= */ true))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
   private static HashMap<String, String> createIso3ToIso2Map() {
     String[] iso2Languages = Locale.getISOLanguages();
     HashMap<String, String> iso3ToIso2 =
@@ -2120,47 +2158,71 @@ public final class Util {
       };
 
   /**
-   * Allows the CRC calculation to be done byte by byte instead of bit per bit being the order
-   * "most significant bit first".
+   * Allows the CRC-32 calculation to be done byte by byte instead of bit per bit in the order "most
+   * significant bit first".
    */
   private static final int[] CRC32_BYTES_MSBF = {
-      0X00000000, 0X04C11DB7, 0X09823B6E, 0X0D4326D9, 0X130476DC, 0X17C56B6B, 0X1A864DB2,
-      0X1E475005, 0X2608EDB8, 0X22C9F00F, 0X2F8AD6D6, 0X2B4BCB61, 0X350C9B64, 0X31CD86D3,
-      0X3C8EA00A, 0X384FBDBD, 0X4C11DB70, 0X48D0C6C7, 0X4593E01E, 0X4152FDA9, 0X5F15ADAC,
-      0X5BD4B01B, 0X569796C2, 0X52568B75, 0X6A1936C8, 0X6ED82B7F, 0X639B0DA6, 0X675A1011,
-      0X791D4014, 0X7DDC5DA3, 0X709F7B7A, 0X745E66CD, 0X9823B6E0, 0X9CE2AB57, 0X91A18D8E,
-      0X95609039, 0X8B27C03C, 0X8FE6DD8B, 0X82A5FB52, 0X8664E6E5, 0XBE2B5B58, 0XBAEA46EF,
-      0XB7A96036, 0XB3687D81, 0XAD2F2D84, 0XA9EE3033, 0XA4AD16EA, 0XA06C0B5D, 0XD4326D90,
-      0XD0F37027, 0XDDB056FE, 0XD9714B49, 0XC7361B4C, 0XC3F706FB, 0XCEB42022, 0XCA753D95,
-      0XF23A8028, 0XF6FB9D9F, 0XFBB8BB46, 0XFF79A6F1, 0XE13EF6F4, 0XE5FFEB43, 0XE8BCCD9A,
-      0XEC7DD02D, 0X34867077, 0X30476DC0, 0X3D044B19, 0X39C556AE, 0X278206AB, 0X23431B1C,
-      0X2E003DC5, 0X2AC12072, 0X128E9DCF, 0X164F8078, 0X1B0CA6A1, 0X1FCDBB16, 0X018AEB13,
-      0X054BF6A4, 0X0808D07D, 0X0CC9CDCA, 0X7897AB07, 0X7C56B6B0, 0X71159069, 0X75D48DDE,
-      0X6B93DDDB, 0X6F52C06C, 0X6211E6B5, 0X66D0FB02, 0X5E9F46BF, 0X5A5E5B08, 0X571D7DD1,
-      0X53DC6066, 0X4D9B3063, 0X495A2DD4, 0X44190B0D, 0X40D816BA, 0XACA5C697, 0XA864DB20,
-      0XA527FDF9, 0XA1E6E04E, 0XBFA1B04B, 0XBB60ADFC, 0XB6238B25, 0XB2E29692, 0X8AAD2B2F,
-      0X8E6C3698, 0X832F1041, 0X87EE0DF6, 0X99A95DF3, 0X9D684044, 0X902B669D, 0X94EA7B2A,
-      0XE0B41DE7, 0XE4750050, 0XE9362689, 0XEDF73B3E, 0XF3B06B3B, 0XF771768C, 0XFA325055,
-      0XFEF34DE2, 0XC6BCF05F, 0XC27DEDE8, 0XCF3ECB31, 0XCBFFD686, 0XD5B88683, 0XD1799B34,
-      0XDC3ABDED, 0XD8FBA05A, 0X690CE0EE, 0X6DCDFD59, 0X608EDB80, 0X644FC637, 0X7A089632,
-      0X7EC98B85, 0X738AAD5C, 0X774BB0EB, 0X4F040D56, 0X4BC510E1, 0X46863638, 0X42472B8F,
-      0X5C007B8A, 0X58C1663D, 0X558240E4, 0X51435D53, 0X251D3B9E, 0X21DC2629, 0X2C9F00F0,
-      0X285E1D47, 0X36194D42, 0X32D850F5, 0X3F9B762C, 0X3B5A6B9B, 0X0315D626, 0X07D4CB91,
-      0X0A97ED48, 0X0E56F0FF, 0X1011A0FA, 0X14D0BD4D, 0X19939B94, 0X1D528623, 0XF12F560E,
-      0XF5EE4BB9, 0XF8AD6D60, 0XFC6C70D7, 0XE22B20D2, 0XE6EA3D65, 0XEBA91BBC, 0XEF68060B,
-      0XD727BBB6, 0XD3E6A601, 0XDEA580D8, 0XDA649D6F, 0XC423CD6A, 0XC0E2D0DD, 0XCDA1F604,
-      0XC960EBB3, 0XBD3E8D7E, 0XB9FF90C9, 0XB4BCB610, 0XB07DABA7, 0XAE3AFBA2, 0XAAFBE615,
-      0XA7B8C0CC, 0XA379DD7B, 0X9B3660C6, 0X9FF77D71, 0X92B45BA8, 0X9675461F, 0X8832161A,
-      0X8CF30BAD, 0X81B02D74, 0X857130C3, 0X5D8A9099, 0X594B8D2E, 0X5408ABF7, 0X50C9B640,
-      0X4E8EE645, 0X4A4FFBF2, 0X470CDD2B, 0X43CDC09C, 0X7B827D21, 0X7F436096, 0X7200464F,
-      0X76C15BF8, 0X68860BFD, 0X6C47164A, 0X61043093, 0X65C52D24, 0X119B4BE9, 0X155A565E,
-      0X18197087, 0X1CD86D30, 0X029F3D35, 0X065E2082, 0X0B1D065B, 0X0FDC1BEC, 0X3793A651,
-      0X3352BBE6, 0X3E119D3F, 0X3AD08088, 0X2497D08D, 0X2056CD3A, 0X2D15EBE3, 0X29D4F654,
-      0XC5A92679, 0XC1683BCE, 0XCC2B1D17, 0XC8EA00A0, 0XD6AD50A5, 0XD26C4D12, 0XDF2F6BCB,
-      0XDBEE767C, 0XE3A1CBC1, 0XE760D676, 0XEA23F0AF, 0XEEE2ED18, 0XF0A5BD1D, 0XF464A0AA,
-      0XF9278673, 0XFDE69BC4, 0X89B8FD09, 0X8D79E0BE, 0X803AC667, 0X84FBDBD0, 0X9ABC8BD5,
-      0X9E7D9662, 0X933EB0BB, 0X97FFAD0C, 0XAFB010B1, 0XAB710D06, 0XA6322BDF, 0XA2F33668,
-      0XBCB4666D, 0XB8757BDA, 0XB5365D03, 0XB1F740B4
+    0X00000000, 0X04C11DB7, 0X09823B6E, 0X0D4326D9, 0X130476DC, 0X17C56B6B, 0X1A864DB2,
+    0X1E475005, 0X2608EDB8, 0X22C9F00F, 0X2F8AD6D6, 0X2B4BCB61, 0X350C9B64, 0X31CD86D3,
+    0X3C8EA00A, 0X384FBDBD, 0X4C11DB70, 0X48D0C6C7, 0X4593E01E, 0X4152FDA9, 0X5F15ADAC,
+    0X5BD4B01B, 0X569796C2, 0X52568B75, 0X6A1936C8, 0X6ED82B7F, 0X639B0DA6, 0X675A1011,
+    0X791D4014, 0X7DDC5DA3, 0X709F7B7A, 0X745E66CD, 0X9823B6E0, 0X9CE2AB57, 0X91A18D8E,
+    0X95609039, 0X8B27C03C, 0X8FE6DD8B, 0X82A5FB52, 0X8664E6E5, 0XBE2B5B58, 0XBAEA46EF,
+    0XB7A96036, 0XB3687D81, 0XAD2F2D84, 0XA9EE3033, 0XA4AD16EA, 0XA06C0B5D, 0XD4326D90,
+    0XD0F37027, 0XDDB056FE, 0XD9714B49, 0XC7361B4C, 0XC3F706FB, 0XCEB42022, 0XCA753D95,
+    0XF23A8028, 0XF6FB9D9F, 0XFBB8BB46, 0XFF79A6F1, 0XE13EF6F4, 0XE5FFEB43, 0XE8BCCD9A,
+    0XEC7DD02D, 0X34867077, 0X30476DC0, 0X3D044B19, 0X39C556AE, 0X278206AB, 0X23431B1C,
+    0X2E003DC5, 0X2AC12072, 0X128E9DCF, 0X164F8078, 0X1B0CA6A1, 0X1FCDBB16, 0X018AEB13,
+    0X054BF6A4, 0X0808D07D, 0X0CC9CDCA, 0X7897AB07, 0X7C56B6B0, 0X71159069, 0X75D48DDE,
+    0X6B93DDDB, 0X6F52C06C, 0X6211E6B5, 0X66D0FB02, 0X5E9F46BF, 0X5A5E5B08, 0X571D7DD1,
+    0X53DC6066, 0X4D9B3063, 0X495A2DD4, 0X44190B0D, 0X40D816BA, 0XACA5C697, 0XA864DB20,
+    0XA527FDF9, 0XA1E6E04E, 0XBFA1B04B, 0XBB60ADFC, 0XB6238B25, 0XB2E29692, 0X8AAD2B2F,
+    0X8E6C3698, 0X832F1041, 0X87EE0DF6, 0X99A95DF3, 0X9D684044, 0X902B669D, 0X94EA7B2A,
+    0XE0B41DE7, 0XE4750050, 0XE9362689, 0XEDF73B3E, 0XF3B06B3B, 0XF771768C, 0XFA325055,
+    0XFEF34DE2, 0XC6BCF05F, 0XC27DEDE8, 0XCF3ECB31, 0XCBFFD686, 0XD5B88683, 0XD1799B34,
+    0XDC3ABDED, 0XD8FBA05A, 0X690CE0EE, 0X6DCDFD59, 0X608EDB80, 0X644FC637, 0X7A089632,
+    0X7EC98B85, 0X738AAD5C, 0X774BB0EB, 0X4F040D56, 0X4BC510E1, 0X46863638, 0X42472B8F,
+    0X5C007B8A, 0X58C1663D, 0X558240E4, 0X51435D53, 0X251D3B9E, 0X21DC2629, 0X2C9F00F0,
+    0X285E1D47, 0X36194D42, 0X32D850F5, 0X3F9B762C, 0X3B5A6B9B, 0X0315D626, 0X07D4CB91,
+    0X0A97ED48, 0X0E56F0FF, 0X1011A0FA, 0X14D0BD4D, 0X19939B94, 0X1D528623, 0XF12F560E,
+    0XF5EE4BB9, 0XF8AD6D60, 0XFC6C70D7, 0XE22B20D2, 0XE6EA3D65, 0XEBA91BBC, 0XEF68060B,
+    0XD727BBB6, 0XD3E6A601, 0XDEA580D8, 0XDA649D6F, 0XC423CD6A, 0XC0E2D0DD, 0XCDA1F604,
+    0XC960EBB3, 0XBD3E8D7E, 0XB9FF90C9, 0XB4BCB610, 0XB07DABA7, 0XAE3AFBA2, 0XAAFBE615,
+    0XA7B8C0CC, 0XA379DD7B, 0X9B3660C6, 0X9FF77D71, 0X92B45BA8, 0X9675461F, 0X8832161A,
+    0X8CF30BAD, 0X81B02D74, 0X857130C3, 0X5D8A9099, 0X594B8D2E, 0X5408ABF7, 0X50C9B640,
+    0X4E8EE645, 0X4A4FFBF2, 0X470CDD2B, 0X43CDC09C, 0X7B827D21, 0X7F436096, 0X7200464F,
+    0X76C15BF8, 0X68860BFD, 0X6C47164A, 0X61043093, 0X65C52D24, 0X119B4BE9, 0X155A565E,
+    0X18197087, 0X1CD86D30, 0X029F3D35, 0X065E2082, 0X0B1D065B, 0X0FDC1BEC, 0X3793A651,
+    0X3352BBE6, 0X3E119D3F, 0X3AD08088, 0X2497D08D, 0X2056CD3A, 0X2D15EBE3, 0X29D4F654,
+    0XC5A92679, 0XC1683BCE, 0XCC2B1D17, 0XC8EA00A0, 0XD6AD50A5, 0XD26C4D12, 0XDF2F6BCB,
+    0XDBEE767C, 0XE3A1CBC1, 0XE760D676, 0XEA23F0AF, 0XEEE2ED18, 0XF0A5BD1D, 0XF464A0AA,
+    0XF9278673, 0XFDE69BC4, 0X89B8FD09, 0X8D79E0BE, 0X803AC667, 0X84FBDBD0, 0X9ABC8BD5,
+    0X9E7D9662, 0X933EB0BB, 0X97FFAD0C, 0XAFB010B1, 0XAB710D06, 0XA6322BDF, 0XA2F33668,
+    0XBCB4666D, 0XB8757BDA, 0XB5365D03, 0XB1F740B4
   };
 
+  /**
+   * Allows the CRC-8 calculation to be done byte by byte instead of bit per bit in the order "most
+   * significant bit first".
+   */
+  private static final int[] CRC8_BYTES_MSBF = {
+    0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A,
+    0x2D, 0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53,
+    0x5A, 0x5D, 0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4,
+    0xC3, 0xCA, 0xCD, 0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1,
+    0xB4, 0xB3, 0xBA, 0xBD, 0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1,
+    0xF6, 0xE3, 0xE4, 0xED, 0xEA, 0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88,
+    0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A, 0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F,
+    0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A, 0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
+    0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A, 0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B,
+    0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4, 0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2,
+    0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4, 0x69, 0x6E, 0x67, 0x60, 0x75,
+    0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44, 0x19, 0x1E, 0x17, 0x10,
+    0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34, 0x4E, 0x49, 0x40,
+    0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63, 0x3E, 0x39,
+    0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13, 0xAE,
+    0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
+    0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4,
+    0xF3
+  };
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java b/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java
index 3aeff9d..3a13540 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/DolbyVisionConfig.java
@@ -36,7 +36,7 @@ public final class DolbyVisionConfig {
     int dvProfile = (profileData >> 1);
     int dvLevel = ((profileData & 0x1) << 5) | ((data.readUnsignedByte() >> 3) & 0x1F);
     String codecsPrefix;
-    if (dvProfile == 4 || dvProfile == 5) {
+    if (dvProfile == 4 || dvProfile == 5 || dvProfile == 7) {
       codecsPrefix = "dvhe";
     } else if (dvProfile == 8) {
       codecsPrefix = "hev1";
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 035e3bf..57c3ab1 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -30,7 +30,6 @@ import android.os.SystemClock;
 import android.util.Pair;
 import android.view.Surface;
 import androidx.annotation.CallSuper;
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -38,6 +37,7 @@ import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.PlayerMessage.Target;
+import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -48,6 +48,7 @@ import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.mediacodec.MediaFormatUtil;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -94,6 +95,9 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    */
   private static final float INITIAL_FORMAT_MAX_INPUT_SIZE_SCALE_FACTOR = 1.5f;
 
+  /** Magic frame render timestamp that indicates the EOS in tunneling mode. */
+  private static final long TUNNELING_EOS_PRESENTATION_TIME_US = Long.MAX_VALUE;
+
   /** A {@link DecoderException} with additional surface information. */
   public static final class VideoDecoderException extends DecoderException {
 
@@ -142,6 +146,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
 
   private int pendingRotationDegrees;
   private float pendingPixelWidthHeightRatio;
+  @Nullable private MediaFormat currentMediaFormat;
   private int currentWidth;
   private int currentHeight;
   private int currentUnappliedRotationDegrees;
@@ -196,6 +201,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
+  @SuppressWarnings("deprecation")
   public MediaCodecVideoRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -231,7 +237,12 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   * @deprecated Use {@link #MediaCodecVideoRenderer(Context, MediaCodecSelector, long, boolean,
+   *     Handler, VideoRendererEventListener, int)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public MediaCodecVideoRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -258,6 +269,41 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    * @param mediaCodecSelector A decoder selector.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
+   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
+   *     initialization fails. This may result in using a decoder that is slower/less efficient than
+   *     the primary decoder.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   */
+  @SuppressWarnings("deprecation")
+  public MediaCodecVideoRenderer(
+      Context context,
+      MediaCodecSelector mediaCodecSelector,
+      long allowedJoiningTimeMs,
+      boolean enableDecoderFallback,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify) {
+    this(
+        context,
+        mediaCodecSelector,
+        allowedJoiningTimeMs,
+        /* drmSessionManager= */ null,
+        /* playClearSamplesWithoutKeys= */ false,
+        enableDecoderFallback,
+        eventHandler,
+        eventListener,
+        maxDroppedFramesToNotify);
+  }
+
+  /**
+   * @param context A context.
+   * @param mediaCodecSelector A decoder selector.
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
    * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
    *     content is not required.
    * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
@@ -273,7 +319,11 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   * @deprecated Use {@link #MediaCodecVideoRenderer(Context, MediaCodecSelector, long, boolean,
+   *     Handler, VideoRendererEventListener, int)} instead, and pass DRM-related parameters to the
+   *     {@link MediaSource} factories.
    */
+  @Deprecated
   public MediaCodecVideoRenderer(
       Context context,
       MediaCodecSelector mediaCodecSelector,
@@ -311,6 +361,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
   }
 
   @Override
+  @Capabilities
   protected int supportsFormat(
       MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
@@ -318,7 +369,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
       throws DecoderQueryException {
     String mimeType = format.sampleMimeType;
     if (!MimeTypes.isVideo(mimeType)) {
-      return FORMAT_UNSUPPORTED_TYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
     }
     @Nullable DrmInitData drmInitData = format.drmInitData;
     // Assume encrypted content requires secure decoders.
@@ -339,7 +390,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
               /* requiresTunnelingDecoder= */ false);
     }
     if (decoderInfos.isEmpty()) {
-      return FORMAT_UNSUPPORTED_SUBTYPE;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_SUBTYPE);
     }
     boolean supportsFormatDrm =
         drmInitData == null
@@ -347,16 +398,17 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
             || (format.exoMediaCryptoType == null
                 && supportsFormatDrm(drmSessionManager, drmInitData));
     if (!supportsFormatDrm) {
-      return FORMAT_UNSUPPORTED_DRM;
+      return RendererCapabilities.create(FORMAT_UNSUPPORTED_DRM);
     }
     // Check capabilities for the first decoder in the list, which takes priority.
     MediaCodecInfo decoderInfo = decoderInfos.get(0);
     boolean isFormatSupported = decoderInfo.isFormatSupported(format);
+    @AdaptiveSupport
     int adaptiveSupport =
         decoderInfo.isSeamlessAdaptationSupported(format)
             ? ADAPTIVE_SEAMLESS
             : ADAPTIVE_NOT_SEAMLESS;
-    int tunnelingSupport = TUNNELING_NOT_SUPPORTED;
+    @TunnelingSupport int tunnelingSupport = TUNNELING_NOT_SUPPORTED;
     if (isFormatSupported) {
       List<MediaCodecInfo> tunnelingDecoderInfos =
           getDecoderInfos(
@@ -372,8 +424,9 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
         }
       }
     }
+    @FormatSupport
     int formatSupport = isFormatSupported ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return adaptiveSupport | tunnelingSupport | formatSupport;
+    return RendererCapabilities.create(formatSupport, adaptiveSupport, tunnelingSupport);
   }
 
   @Override
@@ -389,11 +442,15 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
       boolean requiresSecureDecoder,
       boolean requiresTunnelingDecoder)
       throws DecoderQueryException {
+    @Nullable String mimeType = format.sampleMimeType;
+    if (mimeType == null) {
+      return Collections.emptyList();
+    }
     List<MediaCodecInfo> decoderInfos =
         mediaCodecSelector.getDecoderInfos(
-            format.sampleMimeType, requiresSecureDecoder, requiresTunnelingDecoder);
+            mimeType, requiresSecureDecoder, requiresTunnelingDecoder);
     decoderInfos = MediaCodecUtil.getDecoderInfosSortedByFormatSupport(decoderInfos, format);
-    if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {
+    if (MimeTypes.VIDEO_DOLBY_VISION.equals(mimeType)) {
       // Fall back to H.264/AVC or H.265/HEVC for the relevant DV profiles.
       @Nullable
       Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(format);
@@ -502,6 +559,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
     lastInputTimeUs = C.TIME_UNSET;
     outputStreamOffsetUs = C.TIME_UNSET;
     pendingOutputStreamOffsetCount = 0;
+    currentMediaFormat = null;
     clearReportedVideoSize();
     clearRenderedFirstFrame();
     frameReleaseTimeHelper.disable();
@@ -599,8 +657,8 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
 
   @Override
   protected boolean getCodecNeedsEosPropagation() {
-    // In tunneling mode we can't dequeue an end-of-stream buffer, so propagate it in the renderer.
-    return tunneling;
+    // Since API 23, onFrameRenderedListener allows for detection of the renderer EOS.
+    return tunneling && Util.SDK_INT < 23;
   }
 
   @Override
@@ -719,18 +777,25 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
   }
 
   @Override
-  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat) {
-    boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
-        && outputFormat.containsKey(KEY_CROP_LEFT) && outputFormat.containsKey(KEY_CROP_BOTTOM)
-        && outputFormat.containsKey(KEY_CROP_TOP);
+  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputMediaFormat) {
+    currentMediaFormat = outputMediaFormat;
+    boolean hasCrop =
+        outputMediaFormat.containsKey(KEY_CROP_RIGHT)
+            && outputMediaFormat.containsKey(KEY_CROP_LEFT)
+            && outputMediaFormat.containsKey(KEY_CROP_BOTTOM)
+            && outputMediaFormat.containsKey(KEY_CROP_TOP);
     int width =
         hasCrop
-            ? outputFormat.getInteger(KEY_CROP_RIGHT) - outputFormat.getInteger(KEY_CROP_LEFT) + 1
-            : outputFormat.getInteger(MediaFormat.KEY_WIDTH);
+            ? outputMediaFormat.getInteger(KEY_CROP_RIGHT)
+                - outputMediaFormat.getInteger(KEY_CROP_LEFT)
+                + 1
+            : outputMediaFormat.getInteger(MediaFormat.KEY_WIDTH);
     int height =
         hasCrop
-            ? outputFormat.getInteger(KEY_CROP_BOTTOM) - outputFormat.getInteger(KEY_CROP_TOP) + 1
-            : outputFormat.getInteger(MediaFormat.KEY_HEIGHT);
+            ? outputMediaFormat.getInteger(KEY_CROP_BOTTOM)
+                - outputMediaFormat.getInteger(KEY_CROP_TOP)
+                + 1
+            : outputMediaFormat.getInteger(MediaFormat.KEY_HEIGHT);
     processOutputFormat(codec, width, height);
   }
 
@@ -802,14 +867,15 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
     long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
     long elapsedSinceLastRenderUs = elapsedRealtimeNowUs - lastRenderTimeUs;
     boolean isStarted = getState() == STATE_STARTED;
-    // Don't force output until we joined and always render first frame if not joining.
+    // Don't force output until we joined and the position reached the current stream.
     boolean forceRenderOutputBuffer =
         joiningDeadlineMs == C.TIME_UNSET
+            && positionUs >= outputStreamOffsetUs
             && (!renderedFirstFrame
                 || (isStarted && shouldForceRenderOutputBuffer(earlyUs, elapsedSinceLastRenderUs)));
     if (forceRenderOutputBuffer) {
       long releaseTimeNs = System.nanoTime();
-      notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format);
+      notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format, currentMediaFormat);
       if (Util.SDK_INT >= 21) {
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, releaseTimeNs);
       } else {
@@ -853,7 +919,8 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
     if (Util.SDK_INT >= 21) {
       // Let the underlying framework time the release.
       if (earlyUs < 50000) {
-        notifyFrameMetadataListener(presentationTimeUs, adjustedReleaseTimeNs, format);
+        notifyFrameMetadataListener(
+            presentationTimeUs, adjustedReleaseTimeNs, format, currentMediaFormat);
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, adjustedReleaseTimeNs);
         return true;
       }
@@ -871,7 +938,8 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
             return false;
           }
         }
-        notifyFrameMetadataListener(presentationTimeUs, adjustedReleaseTimeNs, format);
+        notifyFrameMetadataListener(
+            presentationTimeUs, adjustedReleaseTimeNs, format, currentMediaFormat);
         renderOutputBuffer(codec, bufferIndex, presentationTimeUs);
         return true;
       }
@@ -899,15 +967,15 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
       // On API level 20 and below the decoder does not apply the rotation.
       currentUnappliedRotationDegrees = pendingRotationDegrees;
     }
-    // Must be applied each time the output format changes.
+    // Must be applied each time the output MediaFormat changes.
     codec.setVideoScalingMode(scalingMode);
   }
 
   private void notifyFrameMetadataListener(
-      long presentationTimeUs, long releaseTimeNs, Format format) {
+      long presentationTimeUs, long releaseTimeNs, Format format, MediaFormat mediaFormat) {
     if (frameMetadataListener != null) {
       frameMetadataListener.onVideoFrameAboutToBeRendered(
-          presentationTimeUs, releaseTimeNs, format);
+          presentationTimeUs, releaseTimeNs, format, mediaFormat);
     }
   }
 
@@ -931,6 +999,11 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
     onProcessedOutputBuffer(presentationTimeUs);
   }
 
+  /** Called when a output EOS was received in tunneling mode. */
+  private void onProcessedTunneledEndOfStream() {
+    setPendingOutputEndOfStream();
+  }
+
   /**
    * Called when an output buffer is successfully processed.
    *
@@ -956,6 +1029,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
           pendingOutputStreamSwitchTimesUs,
           /* destPos= */ 0,
           pendingOutputStreamOffsetCount);
+      clearRenderedFirstFrame();
     }
   }
 
@@ -1235,7 +1309,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
   /**
    * Returns the framework {@link MediaFormat} that should be used to configure the decoder.
    *
-   * @param format The format of media.
+   * @param format The {@link Format} of media.
    * @param codecMimeType The MIME type handled by the codec.
    * @param codecMaxValues Codec max values that should be used when configuring the decoder.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
@@ -1300,7 +1374,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    * that will allow possible adaptation to other compatible formats in {@code streamFormats}.
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
-   * @param format The format for which the codec is being configured.
+   * @param format The {@link Format} for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
    */
@@ -1366,7 +1440,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
    * aspect ratio, but whose sizes are unknown.
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
-   * @param format The format for which the codec is being configured.
+   * @param format The {@link Format} for which the codec is being configured.
    * @return The maximum video size to use, or null if the size of {@code format} should be used.
    */
   private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format) {
@@ -1406,7 +1480,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
   }
 
   /**
-   * Returns a maximum input buffer size for a given codec and format.
+   * Returns a maximum input buffer size for a given {@link MediaCodec} and {@link Format}.
    *
    * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format.
@@ -1555,7 +1629,8 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
           // https://github.com/google/ExoPlayer/issues/4419,
           // https://github.com/google/ExoPlayer/issues/4460,
           // https://github.com/google/ExoPlayer/issues/4468,
-          // https://github.com/google/ExoPlayer/issues/5312.
+          // https://github.com/google/ExoPlayer/issues/5312,
+          // https://github.com/google/ExoPlayer/issues/6503.
           switch (Util.DEVICE) {
             case "1601":
             case "1713":
@@ -1622,6 +1697,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
             case "JGZ":
             case "K50a40":
             case "kate":
+            case "l5460":
             case "le_x6":
             case "LS-5017":
             case "M5c":
@@ -1691,6 +1767,7 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
           switch (Util.MODEL) {
             case "AFTA":
             case "AFTN":
+            case "JSN-L21":
               deviceNeedsSetOutputSurfaceWorkaround = true;
               break;
             default:
@@ -1708,11 +1785,6 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
     return surface;
   }
 
-  /** Returns true if the first frame has been rendered (playback has not necessarily begun). */
-  protected final boolean haveRenderedFirstFrame() {
-    return renderedFirstFrame;
-  }
-
   protected static final class CodecMaxValues {
 
     public final int width;
@@ -1735,14 +1807,17 @@ public class MediaCodecVideoRenderer extends MediaCodecRenderer {
     }
 
     @Override
-    public void onFrameRendered(@NonNull MediaCodec codec, long presentationTimeUs, long nanoTime) {
+    public void onFrameRendered(MediaCodec codec, long presentationTimeUs, long nanoTime) {
       if (this != tunnelingOnFrameRenderedListener) {
         // Stale event.
         return;
       }
-      onProcessedTunneledBuffer(presentationTimeUs);
+      if (presentationTimeUs == TUNNELING_EOS_PRESENTATION_TIME_US) {
+        onProcessedTunneledEndOfStream();
+      } else {
+        onProcessedTunneledBuffer(presentationTimeUs);
+      }
     }
 
   }
-
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java b/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
index e8d63dd..bf0a28f 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
@@ -86,6 +86,10 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
       decoder;
   private VideoDecoderInputBuffer inputBuffer;
   private VideoDecoderOutputBuffer outputBuffer;
+  @Nullable private Surface surface;
+  @Nullable private VideoDecoderOutputBufferRenderer outputBufferRenderer;
+  @C.VideoOutputMode private int outputMode;
+
   @Nullable private DrmSession<ExoMediaCrypto> decoderDrmSession;
   @Nullable private DrmSession<ExoMediaCrypto> sourceDrmSession;
 
@@ -147,11 +151,13 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
+    outputMode = C.VIDEO_OUTPUT_MODE_NONE;
   }
 
   // BaseRenderer implementation.
 
   @Override
+  @Capabilities
   public final int supportsFormat(Format format) {
     return supportsFormatInternal(drmSessionManager, format);
   }
@@ -192,7 +198,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
         while (feedInputBuffer()) {}
         TraceUtil.endSection();
       } catch (VideoDecoderException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
+        throw createRendererException(e, inputFormat);
       }
       decoderCounters.ensureUpdated();
     }
@@ -210,7 +216,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     }
     if (inputFormat != null
         && (isSourceReady() || outputBuffer != null)
-        && (renderedFirstFrame || !hasOutputSurface())) {
+        && (renderedFirstFrame || !hasOutput())) {
       // Ready. If we were joining then we've now joined, so clear the joining deadline.
       joiningDeadlineMs = C.TIME_UNSET;
       return true;
@@ -227,6 +233,8 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     }
   }
 
+  // Protected methods.
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
@@ -316,7 +324,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
       inputBuffer = null;
       if (outputBuffer != null) {
         outputBuffer.release();
-        clearOutputBuffer();
+        outputBuffer = null;
       }
       decoder.flush();
       decoderReceivedBuffers = false;
@@ -327,7 +335,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
   @CallSuper
   protected void releaseDecoder() {
     inputBuffer = null;
-    clearOutputBuffer();
+    outputBuffer = null;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     decoderReceivedBuffers = false;
     buffersInCodecCount = 0;
@@ -339,16 +347,6 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     setDecoderDrmSession(null);
   }
 
-  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(sourceDrmSession, session);
-    sourceDrmSession = session;
-  }
-
-  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(decoderDrmSession, session);
-    decoderDrmSession = session;
-  }
-
   /**
    * Called when a new format is read from the upstream source.
    *
@@ -501,13 +499,14 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
   }
 
   /**
-   * Returns the extent to which the subclass supports a given format.
+   * Returns the {@link Capabilities} for the given {@link Format}.
    *
    * @param drmSessionManager The renderer's {@link DrmSessionManager}.
    * @param format The format, which has a video {@link Format#sampleMimeType}.
-   * @return The extent to which the subclass supports the format itself.
+   * @return The {@link Capabilities} for this {@link Format}.
    * @see RendererCapabilities#supportsFormat(Format)
    */
+  @Capabilities
   protected abstract int supportsFormatInternal(
       @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format);
 
@@ -528,94 +527,126 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
           throws VideoDecoderException;
 
   /**
-   * Dequeues output buffer.
+   * Renders the specified output buffer.
    *
-   * @return Dequeued video decoder output buffer, or null if an output buffer isn't available.
-   * @throws VideoDecoderException If an error occurs while dequeuing the output buffer.
+   * <p>The implementation of this method takes ownership of the output buffer and is responsible
+   * for calling {@link VideoDecoderOutputBuffer#release()} either immediately or in the future.
+   *
+   * @param outputBuffer {@link VideoDecoderOutputBuffer} to render.
+   * @param presentationTimeUs Presentation time in microseconds.
+   * @param outputFormat Output {@link Format}.
+   * @throws VideoDecoderException If an error occurs when rendering the output buffer.
    */
-  @Nullable
-  protected abstract VideoDecoderOutputBuffer dequeueOutputBuffer() throws VideoDecoderException;
-
-  /** Clears output buffer. */
-  protected void clearOutputBuffer() {
-    outputBuffer = null;
+  protected void renderOutputBuffer(
+      VideoDecoderOutputBuffer outputBuffer, long presentationTimeUs, Format outputFormat)
+      throws VideoDecoderException {
+    lastRenderTimeUs = C.msToUs(SystemClock.elapsedRealtime() * 1000);
+    int bufferMode = outputBuffer.mode;
+    boolean renderSurface = bufferMode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && surface != null;
+    boolean renderYuv = bufferMode == C.VIDEO_OUTPUT_MODE_YUV && outputBufferRenderer != null;
+    if (!renderYuv && !renderSurface) {
+      dropOutputBuffer(outputBuffer);
+    } else {
+      maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
+      if (renderYuv) {
+        outputBufferRenderer.setOutputBuffer(outputBuffer);
+      } else {
+        renderOutputBufferToSurface(outputBuffer, surface);
+      }
+      consecutiveDroppedFrameCount = 0;
+      decoderCounters.renderedOutputBufferCount++;
+      maybeNotifyRenderedFirstFrame();
+    }
   }
 
   /**
-   * Renders the specified output buffer.
+   * Renders the specified output buffer to the passed surface.
    *
    * <p>The implementation of this method takes ownership of the output buffer and is responsible
    * for calling {@link VideoDecoderOutputBuffer#release()} either immediately or in the future.
    *
-   * @param presentationTimeUs Presentation time in microseconds.
-   * @param outputFormat Output format.
+   * @param outputBuffer {@link VideoDecoderOutputBuffer} to render.
+   * @param surface Output {@link Surface}.
+   * @throws VideoDecoderException If an error occurs when rendering the output buffer.
    */
-  // TODO: The output buffer is not being passed to this method currently. Due to the need of
-  // decoder-specific output buffer type, the reference to the output buffer is being kept in the
-  // subclass. Once the common output buffer is established, this method can be updated to receive
-  // the output buffer as an argument. See [Internal: b/139174707].
-  protected abstract void renderOutputBuffer(long presentationTimeUs, Format outputFormat)
-      throws VideoDecoderException;
+  protected abstract void renderOutputBufferToSurface(
+      VideoDecoderOutputBuffer outputBuffer, Surface surface) throws VideoDecoderException;
 
   /**
-   * Returns whether the renderer has output surface.
+   * Sets output surface.
    *
-   * @return Whether the renderer has output surface.
+   * @param surface Surface.
    */
-  protected abstract boolean hasOutputSurface();
-
-  /** Called when the output surface is changed. */
-  protected final void onOutputSurfaceChanged() {
-    // If we know the video size, report it again immediately.
-    maybeRenotifyVideoSizeChanged();
-    // We haven't rendered to the new output yet.
-    clearRenderedFirstFrame();
-    if (getState() == STATE_STARTED) {
-      setJoiningDeadlineMs();
+  protected final void setOutputSurface(@Nullable Surface surface) {
+    if (this.surface != surface) {
+      // The output has changed.
+      this.surface = surface;
+      if (surface != null) {
+        outputBufferRenderer = null;
+        outputMode = C.VIDEO_OUTPUT_MODE_SURFACE_YUV;
+        if (decoder != null) {
+          setDecoderOutputMode(outputMode);
+        }
+        onOutputChanged();
+      } else {
+        // The output has been removed. We leave the outputMode of the underlying decoder unchanged
+        // in anticipation that a subsequent output will likely be of the same type.
+        outputMode = C.VIDEO_OUTPUT_MODE_NONE;
+        onOutputRemoved();
+      }
+    } else if (surface != null) {
+      // The output is unchanged and non-null.
+      onOutputReset();
     }
   }
 
-  /** Called when the output surface is removed. */
-  protected final void onOutputSurfaceRemoved() {
-    clearReportedVideoSize();
-    clearRenderedFirstFrame();
-  }
-
   /**
-   * Called when the output surface is set again to the same non-null value.
+   * Sets output buffer renderer.
    *
-   * @param surface Output surface.
+   * @param outputBufferRenderer Output buffer renderer.
    */
-  protected final void onOutputSurfaceReset(Surface surface) {
-    // The output is unchanged and non-null. If we know the video size and/or have already
-    // rendered to the output, report these again immediately.
-    maybeRenotifyVideoSizeChanged();
-    maybeRenotifyRenderedFirstFrame(surface);
+  protected final void setOutputBufferRenderer(
+      @Nullable VideoDecoderOutputBufferRenderer outputBufferRenderer) {
+    if (this.outputBufferRenderer != outputBufferRenderer) {
+      // The output has changed.
+      this.outputBufferRenderer = outputBufferRenderer;
+      if (outputBufferRenderer != null) {
+        surface = null;
+        outputMode = C.VIDEO_OUTPUT_MODE_YUV;
+        if (decoder != null) {
+          setDecoderOutputMode(outputMode);
+        }
+        onOutputChanged();
+      } else {
+        // The output has been removed. We leave the outputMode of the underlying decoder unchanged
+        // in anticipation that a subsequent output will likely be of the same type.
+        outputMode = C.VIDEO_OUTPUT_MODE_NONE;
+        onOutputRemoved();
+      }
+    } else if (outputBufferRenderer != null) {
+      // The output is unchanged and non-null.
+      onOutputReset();
+    }
   }
 
   /**
-   * Notifies event dispatcher if video size changed.
+   * Sets output mode of the decoder.
    *
-   * @param width New video width.
-   * @param height New video height.
+   * @param outputMode Output mode.
    */
-  protected final void maybeNotifyVideoSizeChanged(int width, int height) {
-    if (reportedWidth != width || reportedHeight != height) {
-      reportedWidth = width;
-      reportedHeight = height;
-      eventDispatcher.videoSizeChanged(
-          width, height, /* unappliedRotationDegrees= */ 0, /* pixelWidthHeightRatio= */ 1);
-    }
-  }
+  protected abstract void setDecoderOutputMode(@C.VideoOutputMode int outputMode);
 
-  /** Called after rendering a frame. */
-  protected final void onFrameRendered(Surface surface) {
-    consecutiveDroppedFrameCount = 0;
-    decoderCounters.renderedOutputBufferCount++;
-    maybeNotifyRenderedFirstFrame(surface);
+  // Internal methods.
+
+  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession.replaceSession(sourceDrmSession, session);
+    sourceDrmSession = session;
   }
 
-  // Internal methods.
+  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession.replaceSession(decoderDrmSession, session);
+    decoderDrmSession = session;
+  }
 
   private void maybeInitDecoder() throws ExoPlaybackException {
     if (decoder != null) {
@@ -642,6 +673,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     try {
       long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
       decoder = createDecoder(inputFormat, mediaCrypto);
+      setDecoderOutputMode(outputMode);
       long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
       onDecoderInitialized(
           decoder.getName(),
@@ -649,7 +681,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
           decoderInitializedTimestamp - decoderInitializingTimestamp);
       decoderCounters.decoderInitCount++;
     } catch (VideoDecoderException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      throw createRendererException(e, inputFormat);
     }
   }
 
@@ -731,7 +763,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException, VideoDecoderException {
     if (outputBuffer == null) {
-      outputBuffer = dequeueOutputBuffer();
+      outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
         return false;
       }
@@ -746,7 +778,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
         maybeInitDecoder();
       } else {
         outputBuffer.release();
-        clearOutputBuffer();
+        outputBuffer = null;
         outputStreamEnded = true;
       }
       return false;
@@ -755,7 +787,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     boolean processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs);
     if (processedOutputBuffer) {
       onProcessedOutputBuffer(outputBuffer.timeUs);
-      clearOutputBuffer();
+      outputBuffer = null;
     }
     return processedOutputBuffer;
   }
@@ -777,7 +809,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     }
 
     long earlyUs = outputBuffer.timeUs - positionUs;
-    if (!hasOutputSurface()) {
+    if (!hasOutput()) {
       // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
       if (isBufferLate(earlyUs)) {
         skipOutputBuffer(outputBuffer);
@@ -797,8 +829,7 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     if (!renderedFirstFrame
         || (isStarted
             && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
-      lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-      renderOutputBuffer(presentationTimeUs, outputFormat);
+      renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);
       return true;
     }
 
@@ -815,21 +846,48 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     }
 
     if (earlyUs < 30000) {
-      lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-      renderOutputBuffer(presentationTimeUs, outputFormat);
+      renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);
       return true;
     }
 
     return false;
   }
 
+  private boolean hasOutput() {
+    return outputMode != C.VIDEO_OUTPUT_MODE_NONE;
+  }
+
+  private void onOutputChanged() {
+    // If we know the video size, report it again immediately.
+    maybeRenotifyVideoSizeChanged();
+    // We haven't rendered to the new output yet.
+    clearRenderedFirstFrame();
+    if (getState() == STATE_STARTED) {
+      setJoiningDeadlineMs();
+    }
+  }
+
+  private void onOutputRemoved() {
+    clearReportedVideoSize();
+    clearRenderedFirstFrame();
+  }
+
+  private void onOutputReset() {
+    // The output is unchanged and non-null. If we know the video size and/or have already
+    // rendered to the output, report these again immediately.
+    maybeRenotifyVideoSizeChanged();
+    maybeRenotifyRenderedFirstFrame();
+  }
+
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+    if (decoderDrmSession == null
+        || (!bufferEncrypted
+            && (playClearSamplesWithoutKeys || decoderDrmSession.playClearSamplesWithoutKeys()))) {
       return false;
     }
     @DrmSession.State int drmSessionState = decoderDrmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(decoderDrmSession.getError(), getIndex());
+      throw createRendererException(decoderDrmSession.getError(), inputFormat);
     }
     return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
   }
@@ -845,14 +903,14 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     renderedFirstFrame = false;
   }
 
-  private void maybeNotifyRenderedFirstFrame(Surface surface) {
+  private void maybeNotifyRenderedFirstFrame() {
     if (!renderedFirstFrame) {
       renderedFirstFrame = true;
       eventDispatcher.renderedFirstFrame(surface);
     }
   }
 
-  private void maybeRenotifyRenderedFirstFrame(Surface surface) {
+  private void maybeRenotifyRenderedFirstFrame() {
     if (renderedFirstFrame) {
       eventDispatcher.renderedFirstFrame(surface);
     }
@@ -863,6 +921,15 @@ public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
     reportedHeight = Format.NO_VALUE;
   }
 
+  private void maybeNotifyVideoSizeChanged(int width, int height) {
+    if (reportedWidth != width || reportedHeight != height) {
+      reportedWidth = width;
+      reportedHeight = height;
+      eventDispatcher.videoSizeChanged(
+          width, height, /* unappliedRotationDegrees= */ 0, /* pixelWidthHeightRatio= */ 1);
+    }
+  }
+
   private void maybeRenotifyVideoSizeChanged() {
     if (reportedWidth != Format.NO_VALUE || reportedHeight != Format.NO_VALUE) {
       eventDispatcher.videoSizeChanged(
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderGLSurfaceView.java b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderGLSurfaceView.java
new file mode 100644
index 0000000..99f3d07
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderGLSurfaceView.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import android.content.Context;
+import android.opengl.GLSurfaceView;
+import android.util.AttributeSet;
+import androidx.annotation.Nullable;
+
+/**
+ * GLSurfaceView for rendering video output. To render video in this view, call {@link
+ * #getVideoDecoderOutputBufferRenderer()} to get a {@link VideoDecoderOutputBufferRenderer} that
+ * will render video decoder output buffers in this view.
+ *
+ * <p>This view is intended for use only with extension renderers. For other use cases a {@link
+ * android.view.SurfaceView} or {@link android.view.TextureView} should be used instead.
+ */
+public class VideoDecoderGLSurfaceView extends GLSurfaceView {
+
+  private final VideoDecoderRenderer renderer;
+
+  /** @param context A {@link Context}. */
+  public VideoDecoderGLSurfaceView(Context context) {
+    this(context, /* attrs= */ null);
+  }
+
+  /**
+   * @param context A {@link Context}.
+   * @param attrs Custom attributes.
+   */
+  public VideoDecoderGLSurfaceView(Context context, @Nullable AttributeSet attrs) {
+    super(context, attrs);
+    renderer = new VideoDecoderRenderer(this);
+    setPreserveEGLContextOnPause(true);
+    setEGLContextClientVersion(2);
+    setRenderer(renderer);
+    setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
+  }
+
+  /** Returns the {@link VideoDecoderOutputBufferRenderer} that will render frames in this view. */
+  public VideoDecoderOutputBufferRenderer getVideoDecoderOutputBufferRenderer() {
+    return renderer;
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
index 3704a09..457aa30 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -21,12 +21,28 @@ import com.google.android.exoplayer2.decoder.OutputBuffer;
 import java.nio.ByteBuffer;
 
 /** Video decoder output buffer containing video frame data. */
-public abstract class VideoDecoderOutputBuffer extends OutputBuffer {
+public class VideoDecoderOutputBuffer extends OutputBuffer {
 
+  /** Buffer owner. */
+  public interface Owner {
+
+    /**
+     * Releases the buffer.
+     *
+     * @param outputBuffer Output buffer.
+     */
+    void releaseOutputBuffer(VideoDecoderOutputBuffer outputBuffer);
+  }
+
+  // LINT.IfChange
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
   public static final int COLORSPACE_BT709 = 2;
   public static final int COLORSPACE_BT2020 = 3;
+  // LINT.ThenChange(
+  //     ../../../../../../../../../../extensions/av1/src/main/jni/gav1_jni.cc,
+  //     ../../../../../../../../../../extensions/vp9/src/main/jni/vpx_jni.cc
+  // )
 
   /** Decoder private data. */
   public int decoderPrivate;
@@ -52,6 +68,22 @@ public abstract class VideoDecoderOutputBuffer extends OutputBuffer {
    */
   @Nullable public ByteBuffer supplementalData;
 
+  private final Owner owner;
+
+  /**
+   * Creates VideoDecoderOutputBuffer.
+   *
+   * @param owner Buffer owner.
+   */
+  public VideoDecoderOutputBuffer(Owner owner) {
+    this.owner = owner;
+  }
+
+  @Override
+  public void release() {
+    owner.releaseOutputBuffer(this);
+  }
+
   /**
    * Initializes the buffer.
    *
@@ -65,16 +97,19 @@ public abstract class VideoDecoderOutputBuffer extends OutputBuffer {
       long timeUs, @C.VideoOutputMode int mode, @Nullable ByteBuffer supplementalData) {
     this.timeUs = timeUs;
     this.mode = mode;
-    if (supplementalData != null) {
+    if (supplementalData != null && supplementalData.hasRemaining()) {
       addFlag(C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA);
       int size = supplementalData.limit();
       if (this.supplementalData == null || this.supplementalData.capacity() < size) {
         this.supplementalData = ByteBuffer.allocate(size);
+      } else {
+        this.supplementalData.clear();
       }
-      this.supplementalData.position(0);
       this.supplementalData.put(supplementalData);
       this.supplementalData.flip();
       supplementalData.position(0);
+    } else {
+      this.supplementalData = null;
     }
   }
 
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java
new file mode 100644
index 0000000..c57794f
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+/** Renders the {@link VideoDecoderOutputBuffer}. */
+public interface VideoDecoderOutputBufferRenderer {
+
+  /**
+   * Sets the output buffer to be rendered. The renderer is responsible for releasing the buffer.
+   *
+   * @param outputBuffer The output buffer to be rendered.
+   */
+  void setOutputBuffer(VideoDecoderOutputBuffer outputBuffer);
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
new file mode 100644
index 0000000..cb9c4eb
--- /dev/null
+++ b/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.GlUtil;
+import java.nio.FloatBuffer;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * GLSurfaceView.Renderer implementation that can render YUV Frames returned by a video decoder
+ * after decoding. It does the YUV to RGB color conversion in the Fragment Shader.
+ */
+/* package */ class VideoDecoderRenderer
+    implements GLSurfaceView.Renderer, VideoDecoderOutputBufferRenderer {
+
+  private static final float[] kColorConversion601 = {
+    1.164f, 1.164f, 1.164f,
+    0.0f, -0.392f, 2.017f,
+    1.596f, -0.813f, 0.0f,
+  };
+
+  private static final float[] kColorConversion709 = {
+    1.164f, 1.164f, 1.164f,
+    0.0f, -0.213f, 2.112f,
+    1.793f, -0.533f, 0.0f,
+  };
+
+  private static final float[] kColorConversion2020 = {
+    1.168f, 1.168f, 1.168f,
+    0.0f, -0.188f, 2.148f,
+    1.683f, -0.652f, 0.0f,
+  };
+
+  private static final String VERTEX_SHADER =
+      "varying vec2 interp_tc_y;\n"
+          + "varying vec2 interp_tc_u;\n"
+          + "varying vec2 interp_tc_v;\n"
+          + "attribute vec4 in_pos;\n"
+          + "attribute vec2 in_tc_y;\n"
+          + "attribute vec2 in_tc_u;\n"
+          + "attribute vec2 in_tc_v;\n"
+          + "void main() {\n"
+          + "  gl_Position = in_pos;\n"
+          + "  interp_tc_y = in_tc_y;\n"
+          + "  interp_tc_u = in_tc_u;\n"
+          + "  interp_tc_v = in_tc_v;\n"
+          + "}\n";
+  private static final String[] TEXTURE_UNIFORMS = {"y_tex", "u_tex", "v_tex"};
+  private static final String FRAGMENT_SHADER =
+      "precision mediump float;\n"
+          + "varying vec2 interp_tc_y;\n"
+          + "varying vec2 interp_tc_u;\n"
+          + "varying vec2 interp_tc_v;\n"
+          + "uniform sampler2D y_tex;\n"
+          + "uniform sampler2D u_tex;\n"
+          + "uniform sampler2D v_tex;\n"
+          + "uniform mat3 mColorConversion;\n"
+          + "void main() {\n"
+          + "  vec3 yuv;\n"
+          + "  yuv.x = texture2D(y_tex, interp_tc_y).r - 0.0625;\n"
+          + "  yuv.y = texture2D(u_tex, interp_tc_u).r - 0.5;\n"
+          + "  yuv.z = texture2D(v_tex, interp_tc_v).r - 0.5;\n"
+          + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);\n"
+          + "}\n";
+
+  private static final FloatBuffer TEXTURE_VERTICES =
+      GlUtil.createBuffer(new float[] {-1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f});
+  private final GLSurfaceView surfaceView;
+  private final int[] yuvTextures = new int[3];
+  private final AtomicReference<VideoDecoderOutputBuffer> pendingOutputBufferReference;
+
+  // Kept in field rather than a local variable in order not to get garbage collected before
+  // glDrawArrays uses it.
+  private FloatBuffer[] textureCoords;
+
+  private int program;
+  private int[] texLocations;
+  private int colorMatrixLocation;
+  private int[] previousWidths;
+  private int[] previousStrides;
+
+  @Nullable
+  private VideoDecoderOutputBuffer renderedOutputBuffer; // Accessed only from the GL thread.
+
+  public VideoDecoderRenderer(GLSurfaceView surfaceView) {
+    this.surfaceView = surfaceView;
+    pendingOutputBufferReference = new AtomicReference<>();
+    textureCoords = new FloatBuffer[3];
+    texLocations = new int[3];
+    previousWidths = new int[3];
+    previousStrides = new int[3];
+    for (int i = 0; i < 3; i++) {
+      previousWidths[i] = previousStrides[i] = -1;
+    }
+  }
+
+  @Override
+  public void onSurfaceCreated(GL10 unused, EGLConfig config) {
+    program = GlUtil.compileProgram(VERTEX_SHADER, FRAGMENT_SHADER);
+    GLES20.glUseProgram(program);
+    int posLocation = GLES20.glGetAttribLocation(program, "in_pos");
+    GLES20.glEnableVertexAttribArray(posLocation);
+    GLES20.glVertexAttribPointer(posLocation, 2, GLES20.GL_FLOAT, false, 0, TEXTURE_VERTICES);
+    texLocations[0] = GLES20.glGetAttribLocation(program, "in_tc_y");
+    GLES20.glEnableVertexAttribArray(texLocations[0]);
+    texLocations[1] = GLES20.glGetAttribLocation(program, "in_tc_u");
+    GLES20.glEnableVertexAttribArray(texLocations[1]);
+    texLocations[2] = GLES20.glGetAttribLocation(program, "in_tc_v");
+    GLES20.glEnableVertexAttribArray(texLocations[2]);
+    GlUtil.checkGlError();
+    colorMatrixLocation = GLES20.glGetUniformLocation(program, "mColorConversion");
+    GlUtil.checkGlError();
+    setupTextures();
+    GlUtil.checkGlError();
+  }
+
+  @Override
+  public void onSurfaceChanged(GL10 unused, int width, int height) {
+    GLES20.glViewport(0, 0, width, height);
+  }
+
+  @Override
+  public void onDrawFrame(GL10 unused) {
+    VideoDecoderOutputBuffer pendingOutputBuffer = pendingOutputBufferReference.getAndSet(null);
+    if (pendingOutputBuffer == null && renderedOutputBuffer == null) {
+      // There is no output buffer to render at the moment.
+      return;
+    }
+    if (pendingOutputBuffer != null) {
+      if (renderedOutputBuffer != null) {
+        renderedOutputBuffer.release();
+      }
+      renderedOutputBuffer = pendingOutputBuffer;
+    }
+    VideoDecoderOutputBuffer outputBuffer = renderedOutputBuffer;
+    // Set color matrix. Assume BT709 if the color space is unknown.
+    float[] colorConversion = kColorConversion709;
+    switch (outputBuffer.colorspace) {
+      case VideoDecoderOutputBuffer.COLORSPACE_BT601:
+        colorConversion = kColorConversion601;
+        break;
+      case VideoDecoderOutputBuffer.COLORSPACE_BT2020:
+        colorConversion = kColorConversion2020;
+        break;
+      case VideoDecoderOutputBuffer.COLORSPACE_BT709:
+      default:
+        break; // Do nothing
+    }
+    GLES20.glUniformMatrix3fv(colorMatrixLocation, 1, false, colorConversion, 0);
+
+    for (int i = 0; i < 3; i++) {
+      int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
+      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
+      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
+      GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
+      GLES20.glTexImage2D(
+          GLES20.GL_TEXTURE_2D,
+          0,
+          GLES20.GL_LUMINANCE,
+          outputBuffer.yuvStrides[i],
+          h,
+          0,
+          GLES20.GL_LUMINANCE,
+          GLES20.GL_UNSIGNED_BYTE,
+          outputBuffer.yuvPlanes[i]);
+    }
+
+    int[] widths = new int[3];
+    widths[0] = outputBuffer.width;
+    // TODO: Handle streams where chroma channels are not stored at half width and height
+    // compared to luma channel. See [Internal: b/142097774].
+    // U and V planes are being stored at half width compared to Y.
+    widths[1] = widths[2] = (widths[0] + 1) / 2;
+    for (int i = 0; i < 3; i++) {
+      // Set cropping of stride if either width or stride has changed.
+      if (previousWidths[i] != widths[i] || previousStrides[i] != outputBuffer.yuvStrides[i]) {
+        Assertions.checkState(outputBuffer.yuvStrides[i] != 0);
+        float widthRatio = (float) widths[i] / outputBuffer.yuvStrides[i];
+        // These buffers are consumed during each call to glDrawArrays. They need to be member
+        // variables rather than local variables in order not to get garbage collected.
+        textureCoords[i] =
+            GlUtil.createBuffer(
+                new float[] {0.0f, 0.0f, 0.0f, 1.0f, widthRatio, 0.0f, widthRatio, 1.0f});
+        GLES20.glVertexAttribPointer(
+            texLocations[i], 2, GLES20.GL_FLOAT, false, 0, textureCoords[i]);
+        previousWidths[i] = widths[i];
+        previousStrides[i] = outputBuffer.yuvStrides[i];
+      }
+    }
+
+    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
+    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+    GlUtil.checkGlError();
+  }
+
+  @Override
+  public void setOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {
+    VideoDecoderOutputBuffer oldPendingOutputBuffer =
+        pendingOutputBufferReference.getAndSet(outputBuffer);
+    if (oldPendingOutputBuffer != null) {
+      // The old pending output buffer will never be used for rendering, so release it now.
+      oldPendingOutputBuffer.release();
+    }
+    surfaceView.requestRender();
+  }
+
+  private void setupTextures() {
+    GLES20.glGenTextures(3, yuvTextures, 0);
+    for (int i = 0; i < 3; i++) {
+      GLES20.glUniform1i(GLES20.glGetUniformLocation(program, TEXTURE_UNIFORMS[i]), i);
+      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
+      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+      GLES20.glTexParameterf(
+          GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+      GLES20.glTexParameterf(
+          GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+    }
+    GlUtil.checkGlError();
+  }
+}
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java b/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
index b467d0f..746903a 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.video;
 
+import android.media.MediaFormat;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 
 /** A listener for metadata corresponding to video frame being rendered. */
@@ -26,6 +28,13 @@ public interface VideoFrameMetadataListener {
    * @param releaseTimeNs The wallclock time at which the frame should be displayed, in nanoseconds.
    *     If the platform API version of the device is less than 21, then this is the best effort.
    * @param format The format associated with the frame.
+   * @param mediaFormat The framework media format associated with the frame, or {@code null} if not
+   *     known or not applicable (e.g., because the frame was not output by a {@link
+   *     android.media.MediaCodec MediaCodec}).
    */
-  void onVideoFrameAboutToBeRendered(long presentationTimeUs, long releaseTimeNs, Format format);
+  void onVideoFrameAboutToBeRendered(
+      long presentationTimeUs,
+      long releaseTimeNs,
+      Format format,
+      @Nullable MediaFormat mediaFormat);
 }
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java b/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
index 70f30d3..e7dfd12 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.video;
 
+import static com.google.android.exoplayer2.util.Util.castNonNull;
+
 import android.os.Handler;
 import android.os.SystemClock;
 import android.view.Surface;
@@ -126,33 +128,34 @@ public interface VideoRendererEventListener {
 
     /** Invokes {@link VideoRendererEventListener#onVideoEnabled(DecoderCounters)}. */
     public void enabled(DecoderCounters decoderCounters) {
-      if (listener != null) {
-        handler.post(() -> listener.onVideoEnabled(decoderCounters));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onVideoEnabled(decoderCounters));
       }
     }
 
     /** Invokes {@link VideoRendererEventListener#onVideoDecoderInitialized(String, long, long)}. */
     public void decoderInitialized(
         String decoderName, long initializedTimestampMs, long initializationDurationMs) {
-      if (listener != null) {
+      if (handler != null) {
         handler.post(
             () ->
-                listener.onVideoDecoderInitialized(
-                    decoderName, initializedTimestampMs, initializationDurationMs));
+                castNonNull(listener)
+                    .onVideoDecoderInitialized(
+                        decoderName, initializedTimestampMs, initializationDurationMs));
       }
     }
 
     /** Invokes {@link VideoRendererEventListener#onVideoInputFormatChanged(Format)}. */
     public void inputFormatChanged(Format format) {
-      if (listener != null) {
-        handler.post(() -> listener.onVideoInputFormatChanged(format));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onVideoInputFormatChanged(format));
       }
     }
 
     /** Invokes {@link VideoRendererEventListener#onDroppedFrames(int, long)}. */
     public void droppedFrames(int droppedFrameCount, long elapsedMs) {
-      if (listener != null) {
-        handler.post(() -> listener.onDroppedFrames(droppedFrameCount, elapsedMs));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onDroppedFrames(droppedFrameCount, elapsedMs));
       }
     }
 
@@ -162,29 +165,30 @@ public interface VideoRendererEventListener {
         int height,
         final int unappliedRotationDegrees,
         final float pixelWidthHeightRatio) {
-      if (listener != null) {
+      if (handler != null) {
         handler.post(
             () ->
-                listener.onVideoSizeChanged(
-                    width, height, unappliedRotationDegrees, pixelWidthHeightRatio));
+                castNonNull(listener)
+                    .onVideoSizeChanged(
+                        width, height, unappliedRotationDegrees, pixelWidthHeightRatio));
       }
     }
 
     /** Invokes {@link VideoRendererEventListener#onRenderedFirstFrame(Surface)}. */
     public void renderedFirstFrame(@Nullable Surface surface) {
-      if (listener != null) {
-        handler.post(() -> listener.onRenderedFirstFrame(surface));
+      if (handler != null) {
+        handler.post(() -> castNonNull(listener).onRenderedFirstFrame(surface));
       }
     }
 
     /** Invokes {@link VideoRendererEventListener#onVideoDisabled(DecoderCounters)}. */
     public void disabled(DecoderCounters counters) {
       counters.ensureUpdated();
-      if (listener != null) {
+      if (handler != null) {
         handler.post(
             () -> {
               counters.ensureUpdated();
-              listener.onVideoDisabled(counters);
+              castNonNull(listener).onVideoDisabled(counters);
             });
       }
     }
diff --git a/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java b/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
index d1cf0ab..35804ad 100644
--- a/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
+++ b/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
@@ -22,6 +22,7 @@ import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -48,10 +49,11 @@ public class CameraMotionRenderer extends BaseRenderer {
   }
 
   @Override
+  @Capabilities
   public int supportsFormat(Format format) {
     return MimeTypes.APPLICATION_CAMERA_MOTION.equals(format.sampleMimeType)
-        ? FORMAT_HANDLED
-        : FORMAT_UNSUPPORTED_TYPE;
+        ? RendererCapabilities.create(FORMAT_HANDLED)
+        : RendererCapabilities.create(FORMAT_UNSUPPORTED_TYPE);
   }
 
   @Override
-- 
1.9.2.msysgit.0

